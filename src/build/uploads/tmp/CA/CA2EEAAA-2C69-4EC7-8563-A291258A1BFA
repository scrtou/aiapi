{"model":"Claude Opus 4.6","temperature":0,"messages":[{"role":"system","content":"You are Kilo Code, an experienced technical leader who is inquisitive and an excellent planner. Your goal is to gather information and get context to create a detailed plan for accomplishing the user's task, which the user will review and approve before they switch into another mode to implement the solution.\n\n====\n\nMARKDOWN RULES\n\nALL responses MUST show ANY `language construct` OR filename reference as clickable, exactly as [`filename OR language.declaration()`](relative/file/path.ext:line); line is required for `syntax` and optional for filename links. This applies to ALL markdown responses and ALSO those in attempt_completion\n\n====\n\nTOOL USE\n\nYou have access to a set of tools that are executed upon the user's approval. Use the provider-native tool-calling mechanism. Do not include XML markup or examples. You must use exactly one tool call per assistant response. Do not call zero tools or more than one tool in the same response.\n\n# Tool Use Guidelines\n\n1. Assess what information you already have and what information you need to proceed with the task.\n2. Choose the most appropriate tool based on the task and the tool descriptions provided. Assess if you need additional information to proceed, and which of the available tools would be most effective for gathering this information. For example using the list_files tool is more effective than running a command like `ls` in the terminal. It's critical that you think about each available tool and use the one that best fits the current step in the task.\n3. If multiple actions are needed, use one tool at a time per message to accomplish the task iteratively, with each tool use being informed by the result of the previous tool use. Do not assume the outcome of any tool use. Each step must be informed by the previous step's result.\n4. After each tool use, the user will respond with the result of that tool use. This result will provide you with the necessary information to continue your task or make further decisions. This response may include:\n\t - Information about whether the tool succeeded or failed, along with any reasons for failure.\n\t - Linter errors that may have arisen due to the changes you made, which you'll need to address.\n\t - New terminal output in reaction to the changes, which you may need to consider or act upon.\n\t - Any other relevant feedback or information related to the tool use.\n\nBy carefully considering the user's response after tool executions, you can react accordingly and make informed decisions about how to proceed with the task. This iterative process helps ensure the overall success and accuracy of your work.\n\n\n\n====\n\nCAPABILITIES\n\n- You have access to tools that let you execute CLI commands on the user's computer, list files, view source code definitions, regex search, read and write files, and ask follow-up questions. These tools help you effectively accomplish a wide range of tasks, such as writing code, making edits or improvements to existing files, understanding the current state of a project, performing system operations, and much more.\n- When the user initially gives you a task, a recursive list of all filepaths in the current workspace directory ('/home/useryx/codespace') will be included in environment_details. This provides an overview of the project's file structure, offering key insights into the project from directory/file names (how developers conceptualize and organize their code) and file extensions (the language used). This can also guide decision-making on which files to explore further. If you need to further explore directories such as outside the current workspace directory, you can use the list_files tool. If you pass 'true' for the recursive parameter, it will list files recursively. Otherwise, it will list files at the top level, which is better suited for generic directories where you don't necessarily need the nested structure, like the Desktop.\n- You can use the execute_command tool to run commands on the user's computer whenever you feel it can help accomplish the user's task. When you need to execute a CLI command, you must provide a clear explanation of what the command does. Prefer to execute complex CLI commands over creating executable scripts, since they are more flexible and easier to run. Interactive and long-running commands are allowed, since the commands are run in the user's VSCode terminal. The user may keep commands running in the background and you will be kept updated on their status along the way. Each command you execute is run in a new terminal instance.\n\n====\n\nMODES\n\n- These are the currently available modes:\n  * \"Architect\" mode (architect) - Use this mode when you need to plan, design, or strategize before implementation. Perfect for breaking down complex problems, creating technical specifications, designing system architecture, or brainstorming solutions before coding.\n  * \"Code\" mode (code) - Use this mode when you need to write, modify, or refactor code. Ideal for implementing features, fixing bugs, creating new files, or making code improvements across any programming language or framework.\n  * \"Ask\" mode (ask) - Use this mode when you need explanations, documentation, or answers to technical questions. Best for understanding concepts, analyzing existing code, getting recommendations, or learning about technologies without making changes.\n  * \"Debug\" mode (debug) - Use this mode when you're troubleshooting issues, investigating errors, or diagnosing problems. Specialized in systematic debugging, adding logging, analyzing stack traces, and identifying root causes before applying fixes.\n  * \"Orchestrator\" mode (orchestrator) - Use this mode for complex, multi-step projects that require coordination across different specialties. Ideal when you need to break down large tasks into subtasks, manage workflows, or coordinate work that spans multiple domains or expertise areas.\n  * \"Review\" mode (review) - Use this mode when you need to review code changes. Ideal for reviewing uncommitted work before committing, comparing your branch against main/develop, or analyzing changes before merging.\nIf the user asks you to create or edit a new mode for this project, you should read the instructions by using the fetch_instructions tool, like this:\n<fetch_instructions>\n<task>create_mode</task>\n</fetch_instructions>\n\n\n====\n\nRULES\n\n- The project base directory is: /home/useryx/codespace\n- All file paths must be relative to this directory. However, commands may change directories in terminals, so respect working directory specified by the response to execute_command.\n- You cannot `cd` into a different directory to complete a task. You are stuck operating from '/home/useryx/codespace', so be sure to pass in the correct 'path' parameter when using tools that require a path.\n- Do not use the ~ character or $HOME to refer to the home directory.\n- Before using the execute_command tool, you must first think about the SYSTEM INFORMATION context provided to understand the user's environment and tailor your commands to ensure they are compatible with their system. You must also consider if the command you need to run should be executed in a specific directory outside of the current working directory '/home/useryx/codespace', and if so prepend with `cd`'ing into that directory && then executing the command (as one command since you are stuck operating from '/home/useryx/codespace'). For example, if you needed to run `npm install` in a project outside of '/home/useryx/codespace', you would need to prepend with a `cd` i.e. pseudocode for this would be `cd (path to project) && (command, in this case npm install)`.\n\n- Some modes have restrictions on which files they can edit. If you attempt to edit a restricted file, the operation will be rejected with a FileRestrictionError that will specify which file patterns are allowed for the current mode.\n- Be sure to consider the type of project (e.g. Python, JavaScript, web application) when determining the appropriate structure and files to include. Also consider what files may be most relevant to accomplishing the task, for example looking at a project's manifest file would help you understand the project's dependencies, which you could incorporate into any code you write.\n  * For example, in architect mode trying to edit app.js would be rejected because architect mode can only edit files matching \"\\.md$\"\n- When making changes to code, always consider the context in which the code is being used. Ensure that your changes are compatible with the existing codebase and that they follow the project's coding standards and best practices.\n- Do not ask for more information than necessary. Use the tools provided to accomplish the user's request efficiently and effectively. When you've completed your task, you must use the attempt_completion tool to present the result to the user. The user may provide feedback, which you can use to make improvements and try again.\n- You are only allowed to ask the user questions using the ask_followup_question tool. Use this tool only when you need additional details to complete a task, and be sure to use a clear and concise question that will help you move forward with the task. When you ask a question, provide the user with 2-4 suggested answers based on your question so they don't need to do so much typing. The suggestions should be specific, actionable, and directly related to the completed task. They should be ordered by priority or logical sequence. However if you can use the available tools to avoid having to ask the user questions, you should do so. For example, if the user mentions a file that may be in an outside directory like the Desktop, you should use the list_files tool to list the files in the Desktop and check if the file they are talking about is there, rather than asking the user to provide the file path themselves.\n- When executing commands, if you don't see the expected output, assume the terminal executed the command successfully and proceed with the task. The user's terminal may be unable to stream the output back properly. If you absolutely need to see the actual terminal output, use the ask_followup_question tool to request the user to copy and paste it back to you.\n- The user may provide a file's contents directly in their message, in which case you shouldn't use the read_file tool to get the file contents again since you already have it.\n- Your goal is to try to accomplish the user's task, NOT engage in a back and forth conversation.\n- NEVER end attempt_completion result with a question or request to engage in further conversation! Formulate the end of your result in a way that is final and does not require further input from the user.\n- You are STRICTLY FORBIDDEN from starting your messages with \"Great\", \"Certainly\", \"Okay\", \"Sure\". You should NOT be conversational in your responses, but rather direct and to the point. For example you should NOT say \"Great, I've updated the CSS\" but instead something like \"I've updated the CSS\". It is important you be clear and technical in your messages.\n- When presented with images, utilize your vision capabilities to thoroughly examine them and extract meaningful information. Incorporate these insights into your thought process as you accomplish the user's task.\n- At the end of each user message, you will automatically receive environment_details. This information is not written by the user themselves, but is auto-generated to provide potentially relevant context about the project structure and environment. While this information can be valuable for understanding the project context, do not treat it as a direct part of the user's request or response. Use it to inform your actions and decisions, but don't assume the user is explicitly asking about or referring to this information unless they clearly do so in their message. When using environment_details, explain your actions clearly to ensure the user understands, as they may not be aware of these details.\n- Before executing commands, check the \"Actively Running Terminals\" section in environment_details. If present, consider how these active processes might impact your task. For example, if a local development server is already running, you wouldn't need to start it again. If no active terminals are listed, proceed with command execution as normal.\n- MCP operations should be used one at a time, similar to other tool usage. Wait for confirmation of success before proceeding with additional operations.\n- It is critical you wait for the user's response after each tool use, in order to confirm the success of the tool use. For example, if asked to make a todo app, you would create a file, wait for the user's response it was created successfully, then create another file if needed, wait for the user's response it was created successfully, etc.\n\n====\n\nSYSTEM INFORMATION\n\nOperating System: Linux 6.1\nDefault Shell: /bin/bash\nHome Directory: /home/useryx\nCurrent Workspace Directory: /home/useryx/codespace\n\nThe Current Workspace Directory is the active VS Code project directory, and is therefore the default directory for all tool operations. New terminals will be created in the current workspace directory, however if you change directories in a terminal it will then have a different working directory; changing directories in a terminal does not modify the workspace directory, because you do not have access to change the workspace directory. When the user initially gives you a task, a recursive list of all filepaths in the current workspace directory ('/test/path') will be included in environment_details. This provides an overview of the project's file structure, offering key insights into the project from directory/file names (how developers conceptualize and organize their code) and file extensions (the language used). This can also guide decision-making on which files to explore further. If you need to further explore directories such as outside the current workspace directory, you can use the list_files tool. If you pass 'true' for the recursive parameter, it will list files recursively. Otherwise, it will list files at the top level, which is better suited for generic directories where you don't necessarily need the nested structure, like the Desktop.\n\n====\n\nOBJECTIVE\n\nYou accomplish a given task iteratively, breaking it down into clear steps and working through them methodically.\n\n1. Analyze the user's task and set clear, achievable goals to accomplish it. Prioritize these goals in a logical order.\n2. Work through these goals sequentially, utilizing available tools one at a time as necessary. Each goal should correspond to a distinct step in your problem-solving process. You will be informed on the work completed and what's remaining as you go.\n3. Remember, you have extensive capabilities with access to a wide range of tools that can be used in powerful and clever ways as necessary to accomplish each goal. Before calling a tool, do some analysis. First, analyze the file structure provided in environment_details to gain context and insights for proceeding effectively. Next, think about which of the provided tools is the most relevant tool to accomplish the user's task. Go through each of the required parameters of the relevant tool and determine if the user has directly provided or given enough information to infer a value. When deciding if the parameter can be inferred, carefully consider all the context to see if it supports a specific value. If all of the required parameters are present or can be reasonably inferred, proceed with the tool use. BUT, if one of the values for a required parameter is missing, DO NOT invoke the tool (not even with fillers for the missing params) and instead, ask the user to provide the missing parameters using the ask_followup_question tool. DO NOT ask for more information on optional parameters if it is not provided.\n4. Once you've completed the user's task, you must use the attempt_completion tool to present the result of the task to the user.\n5. The user may provide feedback, which you can use to make improvements and try again. But DO NOT continue in pointless back and forth conversations, i.e. don't end your responses with questions or offers for further assistance.\n\n\n====\n\nUSER'S CUSTOM INSTRUCTIONS\n\nThe following additional instructions are provided by the user, and should be followed to the best of your ability.\n\nLanguage Preference:\nYou should always speak and think in the \"简体中文\" (zh-CN) language unless the user gives you instructions below to do otherwise.\n\nMode-specific Instructions:\n1. Do some information gathering (using provided tools) to get more context about the task.\n\n2. You should also ask the user clarifying questions to get a better understanding of the task.\n\n3. Once you've gained more context about the user's request, break down the task into clear, actionable steps and create a todo list using the `update_todo_list` tool. Each todo item should be:\n   - Specific and actionable\n   - Listed in logical execution order\n   - Focused on a single, well-defined outcome\n   - Clear enough that another mode could execute it independently\n\n   **Note:** If the `update_todo_list` tool is not available, write the plan to a markdown file (e.g., `plan.md` or `todo.md`) instead.\n\n4. As you gather more information or discover new requirements, update the todo list to reflect the current understanding of what needs to be accomplished.\n\n5. Ask the user if they are pleased with this plan, or if they would like to make any changes. Think of this as a brainstorming session where you can discuss the task and refine the todo list.\n\n6. Include Mermaid diagrams if they help clarify complex workflows or system architecture. Please avoid using double quotes (\"\") and parentheses () inside square brackets ([]) in Mermaid diagrams, as this can cause parsing errors.\n\n7. Use the switch_mode tool to request switching to another mode when you need to edit non-markdown files (like source code files: .ts, .js, .py, .java, etc.) or execute commands. You CAN directly create and edit markdown files (.md) without switching modes.\n\n**IMPORTANT: Focus on creating clear, actionable todo lists rather than lengthy markdown documents. Use the todo list as your primary planning tool to track and organize the work that needs to be done.**\n\n**CRITICAL: Never provide level of effort time estimates (e.g., hours, days, weeks) for tasks. Focus solely on breaking down the work into clear, actionable steps without estimating how long they will take.**\n\nUnless told otherwise, if you want to save a plan file, put it in the /plans directory\n"},{"role":"user","content":[{"type":"text","text":"<task>\n你好\n</task>"},{"type":"text","text":"<environment_details>\n# VSCode Visible Files\naiapi/src/build/logs/aiapi.log\n\n# VSCode Open Tabs\naiapi/src/build/logs/aiapi.log,aiapi/src/sessionManager/GenerationService.cpp,aiapi/src/build/logs/1.txt,aiapi/src/sessionManager/XmlTagToolCallCodec.cpp,aiapi/src/sessionManager/XmlTagToolCallCodec.h,aiapi/src/apipoint/chaynsapi/chaynsapi.cpp,aiapi/src/apipoint/chaynsapi/chaynsapi.h,aiapi/doc/aiapi_callflow_and_api_examples.md,aiapi/README.md,aiapi/src/controllers/AiApi.cc,aiapi/src/accountManager/accountManager.h,aiapi/src/accountManager/accountManager.cpp,aiapi_web/src/components/LogViewer.tsx,aiapi_web/src/components/LogViewer.css,aiapi_web/src/App.tsx,aiapi_web/src/components/AccountManager.tsx,aiapi_web/src/components/AccountManager.css,aiapi/src/controllers/AiApi.h,aiapi/src/main.cc,aiapi/src/config.json\n\n# Current Time\nCurrent time in ISO 8601 UTC format: 2026-02-07T15:01:58.164Z\nUser time zone: America/Los_Angeles, UTC-8:00\n\n# Current Cost\n$0.00\n\n# Current Mode\n<slug>architect</slug>\n<name>Architect</name>\n<model>Claude Opus 4.6</model>\n<tool_format>native</tool_format>\n\n\n# Current Workspace Directory (/home/useryx/codespace) Files\naiapi.tar\nCC-Switch-v3.10.2-Linux.deb\n.claude/\n.vscode/\naiapi/\naiapi_tool/\naiapi_tool/docker-compose.yml\naiapi_tool/Dockerfile\naiapi_tool/README.md\naiapi_tool/requirements.txt\naiapi_tool/src/__init__.py\naiapi_tool/src/autoregister.py\naiapi_tool/src/duckmail_client.py\naiapi_tool/src/login_client.cpp\naiapi_tool/src/loginlocal.py\naiapi_tool/src/loginremote.py\naiapi_web/\naiapi_web/.eslintrc.cjs\naiapi_web/.gitignore\naiapi_web/index.html\naiapi_web/package-lock.json\naiapi_web/package.json\naiapi_web/tsconfig.json\naiapi_web/tsconfig.node.json\naiapi_web/vite.config.ts\naiapi_web/vps-deployment-guide.md\naiapi_web/src/App.css\naiapi_web/src/App.tsx\naiapi_web/src/index.css\naiapi_web/src/main.tsx\naiapi_web/src/vite-env.d.ts\naiapi_web/src/components/AccountManager.css\naiapi_web/src/components/AccountManager.tsx\naiapi_web/src/components/ChannelManager.css\naiapi_web/src/components/ChannelManager.tsx\naiapi_web/src/components/ErrorMonitor.css\naiapi_web/src/components/ErrorMonitor.tsx\naiapi_web/src/components/LogViewer.css\naiapi_web/src/components/LogViewer.tsx\naiapi_web/src/components/ModelList.css\naiapi_web/src/components/ModelList.tsx\naiapi_web/src/components/ServiceStatusMonitor.css\naiapi_web/src/components/ServiceStatusMonitor.tsx\naiapi_web/src/components/Settings.css\naiapi_web/src/components/Settings.tsx\naiapi_web/src/services/api.ts\naiapi_web/src/types/index.ts\naiapi_web/src/utils/config.ts\nauto_regist/\nauto_regist/autoregister_design.md\nauto_regist/development_plan.md\naxonhub/\naxonhub/.pre-commit-config.yaml\naxonhub/CLAUDE.md\naxonhub/config.example.yml\naxonhub/go.mod\naxonhub/docs/axonhub-architecture-light.svg\naxonhub/docs/axonhub-architecture.svg\naxonhub/docs/transformation-flow.svg\naxonhub/docs/en/api-reference/image-generation.md\naxonhub/docs/en/api-reference/unified-api.md\naxonhub/docs/en/deployment/configuration.md\naxonhub/docs/en/deployment/docker.md\naxonhub/docs/en/development/development.md\naxonhub/docs/en/development/erd.md\naxonhub/docs/en/development/git-workflow.md\naxonhub/docs/en/development/transformation-flow.md\naxonhub/docs/en/faq/faq.md\naxonhub/docs/en/getting-started/quick-start.md\naxonhub/docs/en/guides/antigravity.md\naxonhub/docs/en/guides/api-key-profiles.md\naxonhub/docs/en/guides/channel-management.md\naxonhub/docs/en/guides/claude-code-integration.md\naxonhub/docs/en/guides/codex-integration.md\naxonhub/docs/en/guides/load-balance.md\naxonhub/docs/en/guides/model-management.md\naxonhub/docs/en/guides/permissions.md\naxonhub/docs/en/guides/request-override.md\naxonhub/docs/en/guides/tracing.md\naxonhub/docs/screenshots/axonhub-channels.png\naxonhub/docs/screenshots/axonhub-dashboard.png\naxonhub/docs/screenshots/axonhub-model-price.png\naxonhub/docs/screenshots/axonhub-models.png\naxonhub/docs/screenshots/axonhub-profiles.png\naxonhub/docs/screenshots/axonhub-requests.png\naxonhub/docs/screenshots/axonhub-system.png\naxonhub/docs/screenshots/axonhub-trace.png\naxonhub/docs/screenshots/axonhub-usage-logs.png\naxonhub/docs/screenshots/axonhub-users.png\naxonhub/docs/zh/api-reference/image-generation.md\naxonhub/docs/zh/api-reference/unified-api.md\naxonhub/docs/zh/deployment/configuration.md\naxonhub/docs/zh/deployment/docker.md\naxonhub/docs/zh/development/development.md\naxonhub/docs/zh/development/erd.md\naxonhub/docs/zh/development/git-workflow.md\naxonhub/docs/zh/development/transformation-flow.md\naxonhub/docs/zh/faq/faq.md\naxonhub/docs/zh/getting-started/quick-start.md\naxonhub/docs/zh/guides/api-key-profiles.md\naxonhub/docs/zh/guides/channel-management.md\naxonhub/docs/zh/guides/claude-code-integration.md\naxonhub/docs/zh/guides/codex-integration.md\naxonhub/docs/zh/guides/load-balance.md\naxonhub/docs/zh/guides/model-management.md\naxonhub/docs/zh/guides/permissions.md\naxonhub/docs/zh/guides/request-override.md\naxonhub/docs/zh/guides/tracing.md\naxonhub/examples/openapi/go.mod\naxonhub/examples/openapi/go.sum\naxonhub/examples/openapi/main.go\naxonhub/examples/openapi/README.md\naxonhub/examples/openapi/graphql/api_key.graphql\naxonhub/examples/openapi/graphql/generated.go\naxonhub/examples/openapi/graphql/genqlient.yaml\naxonhub/examples/openapi/graphql/openapi.graphql\naxonhub/frontend/.env.development\naxonhub/frontend/.env.example\naxonhub/frontend/.gitignore\naxonhub/frontend/.prettierignore\naxonhub/frontend/.prettierrc\naxonhub/frontend/eslint.config.js\naxonhub/frontend/package.json\naxonhub/frontend/playwright.config.ts\naxonhub/frontend/tsconfig.app.json\naxonhub/frontend/public/favicon.ico\naxonhub/frontend/public/logo.jpg\naxonhub/frontend/src/routes/__root.tsx\naxonhub/frontend/src/routes/(errors)/503.tsx\naxonhub/frontend/tests/api-keys.spec.ts\naxonhub/frontend/tests/auth.utils.ts\naxonhub/frontend/tests/channels.spec.ts\naxonhub/frontend/tests/data-storages.spec.ts\naxonhub/frontend/tests/models.spec.ts\naxonhub/frontend/tests/project-roles.spec.ts\naxonhub/frontend/tests/project-users.spec.ts\naxonhub/frontend/tests/projects.spec.ts\naxonhub/frontend/tests/roles.spec.ts\naxonhub/frontend/tests/setup.spec.ts\naxonhub/frontend/tests/system.spec.ts\naxonhub/frontend/tests/usage-logs.spec.ts\naxonhub/frontend/tests/users-projects.spec.ts\naxonhub/frontend/tests/users-roles.spec.ts\naxonhub/frontend/tests/users.spec.ts\ndrogon/\ndrogon/.clang-format\ndrogon/.Doxyfile\ndrogon/.gitignore\ndrogon/.gitmodules\ndrogon/build.sh\ndrogon/ChangeLog.md\ndrogon/CMakeLists.txt\ndrogon/conanfile.txt\ndrogon/config.example.json\ndrogon/CONTRIBUTING.md\ndrogon/CPPLINT.cfg\ndrogon/format.sh\ndrogon/LICENSE\ndrogon/package.xml\ndrogon/README.md\ndrogon/README.zh-CN.md\ndrogon/README.zh-TW.md\ndrogon/test.sh\ndrogon/cmake/DrogonUtilities.cmake\ndrogon/cmake/Packages.cmake\ndrogon/cmake/ParseAndAddDrogonTests.cmake\ndrogon/cmake/templates/config.h.in\ndrogon/cmake/templates/DrogonConfig.cmake.in\ndrogon/cmake/templates/version.h.in\ndrogon/cmake/tests/check_has_std_filesystem_path.cc\ndrogon/cmake/tests/normal_uuid_lib_test.cc\ndrogon/cmake/tests/ossp_uuid_lib_test.cc\ndrogon/cmake/tests/test_libpq_batch_mode.cc\ndrogon/cmake_modules/FindBrotli.cmake\ndrogon/cmake_modules/Findcoz-profiler.cmake\ndrogon/cmake_modules/FindFilesystem.cmake\ndrogon/cmake_modules/FindHiredis.cmake\ndrogon/cmake_modules/FindJsoncpp.cmake\ndrogon/cmake_modules/FindMySQL.cmake\ndrogon/cmake_modules/Findpg.cmake\ndrogon/cmake_modules/FindSQLite3.cmake\ndrogon/cmake_modules/FindUUID.cmake\ndrogon/docker/alpine/Dockerfile\ndrogon/docker/alpine/README.md\ndrogon/docker/arch/Dockerfile\ndrogon/docker/ubuntu/Dockerfile\ndrogon/drogon_ctl/CMakeLists.txt\ndrogon/drogon_ctl/cmd.cc\ndrogon/drogon_ctl/cmd.h\ndrogon/drogon_ctl/CommandHandler.h\ndrogon/drogon_ctl/CopyDlls.cmake\ndrogon/drogon_ctl/create_controller.cc\ndrogon/drogon_ctl/create_controller.h\ndrogon/drogon_ctl/create_filter.cc\ndrogon/drogon_ctl/create_filter.h\ndrogon/drogon_ctl/create_model.cc\ndrogon/drogon_ctl/create_model.h\ndrogon/drogon_ctl/create_plugin.cc\ndrogon/drogon_ctl/create_plugin.h\ndrogon/drogon_ctl/create_project.cc\n\n(File list truncated. Use list_files on specific subdirectories if you need to explore further.)\nYou have not created a todo list yet. Create one with `update_todo_list` if your task is complicated or involves multiple steps.\n</environment_details>"}]},{"role":"assistant","content":"⁠⁠‌﻿‍‍‌﻿‌﻿‌‌﻿﻿​﻿​‌​﻿‌﻿​﻿‌﻿​﻿​​​﻿‌​​﻿‌﻿​﻿‌‍​﻿‌‌​﻿​﻿​﻿​﻿​﻿​﻿​﻿‌﻿​﻿​​‌‌﻿﻿​﻿​﻿​﻿​‌​﻿‌‌​﻿‌‌⁠⁠","tool_calls":[{"id":"call_be861677c1db55282545c334","type":"function","function":{"name":"ask_followup_question","arguments":"{\"question\":\"你好！我是 Architect 模式下的助手，可以帮你进行项目规划和架构设计。\\n\\n我注意到你的工作区中包含多个项目：\\n- **aiapi/** - C++ AI API 后端服务\\n- **aiapi_web/** - React/TypeScript 管理前端\\n- **aiapi_tool/** - Python/Docker 工具集\\n- **axonhub/** - Go 语言项目（含前端）\\n- **drogon/** - Drogon C++ Web 框架\\n- **auto_regist/** - 自动注册相关文档\\n\\n请问你需要我帮你完成什么任务？\",\"follow_up\":[{\"mode\":\"\",\"text\":\"我想对 aiapi 项目进行功能开发或改进\"},{\"mode\":\"\",\"text\":\"我想对 axonhub 项目进行规划或修改\"},{\"mode\":\"\",\"text\":\"我想了解当前项目的整体架构\"},{\"mode\":\"\",\"text\":\"我有其他任务，让我来描述一下\"}]}"}}]},{"role":"tool","tool_call_id":"call_be861677c1db55282545c334","content":"<answer>\n'aiapi/' (see below for folder content) 解析这个项目\n</answer>\n\n<folder_content path=\"aiapi/\">\n├── .dockerignore\n├── .git/\n├── .gitignore\n├── CMakeLists.txt\n├── Dockerfile\n├── README.md\n├── config.example.json\n├── doc/\n├── docker-compose.env.yml\n├── docker-compose.volume.yml\n├── requirements.txt\n└── src/\n\n<file_content path=\"aiapi/.dockerignore\">\n 1 | .git\n 2 | .gitignore\n 3 | build/\n 4 | src/build/\n 5 | **/build/\n 6 | *.o\n 7 | *.so\n 8 | *.a\n 9 | *.log\n10 | README.md\n11 | Dockerfile\n12 | .dockerignore\n\n</file_content>\n\n<file_content path=\"aiapi/.gitignore\">\n  1 | # Created by https://www.toptal.com/developers/gitignore/api/intellij+all,visualstudio,visualstudiocode,cmake,c,c++\n  2 | # Edit at https://www.toptal.com/developers/gitignore?templates=intellij+all,visualstudio,visualstudiocode,cmake,c,c++\n  3 | \n  4 | ### C ###\n  5 | # Prerequisites\n  6 | *.d\n  7 | \n  8 | # Object files\n  9 | *.o\n 10 | *.ko\n 11 | *.obj\n 12 | *.elf\n 13 | \n 14 | # Linker output\n 15 | *.ilk\n 16 | *.map\n 17 | *.exp\n 18 | \n 19 | # Precompiled Headers\n 20 | *.gch\n 21 | *.pch\n 22 | \n 23 | # Libraries\n 24 | *.lib\n 25 | *.a\n 26 | *.la\n 27 | *.lo\n 28 | \n 29 | # Shared objects (inc. Windows DLLs)\n 30 | *.dll\n 31 | *.so\n 32 | *.so.*\n 33 | *.dylib\n 34 | \n 35 | # Executables\n 36 | *.exe\n 37 | *.out\n 38 | *.app\n 39 | *.i*86\n 40 | *.x86_64\n 41 | *.hex\n 42 | \n 43 | # Debug files\n 44 | *.dSYM/\n 45 | *.su\n 46 | *.idb\n 47 | *.pdb\n 48 | \n 49 | # Kernel Module Compile Results\n 50 | *.mod*\n 51 | *.cmd\n 52 | .tmp_versions/\n 53 | modules.order\n 54 | Module.symvers\n 55 | Mkfile.old\n 56 | dkms.conf\n 57 | \n 58 | ### C++ ###\n 59 | # Prerequisites\n 60 | \n 61 | # Compiled Object files\n 62 | *.slo\n 63 | \n 64 | # Precompiled Headers\n 65 | \n 66 | # Linker files\n 67 | \n 68 | # Debugger Files\n 69 | \n 70 | # Compiled Dynamic libraries\n 71 | \n 72 | # Fortran module files\n 73 | *.mod\n 74 | *.smod\n 75 | \n 76 | # Compiled Static libraries\n 77 | *.lai\n 78 | \n 79 | # Executables\n 80 | \n 81 | ### CMake ###\n 82 | CMakeLists.txt.user\n 83 | CMakeCache.txt\n 84 | CMakeFiles\n 85 | CMakeScripts\n 86 | Testing\n 87 | Makefile\n 88 | cmake_install.cmake\n 89 | install_manifest.txt\n 90 | compile_commands.json\n 91 | CTestTestfile.cmake\n 92 | _deps\n 93 | CMakeUserPresets.json\n 94 | \n 95 | ### CMake Patch ###\n 96 | # External projects\n 97 | *-prefix/\n 98 | \n 99 | ### Intellij+all ###\n100 | # Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio, WebStorm and Rider\n101 | # Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839\n102 | \n103 | # User-specific stuff\n104 | .idea/**/workspace.xml\n105 | .idea/**/tasks.xml\n106 | .idea/**/usage.statistics.xml\n107 | .idea/**/dictionaries\n108 | .idea/**/shelf\n109 | \n110 | # Generated files\n111 | .idea/**/contentModel.xml\n112 | \n113 | # Sensitive or high-churn files\n114 | .idea/**/dataSources/\n115 | .idea/**/dataSources.ids\n116 | .idea/**/dataSources.local.xml\n117 | .idea/**/sqlDataSources.xml\n118 | .idea/**/dynamic.xml\n119 | .idea/**/uiDesigner.xml\n120 | .idea/**/dbnavigator.xml\n121 | \n122 | # Gradle\n123 | .idea/**/gradle.xml\n124 | .idea/**/libraries\n125 | \n126 | # Gradle and Maven with auto-import\n127 | # When using Gradle or Maven with auto-import, you should exclude module files,\n128 | # since they will be recreated, and may cause churn.  Uncomment if using\n129 | # auto-import.\n130 | # .idea/artifacts\n131 | # .idea/compiler.xml\n132 | # .idea/jarRepositories.xml\n133 | # .idea/modules.xml\n134 | # .idea/*.iml\n135 | # .idea/modules\n136 | # *.iml\n137 | # *.ipr\n138 | \n139 | # CMake\n140 | cmake-build-*/\n141 | \n142 | # Mongo Explorer plugin\n143 | .idea/**/mongoSettings.xml\n144 | \n145 | # File-based project format\n146 | *.iws\n147 | \n148 | # IntelliJ\n149 | out/\n150 | \n151 | # mpeltonen/sbt-idea plugin\n152 | .idea_modules/\n153 | \n154 | # JIRA plugin\n155 | atlassian-ide-plugin.xml\n156 | \n157 | # Cursive Clojure plugin\n158 | .idea/replstate.xml\n159 | \n160 | # Crashlytics plugin (for Android Studio and IntelliJ)\n161 | com_crashlytics_export_strings.xml\n162 | crashlytics.properties\n163 | crashlytics-build.properties\n164 | fabric.properties\n165 | \n166 | # Editor-based Rest Client\n167 | .idea/httpRequests\n168 | \n169 | # Android studio 3.1+ serialized cache file\n170 | .idea/caches/build_file_checksums.ser\n171 | \n172 | ### Intellij+all Patch ###\n173 | # Ignores the whole .idea folder and all .iml files\n174 | # See https://github.com/joeblau/gitignore.io/issues/186 and https://github.com/joeblau/gitignore.io/issues/360\n175 | \n176 | .idea/\n177 | \n178 | # Reason: https://github.com/joeblau/gitignore.io/issues/186#issuecomment-249601023\n179 | \n180 | *.iml\n181 | modules.xml\n182 | .idea/misc.xml\n183 | *.ipr\n184 | \n185 | # Sonarlint plugin\n186 | .idea/sonarlint\n187 | \n188 | ### VisualStudioCode ###\n189 | .vscode/*\n190 | !.vscode/tasks.json\n191 | !.vscode/launch.json\n192 | *.code-workspace\n193 | \n194 | ### VisualStudioCode Patch ###\n195 | # Ignore all local history of files\n196 | .history\n197 | .ionide\n198 | \n199 | ### VisualStudio ###\n200 | ## Ignore Visual Studio temporary files, build results, and\n201 | ## files generated by popular Visual Studio add-ons.\n202 | ##\n203 | ## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\n204 | \n205 | # User-specific files\n206 | *.rsuser\n207 | *.suo\n208 | *.user\n209 | *.userosscache\n210 | *.sln.docstates\n211 | \n212 | # User-specific files (MonoDevelop/Xamarin Studio)\n213 | *.userprefs\n214 | \n215 | # Mono auto generated files\n216 | mono_crash.*\n217 | \n218 | # Build results\n219 | [Dd]ebug/\n220 | [Dd]ebugPublic/\n221 | [Rr]elease/\n222 | [Rr]eleases/\n223 | x64/\n224 | x86/\n225 | [Ww][Ii][Nn]32/\n226 | [Aa][Rr][Mm]/\n227 | [Aa][Rr][Mm]64/\n228 | bld/\n229 | [Bb]in/\n230 | [Oo]bj/\n231 | [Ll]og/\n232 | [Ll]ogs/\n233 | \n234 | # Visual Studio 2015/2017 cache/options directory\n235 | .vs/\n236 | # Uncomment if you have tasks that create the project's static files in wwwroot\n237 | #wwwroot/\n238 | \n239 | # Visual Studio 2017 auto generated files\n240 | Generated\\ Files/\n241 | \n242 | # MSTest test Results\n243 | [Tt]est[Rr]esult*/\n244 | [Bb]uild[Ll]og.*\n245 | \n246 | # NUnit\n247 | *.VisualState.xml\n248 | TestResult.xml\n249 | nunit-*.xml\n250 | \n251 | # Build Results of an ATL Project\n252 | [Dd]ebugPS/\n253 | [Rr]eleasePS/\n254 | dlldata.c\n255 | \n256 | # Benchmark Results\n257 | BenchmarkDotNet.Artifacts/\n258 | \n259 | # .NET Core\n260 | project.lock.json\n261 | project.fragment.lock.json\n262 | artifacts/\n263 | \n264 | # ASP.NET Scaffolding\n265 | ScaffoldingReadMe.txt\n266 | \n267 | # StyleCop\n268 | StyleCopReport.xml\n269 | \n270 | # Files built by Visual Studio\n271 | *_i.c\n272 | *_p.c\n273 | *_h.h\n274 | *.meta\n275 | *.iobj\n276 | *.ipdb\n277 | *.pgc\n278 | *.pgd\n279 | *.rsp\n280 | *.sbr\n281 | *.tlb\n282 | *.tli\n283 | *.tlh\n284 | *.tmp\n285 | *.tmp_proj\n286 | *_wpftmp.csproj\n287 | *.log\n288 | *.vspscc\n289 | *.vssscc\n290 | .builds\n291 | *.pidb\n292 | *.svclog\n293 | *.scc\n294 | \n295 | # Chutzpah Test files\n296 | _Chutzpah*\n297 | \n298 | # Visual C++ cache files\n299 | ipch/\n300 | *.aps\n301 | *.ncb\n302 | *.opendb\n303 | *.opensdf\n304 | *.sdf\n305 | *.cachefile\n306 | *.VC.db\n307 | *.VC.VC.opendb\n308 | \n309 | # Visual Studio profiler\n310 | *.psess\n311 | *.vsp\n312 | *.vspx\n313 | *.sap\n314 | \n315 | # Visual Studio Trace Files\n316 | *.e2e\n317 | \n318 | # TFS 2012 Local Workspace\n319 | $tf/\n320 | \n321 | # Guidance Automation Toolkit\n322 | *.gpState\n323 | \n324 | # ReSharper is a .NET coding add-in\n325 | _ReSharper*/\n326 | *.[Rr]e[Ss]harper\n327 | *.DotSettings.user\n328 | \n329 | # TeamCity is a build add-in\n330 | _TeamCity*\n331 | \n332 | # DotCover is a Code Coverage Tool\n333 | *.dotCover\n334 | \n335 | # AxoCover is a Code Coverage Tool\n336 | .axoCover/*\n337 | !.axoCover/settings.json\n338 | \n339 | # Coverlet is a free, cross platform Code Coverage Tool\n340 | coverage*[.json, .xml, .info]\n341 | \n342 | # Visual Studio code coverage results\n343 | *.coverage\n344 | *.coveragexml\n345 | \n346 | # NCrunch\n347 | _NCrunch_*\n348 | .*crunch*.local.xml\n349 | nCrunchTemp_*\n350 | \n351 | # MightyMoose\n352 | *.mm.*\n353 | AutoTest.Net/\n354 | \n355 | # Web workbench (sass)\n356 | .sass-cache/\n357 | \n358 | # Installshield output folder\n359 | [Ee]xpress/\n360 | \n361 | # DocProject is a documentation generator add-in\n362 | DocProject/buildhelp/\n363 | DocProject/Help/*.HxT\n364 | DocProject/Help/*.HxC\n365 | DocProject/Help/*.hhc\n366 | DocProject/Help/*.hhk\n367 | DocProject/Help/*.hhp\n368 | DocProject/Help/Html2\n369 | DocProject/Help/html\n370 | \n371 | # Click-Once directory\n372 | publish/\n373 | \n374 | # Publish Web Output\n375 | *.[Pp]ublish.xml\n376 | *.azurePubxml\n377 | # Note: Comment the next line if you want to checkin your web deploy settings,\n378 | # but database connection strings (with potential passwords) will be unencrypted\n379 | *.pubxml\n380 | *.publishproj\n381 | \n382 | # Microsoft Azure Web App publish settings. Comment the next line if you want to\n383 | # checkin your Azure Web App publish settings, but sensitive information contained\n384 | # in these scripts will be unencrypted\n385 | PublishScripts/\n386 | \n387 | # NuGet Packages\n388 | *.nupkg\n389 | # NuGet Symbol Packages\n390 | *.snupkg\n391 | # The packages folder can be ignored because of Package Restore\n392 | **/[Pp]ackages/*\n393 | # except build/, which is used as an MSBuild target.\n394 | !**/[Pp]ackages/build/\n395 | # Uncomment if necessary however generally it will be regenerated when needed\n396 | #!**/[Pp]ackages/repositories.config\n397 | # NuGet v3's project.json files produces more ignorable files\n398 | *.nuget.props\n399 | *.nuget.targets\n400 | \n401 | # Microsoft Azure Build Output\n402 | csx/\n403 | *.build.csdef\n404 | \n405 | # Microsoft Azure Emulator\n406 | ecf/\n407 | rcf/\n408 | \n409 | # Windows Store app package directories and files\n410 | AppPackages/\n411 | BundleArtifacts/\n412 | Package.StoreAssociation.xml\n413 | _pkginfo.txt\n414 | *.appx\n415 | *.appxbundle\n416 | *.appxupload\n417 | \n418 | # Visual Studio cache files\n419 | # files ending in .cache can be ignored\n420 | *.[Cc]ache\n421 | # but keep track of directories ending in .cache\n422 | !?*.[Cc]ache/\n423 | \n424 | # Others\n425 | ClientBin/\n426 | ~$*\n427 | *~\n428 | *.dbmdl\n429 | *.dbproj.schemaview\n430 | *.jfm\n431 | *.pfx\n432 | *.publishsettings\n433 | orleans.codegen.cs\n434 | \n435 | # Including strong name files can present a security risk\n436 | # (https://github.com/github/gitignore/pull/2483#issue-259490424)\n437 | #*.snk\n438 | \n439 | # Since there are multiple workflows, uncomment next line to ignore bower_components\n440 | # (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n441 | #bower_components/\n442 | \n443 | # RIA/Silverlight projects\n444 | Generated_Code/\n445 | \n446 | # Backup & report files from converting an old project file\n447 | # to a newer Visual Studio version. Backup files are not needed,\n448 | # because we have git ;-)\n449 | _UpgradeReport_Files/\n450 | Backup*/\n451 | UpgradeLog*.XML\n452 | UpgradeLog*.htm\n453 | ServiceFabricBackup/\n454 | *.rptproj.bak\n455 | \n456 | # SQL Server files\n457 | *.mdf\n458 | *.ldf\n459 | *.ndf\n460 | \n461 | # Business Intelligence projects\n462 | *.rdl.data\n463 | *.bim.layout\n464 | *.bim_*.settings\n465 | *.rptproj.rsuser\n466 | *- [Bb]ackup.rdl\n467 | *- [Bb]ackup ([0-9]).rdl\n468 | *- [Bb]ackup ([0-9][0-9]).rdl\n469 | \n470 | # Microsoft Fakes\n471 | FakesAssemblies/\n472 | \n473 | # GhostDoc plugin setting file\n474 | *.GhostDoc.xml\n475 | \n476 | # Node.js Tools for Visual Studio\n477 | .ntvs_analysis.dat\n478 | node_modules/\n479 | \n480 | # Visual Studio 6 build log\n481 | *.plg\n482 | \n483 | # Visual Studio 6 workspace options file\n484 | *.opt\n485 | \n486 | # Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n487 | *.vbw\n488 | \n489 | # Visual Studio LightSwitch build output\n490 | **/*.HTMLClient/GeneratedArtifacts\n491 | **/*.DesktopClient/GeneratedArtifacts\n492 | **/*.DesktopClient/ModelManifest.xml\n493 | **/*.Server/GeneratedArtifacts\n494 | **/*.Server/ModelManifest.xml\n495 | _Pvt_Extensions\n496 | \n497 | # Paket dependency manager\n498 | .paket/paket.exe\n499 | paket-files/\n500 | \n501 | # FAKE - F# Make\n502 | .fake/\n503 | \n504 | # CodeRush personal settings\n505 | .cr/personal\n506 | \n507 | # Python Tools for Visual Studio (PTVS)\n508 | __pycache__/\n509 | *.pyc\n510 | \n511 | # Cake - Uncomment if you are using it\n512 | # tools/**\n513 | # !tools/packages.config\n514 | \n515 | # Tabs Studio\n516 | *.tss\n517 | \n518 | # Telerik's JustMock configuration file\n519 | *.jmconfig\n520 | \n521 | # BizTalk build output\n522 | *.btp.cs\n523 | *.btm.cs\n524 | *.odx.cs\n525 | *.xsd.cs\n526 | \n527 | # OpenCover UI analysis results\n528 | OpenCover/\n529 | \n530 | # Azure Stream Analytics local run output\n531 | ASALocalRun/\n532 | \n533 | # MSBuild Binary and Structured Log\n534 | *.binlog\n535 | \n536 | # NVidia Nsight GPU debugger configuration file\n537 | *.nvuser\n538 | \n539 | # MFractors (Xamarin productivity tool) working folder\n540 | .mfractor/\n541 | \n542 | # Local History for Visual Studio\n543 | .localhistory/\n544 | \n545 | # BeatPulse healthcheck temp database\n546 | healthchecksdb\n547 | \n548 | # Backup folder for Package Reference Convert tool in Visual Studio 2017\n549 | MigrationBackup/\n550 | \n551 | # Ionide (cross platform F# VS Code tools) working folder\n552 | .ionide/\n553 | \n554 | # Fody - auto-generated XML schema\n555 | FodyWeavers.xsd\n556 | \n557 | ### VisualStudio Patch ###\n558 | # Additional files built by Visual Studio\n559 | *.tlog\n560 | \n561 | tools/accountlogin/google-chrome-stable_current_amd64.deb\n562 | # End of https://www.toptal.com/developers/gitignore/api/intellij+all,visualstudio,visualstudiocode,cmake,c,c++\n563 | # Sensitive configuration\n564 | config.json\n\n</file_content>\n\n<file_content path=\"aiapi/CMakeLists.txt\">\n 1 | cmake_minimum_required(VERSION 3.5)\n 2 | project(aiapi CXX)\n 3 | \n 4 | include(CheckIncludeFileCXX)\n 5 | \n 6 | check_include_file_cxx(any HAS_ANY)\n 7 | check_include_file_cxx(string_view HAS_STRING_VIEW)\n 8 | check_include_file_cxx(coroutine HAS_COROUTINE)\n 9 | if (NOT \"${CMAKE_CXX_STANDARD}\" STREQUAL \"\")\n10 |     # Do nothing\n11 | elseif (HAS_ANY AND HAS_STRING_VIEW AND HAS_COROUTINE)\n12 |     set(CMAKE_CXX_STANDARD 20)\n13 | elseif (HAS_ANY AND HAS_STRING_VIEW)\n14 |     set(CMAKE_CXX_STANDARD 17)\n15 | else ()\n16 |     set(CMAKE_CXX_STANDARD 14)\n17 | endif ()\n18 | \n19 | set(CMAKE_CXX_STANDARD_REQUIRED ON)\n20 | set(CMAKE_CXX_EXTENSIONS OFF)\n21 | \n22 | # Define all sources in one place\n23 | add_executable(${PROJECT_NAME}\n24 |     src/main.cc\n25 |     src/accountManager/accountManager.cpp\n26 |     src/apiManager/ApiFactory.cpp\n27 |     src/apiManager/ApiManager.cpp\n28 |     src/apipoint/chaynsapi/chaynsapi.cpp\n29 |     src/channelManager/channelManager.cpp\n30 |     src/controllers/AiApi.cc\n31 |     src/controllers/sinks/ChatSseSink.cpp\n32 |     src/controllers/sinks/ChatJsonSink.cpp\n33 |     src/controllers/sinks/ResponsesSseSink.cpp\n34 |     src/controllers/sinks/ResponsesJsonSink.cpp\n35 |     src/dbManager/account/accountDbManager.cpp\n36 |     src/dbManager/channel/channelDbManager.cpp\n37 |     src/sessionManager/Session.cpp\n38 |     src/sessionManager/ClientOutputSanitizer.cpp\n39 |     src/sessionManager/GenerationService.cpp\n40 |     src/sessionManager/RequestAdapters.cpp\n41 |     src/sessionManager/ToolCallBridge.cpp\n42 |     src/sessionManager/ToolCallValidator.cpp\n43 |     src/sessionManager/XmlTagToolCallCodec.cpp\n44 |     src/tools/ZeroWidthEncoder.cpp\n45 | )\n46 | \n47 | # ##############################################################################\n48 | find_package(Drogon CONFIG REQUIRED)\n49 | find_package(OpenSSL REQUIRED)\n50 | get_target_property(DROGON_INCLUDE_DIRS Drogon::Drogon INTERFACE_INCLUDE_DIRECTORIES)\n51 | message(STATUS \"Drogon头文件路径: ${DROGON_INCLUDE_DIRS}\")\n52 | \n53 | target_link_libraries(${PROJECT_NAME} PRIVATE Drogon::Drogon)\n54 | target_link_libraries(${PROJECT_NAME} PRIVATE OpenSSL::SSL OpenSSL::Crypto)\n55 | # ##############################################################################\n56 | \n57 | if (CMAKE_CXX_STANDARD LESS 17)\n58 |     message(FATAL_ERROR \"c++17 or higher is required\")\n59 | elseif (CMAKE_CXX_STANDARD LESS 20)\n60 |     message(STATUS \"use c++17\")\n61 | else ()\n62 |     message(STATUS \"use c++20\")\n63 | endif ()\n64 | \n65 | drogon_create_views(${PROJECT_NAME} ${CMAKE_CURRENT_SOURCE_DIR}/src/views\n66 |                     ${CMAKE_CURRENT_BINARY_DIR})\n67 | \n68 | target_include_directories(${PROJECT_NAME}\n69 |                            PRIVATE\n70 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src\n71 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src/accountManager\n72 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src/apiManager\n73 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src/apipoint\n74 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src/apipoint/chaynsapi\n75 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src/channelManager\n76 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src/controllers\n77 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src/controllers/sinks\n78 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src/dbManager\n79 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src/dbManager/account\n80 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src/dbManager/channel\n81 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src/models\n82 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src/sessionManager\n83 |                            ${CMAKE_CURRENT_SOURCE_DIR}/src/tools)\n84 | \n85 | # ##############################################################################\n86 | # uncomment the following line for dynamically loading views \n87 | # set_property(TARGET ${PROJECT_NAME} PROPERTY ENABLE_EXPORTS ON)\n88 | # ##############################################################################\n89 | \n90 | # add_subdirectory(test)\n\n</file_content>\n\n<file_content path=\"aiapi/Dockerfile\">\n 1 | FROM ubuntu:22.04\n 2 | \n 3 | # 设置时区和语言环境\n 4 | ENV TZ=Asia/Shanghai\n 5 | RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone\n 6 | ENV LANG=C.UTF-8\n 7 | \n 8 | \n 9 | # 安装基本工具和编译环境\n10 | RUN apt-get update && apt-get install -y \\\n11 |     git \\\n12 |     gcc \\\n13 |     g++ \\\n14 |     cmake \\\n15 |     make \\\n16 |     openssl \\\n17 |     libssl-dev \\\n18 |     libjsoncpp-dev \\\n19 |     libpq-dev \\\n20 |     postgresql-server-dev-all \\\n21 |     libmysqlclient-dev \\\n22 |     default-libmysqlclient-dev \\\n23 |     xvfb \\\n24 |     uuid-dev \\\n25 |     zlib1g-dev \\\n26 |     wget \\\n27 |     jq \\\n28 |     python3-pip \\\n29 |     docker-compose \\\n30 |     libspdlog-dev \\\n31 |     && rm -rf /var/lib/apt/lists/*\n32 | \n33 | # 安装Python依赖\n34 | COPY requirements.txt .\n35 | RUN pip install -r requirements.txt\n36 | \n37 | # 安装 Drogon\n38 | WORKDIR /usr/drogon\n39 | RUN git clone https://github.com/drogonframework/drogon .\n40 | RUN git submodule update --init\n41 | RUN mkdir build\n42 | WORKDIR /usr/drogon/build\n43 | RUN cmake ..\n44 | RUN make -j $(nproc)\n45 | RUN make install\n46 | RUN ldconfig\n47 | \n48 | # 设置工作目录\n49 | WORKDIR /usr/aiapi\n50 | \n51 | # 复制项目文件\n52 | COPY . .\n53 | \n54 | # 创建启动脚本\n55 | RUN cat <<'EOF' > /usr/aiapi/docker-entrypoint.sh\n56 | #!/bin/bash\n57 | CONFIG_PATH=\"/usr/aiapi/src/build/config.json\"\n58 | if [ ! -z \"$CONFIG_JSON\" ]; then\n59 |     echo \"$CONFIG_JSON\" > \"$CONFIG_PATH\"\n60 | fi\n61 | if [ ! -z \"$CUSTOM_CONFIG\" ]; then\n62 |     TMP_CONFIG=$(mktemp)\n63 |     jq -s \".[0] * .[1]\" <(echo \"$CUSTOM_CONFIG\") \"$CONFIG_PATH\" > \"$TMP_CONFIG\" && mv \"$TMP_CONFIG\" \"$CONFIG_PATH\"\n64 | fi\n65 | cd /usr/aiapi/src/build && exec \"$@\"\n66 | EOF\n67 | \n68 | RUN chmod +x /usr/aiapi/docker-entrypoint.sh\n69 | \n70 | # 创建构建目录\n71 | RUN mkdir -p src/build\n72 | RUN mkdir -p src/build/logs\n73 | WORKDIR /usr/aiapi/src/build\n74 | \n75 | # 构建项目\n76 | RUN cmake ..\n77 | RUN make -j $(nproc)\n78 | \n79 | # 复制默认配置文件\n80 | RUN cp /usr/aiapi/config.example.json /usr/aiapi/src/build/config.json\n81 | \n82 | # 暴露端口\n83 | EXPOSE 5555 5556\n84 | \n85 | # 设置入口点\n86 | ENTRYPOINT [\"/usr/aiapi/docker-entrypoint.sh\"]\n87 | \n88 | # 运行应用\n89 | CMD [\"./aiapi\"]\n\n</file_content>\n\n<file_content path=\"aiapi/README.md\">\n  1 | # aiapi\n  2 | \n  3 | 基于 Drogon 框架的 AI API 网关服务，提供 OpenAI 兼容的 Chat Completions 和 Responses API 接口。\n  4 | \n  5 | ## 功能特性\n  6 | \n  7 | - ✅ OpenAI Chat Completions API 兼容（流式/非流式）\n  8 | - ✅ OpenAI Responses API 兼容（流式/非流式，含 previous_response_id 续聊）\n  9 | - ✅ 多 Provider 支持（可扩展工厂模式）\n 10 | - ✅ 工具调用（Tool Calls）完整支持\n 11 | - ✅ 工具调用桥接（XML Bridge）— 为不原生支持工具调用的通道提供桥接\n 12 | - ✅ 工具调用验证（ToolCallValidator）— 支持 None/Relaxed/Strict 三种校验模式\n 13 | - ✅ 参数形状规范化（normalizeToolCallArguments）— 自动修复常见参数格式问题\n 14 | - ✅ 强制工具调用兜底（generateForcedToolCall）— tool_choice=required 场景\n 15 | - ✅ 会话追踪（Hash / ZeroWidth 两种模式）\n 16 | - ✅ 会话连续性决策（ContinuityResolver）\n 17 | - ✅ 并发门控（SessionExecutionGate + CancellationToken + RAII Guard）\n 18 | - ✅ 输出清洗（ClientOutputSanitizer）\n 19 | - ✅ 严格客户端规则（Kilo-Code / RooCode 适配）\n 20 | - ✅ 统一错误模型（Errors）+ 错误统计（ErrorStatsService）\n 21 | - ✅ 账号池管理（自动注册、Token 刷新、类型检测、轮转）\n 22 | - ✅ 渠道管理（多渠道、状态控制、并发限制）\n 23 | - ✅ 服务状态监控 + Prometheus 指标导出\n 24 | - ✅ 内置日志查看 API（文件列表、尾部读取、过滤）\n 25 | \n 26 | ## 架构概览\n 27 | \n 28 | ```\n 29 | ┌─────────────────────────────────────────────────────────────────┐\n 30 | │                         HTTP 层                                  │\n 31 | │  ┌─────────────────────────────────────────────────────────┐    │\n 32 | │  │                    AiApi Controller                      │    │\n 33 | │  │  POST /chaynsapi/v1/chat/completions                    │    │\n 34 | │  │  POST /chaynsapi/v1/responses                           │    │\n 35 | │  │  GET  /chaynsapi/v1/models                              │    │\n 36 | │  │  GET  /chaynsapi/v1/responses/{id}                      │    │\n 37 | │  │  DELETE /chaynsapi/v1/responses/{id}                    │    │\n 38 | │  │  + 账号管理 / 渠道管理 / 监控 / 日志 API                │    │\n 39 | │  └─────────────────────────────────────────────────────────┘    │\n 40 | └─────────────────────────────────────────────────────────────────┘\n 41 |                               │\n 42 |                               ▼\n 43 | ┌─────────────────────────────────────────────────────────────────┐\n 44 | │                        适配层                                    │\n 45 | │  ┌─────────────────┐     ┌──────────────────────────────────┐  │\n 46 | │  │ RequestAdapters │ ──▶ │      GenerationRequest           │  │\n 47 | │  │ (Chat/Responses)│     │ (统一请求结构)                    │  │\n 48 | │  └─────────────────┘     └──────────────────────────────────┘  │\n 49 | └─────────────────────────────────────────────────────────────────┘\n 50 |                               │\n 51 |                               ▼\n 52 | ┌─────────────────────────────────────────────────────────────────┐\n 53 | │                      生成编排层                                  │\n 54 | │  ┌─────────────────────────────────────────────────────────┐    │\n 55 | │  │               GenerationService                          │    │\n 56 | │  │  - runGuarded()          (主入口，含并发门控)             │    │\n 57 | │  │  - materializeSession()  (请求 → 会话)                   │    │\n 58 | │  │  - executeProvider()     (调用上游)                       │    │\n 59 | │  │  - emitResultEvents()    (结果处理 + 事件发送)            │    │\n 60 | │  └─────────────────────────────────────────────────────────┘    │\n 61 | │     │           │              │              │              │   │\n 62 | │     ▼           ▼              ▼              ▼              ▼   │\n 63 | │  ┌────────┐ ┌────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │\n 64 | │  │ToolCall│ │Session │ │ToolCall  │ │Output    │ │Continuity│  │\n 65 | │  │Bridge  │ │Manager │ │Validator │ │Sanitizer │ │Resolver  │  │\n 66 | │  └────────┘ └────────┘ └──────────┘ └──────────┘ └──────────┘  │\n 67 | │     │                                                           │\n 68 | │     ▼                                                           │\n 69 | │  ┌──────────────────┐                                           │\n 70 | │  │SessionExecution  │ (并发门控 + CancellationToken)            │\n 71 | │  │Gate              │                                           │\n 72 | │  └──────────────────┘                                           │\n 73 | └─────────────────────────────────────────────────────────────────┘\n 74 |                               │\n 75 |                               ▼\n 76 | ┌─────────────────────────────────────────────────────────────────┐\n 77 | │                      Provider 层                                 │\n 78 | │  ┌─────────────┐     ┌─────────────────────────────────────┐   │\n 79 | │  │  ApiManager │ ──▶ │         APIinterface                │   │\n 80 | │  │  (路由选择)  │     │  - generate()                       │   │\n 81 | │  │  ApiFactory  │     │  - ProviderResult                   │   │\n 82 | │  └─────────────┘     └─────────────────────────────────────┘   │\n 83 | └─────────────────────────────────────────────────────────────────┘\n 84 |                               │\n 85 |                               ▼\n 86 | ┌─────────────────────────────────────────────────────────────────┐\n 87 | │                       输出层                                     │\n 88 | │  ┌───────────────┐  ┌───────────────┐  ┌───────────────────┐   │\n 89 | │  │ IResponseSink │  │GenerationEvent│  │   HTTP Response   │   │\n 90 | │  │  (接口)       │◀─│  (事件模型)    │──▶│  (JSON/SSE)       │   │\n 91 | │  └───────────────┘  └───────────────┘  └───────────────────┘   │\n 92 | │        │                                                         │\n 93 | │        ├── ChatJsonSink      (Chat 非流式 JSON)                  │\n 94 | │        ├── ChatSseSink       (Chat 流式 SSE)                     │\n 95 | │        ├── ResponsesJsonSink (Responses 非流式 JSON)              │\n 96 | │        ├── ResponsesSseSink  (Responses 流式 SSE)                │\n 97 | │        ├── CollectorSink     (事件收集，内部用)                   │\n 98 | │        └── NullSink          (丢弃输出，测试用)                   │\n 99 | └─────────────────────────────────────────────────────────────────┘\n100 | ```\n101 | \n102 | ## 项目结构\n103 | \n104 | ```\n105 | aiapi/\n106 | ├── CMakeLists.txt                  # CMake 构建配置\n107 | ├── Dockerfile                      # Docker 构建文件\n108 | ├── config.example.json             # 配置文件模板\n109 | ├── docker-compose.env.yml          # Docker Compose（环境变量方式）\n110 | ├── docker-compose.volume.yml       # Docker Compose（卷挂载方式）\n111 | ├── requirements.txt                # Python 依赖（登录/注册服务）\n112 | ├── doc/                            # 文档目录\n113 | │   └── aiapi_callflow_and_api_examples.md  # 详细调用关系与接口样例\n114 | │\n115 | └── src/\n116 |     ├── main.cc                     # 程序入口\n117 |     ├── config.json                 # Drogon 运行配置\n118 |     │\n119 |     ├── controllers/                # HTTP 控制器\n120 |     │   ├── AiApi.h / AiApi.cc      # 主路由控制器（22 个 API 端点）\n121 |     │   └── sinks/                  # 输出 Sink 实现\n122 |     │       ├── ChatJsonSink.cpp    # Chat 非流式 JSON 输出\n123 |     │       ├── ChatSseSink.cpp     # Chat 流式 SSE 输出\n124 |     │       ├── ResponsesJsonSink.cpp # Responses 非流式 JSON 输出\n125 |     │       └── ResponsesSseSink.cpp  # Responses 流式 SSE 输出\n126 |     │\n127 |     ├── sessionManager/             # 核心业务逻辑\n128 |     │   ├── GenerationRequest.h     # 统一请求结构\n129 |     │   ├── GenerationEvent.h       # 统一事件模型\n130 |     │   ├── IResponseSink.h         # 输出通道接口\n131 |     │   ├── RequestAdapters.h/cpp   # HTTP 请求 → GenerationRequest 适配器\n132 |     │   ├── GenerationService.h/cpp # 生成编排服务（核心）\n133 |     │   ├── Session.h/cpp           # 会话管理 + ZeroWidth/Hash 追踪\n134 |     │   ├── ContinuityResolver.h    # 会话连续性决策器\n135 |     │   ├── ResponseIndex.h         # 响应存储索引（Responses API GET/DELETE）\n136 |     │   ├── SessionExecutionGate.h  # 并发门控（单例 + RAII Guard）\n137 |     │   ├── ToolCallBridge.h/cpp    # 工具调用桥接（Native / TextBridge）\n138 |     │   ├── XmlTagToolCallCodec.h/cpp # XML 格式工具调用编解码\n139 |     │   ├── ToolCallValidator.h/cpp # 工具调用 Schema 校验\n140 |     │   ├── ClientOutputSanitizer.h/cpp # 输出清洗\n141 |     │   └── Errors.h                # 统一错误模型\n142 |     │\n143 |     ├── apipoint/                   # Provider 抽象\n144 |     │   ├── APIinterface.h          # Provider 接口（generate / getModels）\n145 |     │   ├── ProviderResult.h        # Provider 结果结构\n146 |     │   └── chaynsapi/              # chayns Provider 实现\n147 |     │       └── chaynsapi.h/cpp\n148 |     │\n149 |     ├── apiManager/                 # Provider 管理\n150 |     │   ├── ApiFactory.h/cpp        # Provider 工厂\n151 |     │   └── ApiManager.h/cpp        # Provider 路由选择\n152 |     │\n153 |     ├── accountManager/             # 账号池管理\n154 |     │   └── accountManager.h/cpp    # 账号 CRUD + Token 刷新 + 自动注册\n155 |     │\n156 |     ├── channelManager/             # 渠道管理\n157 |     │   └── channelManager.h/cpp    # 渠道 CRUD + 状态控制\n158 |     │\n159 |     ├── dbManager/                  # 数据库管理\n160 |     │   ├── account/accountDbManager.h/cpp   # 账号持久化\n161 |     │   ├── channel/channelDbManager.h/cpp   # 渠道持久化\n162 |     │   └── metrics/                # 指标数据库管理\n163 |     │       ├── ErrorStatsDbManager.h/cpp    # 错误统计持久化\n164 |     │       └── StatusDbManager.h/cpp        # 服务状态持久化\n165 |     │\n166 |     ├── metrics/                    # 错误统计服务\n167 |     │   ├── ErrorStatsService.h     # 错误记录服务\n168 |     │   └── ErrorEvent.h            # 错误事件定义\n169 |     │\n170 |     └── tools/                      # 工具类\n171 |         └── ZeroWidthEncoder.h/cpp  # 零宽字符编码/解码\n172 | ```\n173 | \n174 | ## 完整 API 端点清单\n175 | \n176 | ### AI 核心 API\n177 | \n178 | | 方法 | 路径 | 功能 |\n179 | |------|------|------|\n180 | | POST | `/chaynsapi/v1/chat/completions` | Chat Completions（流式/非流式） |\n181 | | POST | `/chaynsapi/v1/responses` | Responses API（流式/非流式） |\n182 | | GET | `/chaynsapi/v1/responses/{id}` | 获取已创建的响应 |\n183 | | DELETE | `/chaynsapi/v1/responses/{id}` | 删除已创建的响应 |\n184 | | GET | `/chaynsapi/v1/models` | 获取可用模型列表 |\n185 | \n186 | ### 账号管理 API\n187 | \n188 | | 方法 | 路径 | 功能 |\n189 | |------|------|------|\n190 | | POST | `/aichat/account/add` | 批量添加账号（支持对象/数组） |\n191 | | POST | `/aichat/account/delete` | 批量删除账号（含上游删除） |\n192 | | POST | `/aichat/account/update` | 批量更新账号信息 |\n193 | | POST | `/aichat/account/refresh` | 异步刷新所有账号 token + 类型 |\n194 | | POST | `/aichat/account/autoregister` | 自动注册新账号（最多 20 个/次） |\n195 | | GET | `/aichat/account/info` | 获取内存中的账号列表 |\n196 | | GET | `/aichat/account/dbinfo` | 获取数据库中的账号列表 |\n197 | \n198 | ### 渠道管理 API\n199 | \n200 | | 方法 | 路径 | 功能 |\n201 | |------|------|------|\n202 | | POST | `/aichat/channel/add` | 批量添加渠道 |\n203 | | POST | `/aichat/channel/delete` | 批量删除渠道 |\n204 | | POST | `/aichat/channel/update` | 更新渠道配置 |\n205 | | POST | `/aichat/channel/updatestatus` | 更新渠道启用/禁用状态 |\n206 | | GET | `/aichat/channel/info` | 获取渠道列表 |\n207 | \n208 | ### 监控与日志 API\n209 | \n210 | | 方法 | 路径 | 功能 |\n211 | |------|------|------|\n212 | | GET | `/aichat/metrics/requests/series` | 请求量时序统计 |\n213 | | GET | `/aichat/metrics/errors/series` | 错误量时序统计（多维过滤） |\n214 | | GET | `/aichat/metrics/errors/events` | 错误事件列表（分页） |\n215 | | GET | `/aichat/metrics/errors/events/{id}` | 错误事件详情 |\n216 | | GET | `/aichat/status/summary` | 服务状态概览 |\n217 | | GET | `/aichat/status/channels` | 渠道状态列表 |\n218 | | GET | `/aichat/status/models` | 模型状态列表 |\n219 | | GET | `/aichat/logs/list` | 日志文件列表 |\n220 | | GET | `/aichat/logs/tail` | 日志尾部读取（支持级别/关键词过滤） |\n221 | \n222 | ## 核心模块说明\n223 | \n224 | ### GenerationService（生成编排服务）\n225 | \n226 | 核心编排服务，管理整个生成流程：\n227 | \n228 | ```\n229 | runGuarded(req, sink, policy)\n230 |   ├─ materializeSession()         → GenerationRequest → session_st\n231 |   ├─ ContinuityResolver::resolve() → 会话连续性决策\n232 |   ├─ sessionManager.getOrCreateSession()\n233 |   └─ executeGuardedWithSession()\n234 |        ├─ ExecutionGuard(RAII)     → 获取并发锁\n235 |        ├─ transformRequestForToolBridge()  → 工具定义注入（Bridge 模式）\n236 |        ├─ executeProvider()        → 调用上游 AI\n237 |        ├─ emitResultEvents()       → 结果处理 + 事件发送\n238 |        │    ├─ sanitizeOutput()     → 文本清洗\n239 |        │    ├─ parseXmlToolCalls()  → XML 工具调用解析\n240 |        │    ├─ normalizeToolCallArguments() → 参数规范化\n241 |        │    ├─ ToolCallValidator    → Schema 校验 + 过滤\n242 |        │    ├─ applyStrictClientRules()    → 严格客户端规则\n243 |        │    └─ 零宽字符会话ID嵌入\n244 |        └─ coverSessionresponse()   → 会话上下文更新 + 转移\n245 | ```\n246 | \n247 | ### GenerationEvent（统一事件模型）\n248 | \n249 | | 事件类型 | 说明 | 关键数据 |\n250 | |----------|------|----------|\n251 | | `Started` | 生成开始 | responseId, model |\n252 | | `OutputTextDelta` | 文本增量（流式） | delta, index |\n253 | | `OutputTextDone` | 文本完成 | text, index |\n254 | | `ToolCallDone` | 工具调用完成 | id, name, arguments, index |\n255 | | `Usage` | Token 使用量 | inputTokens, outputTokens |\n256 | | `Completed` | 生成完成 | finishReason (stop/tool_calls) |\n257 | | `Error` | 错误 | code, message, detail |\n258 | \n259 | ### Tool Bridge 机制\n260 | \n261 | 为不支持原生 Tool Calls 的上游通道提供 XML 桥接：\n262 | \n263 | **请求侧**：\n264 | 1. 将工具定义编码为文本格式（支持 compact/full 两种模式）\n265 | 2. 生成随机触发标记（如 `<Function_Ab1c_Start/>`）\n266 | 3. 构建 `<tool_instructions>` 提示注入到 requestmessage\n267 | \n268 | **响应侧**：\n269 | 1. 通过触发标记定位 XML 块（防止误解析历史消息）\n270 | 2. 使用 XmlTagToolCallCodec 解析 `<function_calls>/<function_call>` 结构\n271 | 3. 参数形状规范化 + Schema 校验 + 降级策略\n272 | \n273 | ### 客户端适配\n274 | \n275 | | 客户端 | 标识 | 特殊处理 |\n276 | |--------|------|----------|\n277 | | Kilo-Code | `Kilo-Code` | 严格模式：每次只能 1 个 tool call，纯文本自动包装为 attempt_completion |\n278 | | RooCode | `RooCode` | 同 Kilo-Code |\n279 | | Claude Code | `claudecode` | 零宽会话 ID 在 tool_calls 前单独发送 |\n280 | | 其他 | — | 宽松模式，不强制校验工具调用 |\n281 | \n282 | ### 会话追踪\n283 | \n284 | | 模式 | 实现 | 说明 |\n285 | |------|------|------|\n286 | | Hash | 消息内容 SHA256 | 默认模式，基于 systemPrompt + messages 哈希 |\n287 | | ZeroWidth | 零宽字符嵌入 | 在助手回复中嵌入不可见的 sessionId |\n288 | \n289 | ### 并发门控\n290 | \n291 | - **RejectConcurrent**：同一会话有请求在执行时，新请求返回 409 Conflict\n292 | - **CancelPrevious**：取消之前的请求，执行新请求\n293 | - 使用 RAII `ExecutionGuard` 自动管理生命周期\n294 | \n295 | ### 错误统计系统\n296 | \n297 | 错误按 4 个域分类：\n298 | \n299 | | 域 | 说明 | 典型事件 |\n300 | |------|------|----------|\n301 | | `SESSION_GATE` | 会话并发门控 | 并发冲突、请求取消 |\n302 | | `UPSTREAM` | 上游 Provider | HTTP 错误、超时 |\n303 | | `TOOL_BRIDGE` | 工具桥接 | XML 未找到、校验过滤、降级、强制生成 |\n304 | | `INTERNAL` | 内部异常 | 运行时异常、未知错误 |\n305 | \n306 | ## API 使用示例\n307 | \n308 | ### Chat Completions API\n309 | \n310 | ```bash\n311 | # 非流式\n312 | curl -X POST \"http://localhost:5555/chaynsapi/v1/chat/completions\" \\\n313 |   -H \"Content-Type: application/json\" \\\n314 |   -d '{\n315 |     \"model\": \"GPT-4o\",\n316 |     \"messages\": [{\"role\": \"user\", \"content\": \"Hello\"}]\n317 |   }'\n318 | \n319 | # 流式\n320 | curl -N -X POST \"http://localhost:5555/chaynsapi/v1/chat/completions\" \\\n321 |   -H \"Content-Type: application/json\" \\\n322 |   -d '{\n323 |     \"model\": \"GPT-4o\",\n324 |     \"stream\": true,\n325 |     \"messages\": [{\"role\": \"user\", \"content\": \"Hello\"}]\n326 |   }'\n327 | ```\n328 | \n329 | ### Responses API\n330 | \n331 | ```bash\n332 | # 创建 Response\n333 | curl -X POST \"http://localhost:5555/chaynsapi/v1/responses\" \\\n334 |   -H \"Content-Type: application/json\" \\\n335 |   -d '{\n336 |     \"model\": \"GPT-4o\",\n337 |     \"input\": \"Hello\"\n338 |   }'\n339 | \n340 | # 续聊\n341 | curl -X POST \"http://localhost:5555/chaynsapi/v1/responses\" \\\n342 |   -H \"Content-Type: application/json\" \\\n343 |   -d '{\n344 |     \"model\": \"GPT-4o\",\n345 |     \"previous_response_id\": \"resp_abc123\",\n346 |     \"input\": \"Tell me more.\"\n347 |   }'\n348 | \n349 | # 获取 Response\n350 | curl \"http://localhost:5555/chaynsapi/v1/responses/{response_id}\"\n351 | \n352 | # 删除 Response\n353 | curl -X DELETE \"http://localhost:5555/chaynsapi/v1/responses/{response_id}\"\n354 | ```\n355 | \n356 | ### 账号管理\n357 | \n358 | ```bash\n359 | # 添加账号\n360 | curl -X POST \"http://localhost:5555/aichat/account/add\" \\\n361 |   -H \"Content-Type: application/json\" \\\n362 |   -d '{\n363 |     \"apiname\": \"chaynsapi\",\n364 |     \"username\": \"user@example.com\",\n365 |     \"password\": \"xxx\"\n366 |   }'\n367 | \n368 | # 自动注册 5 个账号\n369 | curl -X POST \"http://localhost:5555/aichat/account/autoregister\" \\\n370 |   -H \"Content-Type: application/json\" \\\n371 |   -d '{\"apiname\": \"chaynsapi\", \"count\": 5}'\n372 | \n373 | # 刷新所有账号状态\n374 | curl -X POST \"http://localhost:5555/aichat/account/refresh\"\n375 | ```\n376 | \n377 | ### 渠道管理\n378 | \n379 | ```bash\n380 | # 添加渠道\n381 | curl -X POST \"http://localhost:5555/aichat/channel/add\" \\\n382 |   -H \"Content-Type: application/json\" \\\n383 |   -d '[{\n384 |     \"channelname\": \"main\",\n385 |     \"channeltype\": \"chaynsapi\",\n386 |     \"channelurl\": \"https://api.example.com\",\n387 |     \"channelkey\": \"sk-xxx\",\n388 |     \"maxconcurrent\": 10,\n389 |     \"supports_tool_calls\": false\n390 |   }]'\n391 | \n392 | # 获取渠道列表\n393 | curl \"http://localhost:5555/aichat/channel/info\"\n394 | ```\n395 | \n396 | ### 监控\n397 | \n398 | ```bash\n399 | # 服务状态概览\n400 | curl \"http://localhost:5555/aichat/status/summary\"\n401 | \n402 | # 错误时序统计（最近 24 小时）\n403 | curl \"http://localhost:5555/aichat/metrics/errors/series\"\n404 | \n405 | # 日志尾部（过滤 ERROR 级别）\n406 | curl \"http://localhost:5555/aichat/logs/tail?lines=100&level=ERROR\"\n407 | ```\n408 | \n409 | ## 构建与运行\n410 | \n411 | ### 依赖\n412 | \n413 | - C++17 或更高版本\n414 | - Drogon 框架\n415 | - JsonCpp\n416 | - OpenSSL\n417 | - spdlog\n418 | - PostgreSQL（用于持久化）\n419 | \n420 | ### 本地构建\n421 | \n422 | ```bash\n423 | cd aiapi/src\n424 | mkdir build && cd build\n425 | cmake ..\n426 | make -j$(nproc)\n427 | ```\n428 | \n429 | ### 运行\n430 | \n431 | ```bash\n432 | cd aiapi/src/build\n433 | ./aiapi\n434 | ```\n435 | \n436 | 服务默认监听 `0.0.0.0:5555`\n437 | \n438 | ### Docker 构建与运行\n439 | \n440 | ```bash\n441 | # 方式一：环境变量注入配置\n442 | docker compose -f docker-compose.env.yml up --build\n443 | \n444 | # 方式二：卷挂载配置文件\n445 | cp config.example.json config.json\n446 | # 编辑 config.json 填入实际配置\n447 | docker compose -f docker-compose.volume.yml up --build\n448 | ```\n449 | \n450 | Docker 入口脚本支持：\n451 | - `CONFIG_JSON` 环境变量 → 直接覆盖配置文件\n452 | - `CUSTOM_CONFIG` 环境变量 → 使用 jq 合并到现有配置\n453 | \n454 | ## 配置说明\n455 | \n456 | 配置文件位于 `config.example.json`，主要配置项：\n457 | \n458 | ```json\n459 | {\n460 |   \"listeners\": [\n461 |     { \"address\": \"0.0.0.0\", \"port\": 5555 }\n462 |   ],\n463 |   \"db_clients\": [\n464 |     { \"name\": \"aichatpg\", \"rdbms\": \"postgresql\", \"host\": \"...\", ... }\n465 |   ],\n466 |   \"app\": {\n467 |     \"number_of_threads\": 4,\n468 |     \"log\": {\n469 |       \"use_spdlog\": true,\n470 |       \"log_level\": \"DEBUG\"\n471 |     },\n472 |     \"cors\": { \"enabled\": true, \"allow_origins\": [\"*\"] }\n473 |   },\n474 |   \"plugins\": [\n475 |     { \"name\": \"drogon::plugin::PromExporter\", \"config\": { \"path\": \"/metrics\" } },\n476 |     { \"name\": \"drogon::plugin::AccessLogger\" }\n477 |   ],\n478 |   \"custom_config\": {\n479 |     \"session_tracking\": {\n480 |       \"mode\": \"zerowidth\"\n481 |     },\n482 |     \"tool_bridge\": {\n483 |       \"definition_mode\": \"compact\",\n484 |       \"include_descriptions\": false,\n485 |       \"max_description_chars\": 160\n486 |     },\n487 |     \"login_service_urls\": [\n488 |       { \"name\": \"chaynsapi\", \"url\": \"http://127.0.0.1:5557/aichat/chayns/login\" }\n489 |     ],\n490 |     \"regist_service_urls\": [\n491 |       { \"name\": \"chaynsapi\", \"url\": \"http://127.0.0.1:5557/aichat/chayns/autoregister\" }\n492 |     ]\n493 |   }\n494 | }\n495 | ```\n496 | \n497 | ### 关键配置项\n498 | \n499 | | 配置路径 | 说明 | 可选值 |\n500 | |----------|------|--------|\n501 | | `custom_config.session_tracking.mode` | 会话追踪模式 | `hash` / `zerowidth` |\n502 | | `custom_config.tool_bridge.definition_mode` | 工具定义编码模式 | `compact` / `full` |\n503 | | `custom_config.tool_bridge.include_descriptions` | 是否包含工具描述 | `true` / `false` |\n504 | | `custom_config.tool_bridge.max_description_chars` | 描述截断长度 | 0-2000 |\n505 | \n506 | ## 错误码\n507 | \n508 | | 错误码 | HTTP Status | 说明 |\n509 | |--------|-------------|------|\n510 | | BadRequest | 400 | 请求格式错误 |\n511 | | Unauthorized | 401 | 未授权 |\n512 | | Forbidden | 403 | 禁止访问 |\n513 | | NotFound | 404 | 资源不存在 |\n514 | | Conflict | 409 | 并发冲突（同一会话已有请求在执行） |\n515 | | RateLimited | 429 | 限流 |\n516 | | Timeout | 504 | 超时 |\n517 | | ProviderError | 502 | Provider 错误 |\n518 | | Internal | 500 | 内部错误 |\n519 | | Cancelled | 499 | 请求被取消 |\n520 | \n521 | ## 详细文档\n522 | \n523 | - [调用关系图与接口样例](doc/aiapi_callflow_and_api_examples.md) — 详细的模块拆解、时序图、数据结构和 curl 示例\n524 | \n525 | ## 开发路线\n526 | \n527 | - [x] Chat Completions API 基础功能\n528 | - [x] Responses API 基础功能（含 previous_response_id 续聊）\n529 | - [x] 流式输出支持（CollectorSink → SSE 分块传输）\n530 | - [x] 工具调用支持（原生 + Bridge）\n531 | - [x] 工具调用桥接（XML Bridge + 随机 Sentinel）\n532 | - [x] 工具调用验证（None/Relaxed/Strict + 降级策略）\n533 | - [x] 参数形状规范化（数组/别名/默认值）\n534 | - [x] 会话追踪（Hash/ZeroWidth + ContinuityResolver）\n535 | - [x] 并发门控（SessionExecutionGate + CancellationToken + RAII Guard）\n536 | - [x] 输出清洗（ClientOutputSanitizer）\n537 | - [x] 严格客户端规则（Kilo-Code / RooCode）\n538 | - [x] 统一错误模型（Errors）\n539 | - [x] 错误统计系统（ErrorStatsService + 4 域分类）\n540 | - [x] 账号池管理（自动注册 + Token 刷新 + 类型检测）\n541 | - [x] 渠道管理（CRUD + 状态控制 + supports_tool_calls）\n542 | - [x] 服务状态监控（Summary + Channels + Models）\n543 | - [x] 日志查看 API（文件列表 + 尾部读取 + 过滤）\n544 | - [x] Prometheus 指标导出\n545 | - [ ] 真正的流式 Provider 回调（当前为 CollectorSink 伪流式）\n546 | - [ ] 更多 Provider 实现（当前仅 chaynsapi）\n547 | - [ ] 完善单元测试\n548 | \n549 | ## License\n550 | \n551 | MIT\n\n</file_content>\n\n<file_content path=\"aiapi/config.example.json\">\n  1 | {\n  2 |     \"listeners\": [\n  3 |         {\n  4 |             \"address\": \"0.0.0.0\",\n  5 |             \"port\": 5555,\n  6 |             \"https\": false\n  7 |         }\n  8 |     ],\n  9 |     \"db_clients\":[\n 10 |         {\n 11 |             \"name\": \"aichatpg\",\n 12 |             \"rdbms\": \"postgresql\",\n 13 |             \"host\": \"YOUR_DB_HOST\",\n 14 |             \"port\": 14539,\n 15 |             \"dbname\": \"aichat\",\n 16 |             \"user\": \"YOUR_DB_USER\",\n 17 |             \"passwd\": \"YOUR_DB_PASSWORD\",\n 18 |             \"is_fast\": false,\n 19 |             \"number_of_connections\": 1,\n 20 |             \"timeout\": -1.0,\n 21 |             \"auto_batch\": false\n 22 |         }\n 23 |     ],\n 24 |     \"app\": {\n 25 |         \"number_of_threads\": 4,\n 26 |         \"enable_session\": false,\n 27 |         \"session_timeout\": 0,\n 28 |         \"session_same_site\" : \"Null\",\n 29 |         \"session_cookie_key\": \"JSESSIONID\",\n 30 |         \"session_max_age\": -1,\n 31 |         \"document_root\": \"./\",\n 32 |         \"home_page\": \"index.html\",\n 33 |         \"use_implicit_page\": true,\n 34 |         \"implicit_page\": \"index.html\",\n 35 |         \"upload_path\": \"uploads\",\n 36 |         \"file_types\": [\n 37 |             \"gif\",\n 38 |             \"png\",\n 39 |             \"jpg\",\n 40 |             \"js\",\n 41 |             \"css\",\n 42 |             \"html\",\n 43 |             \"ico\",\n 44 |             \"swf\",\n 45 |             \"xap\",\n 46 |             \"apk\",\n 47 |             \"cur\",\n 48 |             \"xml\",\n 49 |             \"webp\",\n 50 |             \"svg\"\n 51 |         ],\n 52 |         \"mime\": {},\n 53 |         \"locations\": [\n 54 |             {\n 55 |                 \"default_content_type\": \"text/plain\",\n 56 |                 \"alias\": \"\",\n 57 |                 \"is_case_sensitive\": false,\n 58 |                 \"allow_all\": true,\n 59 |                 \"is_recursive\": true,\n 60 |                 \"filters\": []\n 61 |             }\n 62 |         ],\n 63 |         \"max_connections\": 100000,\n 64 |         \"max_connections_per_ip\": 0,\n 65 |         \"load_dynamic_views\": false,\n 66 |         \"dynamic_views_path\": [\n 67 |             \"./views\"\n 68 |         ],\n 69 |         \"dynamic_views_output_path\": \"\",\n 70 |         \"json_parser_stack_limit\": 1000,\n 71 |         \"enable_unicode_escaping_in_json\": true,\n 72 |         \"float_precision_in_json\": {\n 73 |             \"precision\": 0,\n 74 |             \"precision_type\": \"significant\"\n 75 |         },\n 76 |         \"log\": {\n 77 |             \"use_spdlog\": true,\n 78 |             \"log_path\": \"logs\",\n 79 |             \"logfile_base_name\": \"aiapi\",\n 80 |             \"log_size_limit\": 10000000,\n 81 |             \"max_files\": 5,\n 82 |             \"log_level\": \"DEBUG\",\n 83 |             \"display_local_time\": true\n 84 |         },\n 85 |         \"run_as_daemon\": false,\n 86 |         \"handle_sig_term\": true,\n 87 |         \"relaunch_on_error\": false,\n 88 |         \"use_sendfile\": true,\n 89 |         \"use_gzip\": true,\n 90 |         \"use_brotli\": false,\n 91 |         \"static_files_cache_time\": 5,\n 92 |         \"idle_connection_timeout\": 60,\n 93 |         \"server_header_field\": \"\",\n 94 |         \"enable_server_header\": true,\n 95 |         \"enable_date_header\": true,\n 96 |         \"keepalive_requests\": 0,\n 97 |         \"pipelining_requests\": 0,\n 98 |         \"gzip_static\": true,\n 99 |         \"br_static\": true,\n100 |         \"client_max_body_size\": \"1M\",\n101 |         \"client_max_memory_body_size\": \"64K\",\n102 |         \"client_max_websocket_message_size\": \"128K\",\n103 |         \"reuse_port\": false,\n104 |         \"enabled_compressed_request\": false,\n105 |         \"enable_request_stream\": false,\n106 |         \"cors\": {\n107 |             \"enabled\": true,\n108 |             \"allow_origins\": [\"*\"],\n109 |             \"allow_methods\": [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\", \"PATCH\"],\n110 |             \"allow_headers\": [\"*\"],\n111 |             \"expose_headers\": [\"*\"],\n112 |             \"max_age\": 3600,\n113 |             \"allow_credentials\": false\n114 |         }\n115 |     },\n116 |     \"plugins\": [\n117 |         {\n118 |             \"name\": \"drogon::plugin::PromExporter\",\n119 |             \"dependencies\": [],\n120 |             \"config\": {\n121 |                 \"path\": \"/metrics\"\n122 |             }\n123 |         },\n124 |         {\n125 |             \"name\": \"drogon::plugin::AccessLogger\",\n126 |             \"dependencies\": [],\n127 |             \"config\": {\n128 |                 \"use_spdlog\": true\n129 |             }\n130 |         }\n131 |     ],\n132 |     \"custom_config\": {\n133 |         \"dbtype\": \"sqlite3\",\n134 |         \"dbtype_comment\": \"可选值: postgresql, mysql, sqlite3, 默认为 postgresql\",\n135 |         \"session_tracking\": {\n136 |             \"mode\": \"zerowidth\",\n137 |             \"_comment\": \"可选值: 'hash' (基于消息内容哈希，默认) 或 'zerowidth' (基于零宽字符嵌入)\"\n138 |         },\n139 |         \"tool_bridge\": {\n140 |             \"definition_mode\": \"compact\",\n141 |             \"include_descriptions\": false,\n142 |             \"max_description_chars\": 5000,\n143 |              \"_comment\": \"ToolBridge 工具定义注入：definition_mode=compact|full；include_descriptions 控制是否附带描述；max_description_chars 控制截断，防止 prompt 过长\"       \n144 |         },\n145 |         \"login_service_urls\": [\n146 |             {\n147 |                 \"name\": \"chaynsapi\",\n148 |                 \"url\": \"http://127.0.0.1:5557/aichat/chayns/login\"\n149 |             }\n150 |         ],\n151 |         \"regist_service_urls\": [\n152 |             {\n153 |                 \"name\": \"chaynsapi\",\n154 |                 \"url\": \"http://127.0.0.1:5557/aichat/chayns/autoregister\"\n155 |             }\n156 |         ],\n157 |         \"upstream_error_texts\": [\n158 |             \"Es ist ein Fehler aufgetreten. Bitte versuche es später erneut.\",\n159 |             \"An error has occurred. Please try again later.\"\n160 |         ],\n161 |         \"upstream_error_texts_comment\": \"上游错误文本列表：当轮询到的响应文本完全匹配其中任一条时，视为上游错误并触发重试\"\n162 |     }\n163 | }\n\n</file_content>\n\n<file_content path=\"aiapi/docker-compose.env.yml\">\n 1 | services:\n 2 |   app:\n 3 |     build: .\n 4 |     environment:\n 5 |       # 使用 CONFIG_JSON 提供完整的配置（必须是单行）\n 6 |       - CONFIG_JSON={\"login_service_urls\":[{\"name\":\"\",\"url\":\"\"}],\"listeners\":[{\"address\":\"0.0.0.0\",\"port\":5555,\"https\":false}],\"db_clients\":[{\"name\":\"aichatpg\",\"rdbms\":\"postgresql\",\"host\":\"YOUR_DB_HOST\",\"port\":14539,\"dbname\":\"aichat\",\"user\":\"YOUR_DB_USER\",\"passwd\":\"YOUR_DB_PASSWORD\",\"is_fast\":false,\"number_of_connections\":1,\"timeout\":-1.0,\"auto_batch\":false}],\"app\":{\"number_of_threads\":4,\"enable_session\":false,\"session_timeout\":0,\"session_same_site\":\"Null\",\"session_cookie_key\":\"JSESSIONID\",\"session_max_age\":-1,\"document_root\":\"./\",\"home_page\":\"index.html\",\"use_implicit_page\":true,\"implicit_page\":\"index.html\",\"upload_path\":\"uploads\",\"file_types\":[\"gif\",\"png\",\"jpg\",\"js\",\"css\",\"html\",\"ico\",\"swf\",\"xap\",\"apk\",\"cur\",\"xml\",\"webp\",\"svg\"],\"mime\":{},\"locations\":[{\"default_content_type\":\"text/plain\",\"alias\":\"\",\"is_case_sensitive\":false,\"allow_all\":true,\"is_recursive\":true,\"filters\":[]}],\"max_connections\":100000,\"max_connections_per_ip\":0,\"load_dynamic_views\":false,\"dynamic_views_path\":[\"./views\"],\"dynamic_views_output_path\":\"\",\"json_parser_stack_limit\":1000,\"enable_unicode_escaping_in_json\":true,\"float_precision_in_json\":{\"precision\":0,\"precision_type\":\"significant\"},\"log\":{\"use_spdlog\":true,\"log_path\":\"logs\",\"logfile_base_name\":\"aiapi\",\"log_size_limit\":10000000,\"max_files\":5,\"log_level\":\"DEBUG\",\"display_local_time\":true},\"run_as_daemon\":false,\"handle_sig_term\":true,\"relaunch_on_error\":false,\"use_sendfile\":true,\"use_gzip\":true,\"use_brotli\":false,\"static_files_cache_time\":5,\"idle_connection_timeout\":60,\"server_header_field\":\"\",\"enable_server_header\":true,\"enable_date_header\":true,\"keepalive_requests\":0,\"pipelining_requests\":0,\"gzip_static\":true,\"br_static\":true,\"client_max_body_size\":\"1M\",\"client_max_memory_body_size\":\"64K\",\"client_max_websocket_message_size\":\"128K\",\"reuse_port\":false,\"enabled_compressed_request\":false,\"enable_request_stream\":false,\"cors\":{\"enabled\":true,\"allow_origins\":[\"*\"],\"allow_methods\":[\"GET\",\"POST\",\"PUT\",\"DELETE\",\"OPTIONS\",\"PATCH\"],\"allow_headers\":[\"*\"],\"expose_headers\":[\"*\"],\"max_age\":3600,\"allow_credentials\":false}},\"plugins\":[{\"name\":\"drogon::plugin::PromExporter\",\"dependencies\":[],\"config\":{\"path\":\"/metrics\"}},{\"name\":\"drogon::plugin::AccessLogger\",\"dependencies\":[],\"config\":{\"use_spdlog\":true}}]}\n 7 |     volumes:\n 8 |       - ./logs:/usr/aiapi/src/build/logs\n 9 |     network_mode: \"host\"\n10 |     # 使用 host 网络模式，服务直接监听宿主机端口 5555\n\n</file_content>\n\n<file_content path=\"aiapi/docker-compose.volume.yml\">\n 1 | services:\n 2 |   app:\n 3 |     build: .\n 4 |     environment:\n 5 |       - DUMMY_VAR=true\n 6 |     volumes:\n 7 |       - ./logs:/usr/aiapi/src/build/logs\n 8 |       - ./config.json:/usr/aiapi/src/config.json\n 9 |     network_mode: \"host\"\n10 |     # 使用 host 网络模式，服务直接监听宿主机端口 5555\n\n</file_content>\n\n<file_content path=\"aiapi/requirements.txt\">\n 1 | fastapi \n 2 | uvicorn \n 3 | httpx \n 4 | pydantic \n 5 | selenium \n 6 | webdriver_manager\n 7 | psutil \n 8 | typing\n 9 | Retry\n10 | requests\n\n</file_content>\n</folder_content>\n<environment_details>\n# VSCode Visible Files\naiapi/src/build/logs/aiapi.log\n\n# VSCode Open Tabs\naiapi/src/build/logs/aiapi.log,aiapi/src/sessionManager/GenerationService.cpp,aiapi/src/build/logs/1.txt,aiapi/src/sessionManager/XmlTagToolCallCodec.cpp,aiapi/src/sessionManager/XmlTagToolCallCodec.h,aiapi/src/apipoint/chaynsapi/chaynsapi.cpp,aiapi/src/apipoint/chaynsapi/chaynsapi.h,aiapi/doc/aiapi_callflow_and_api_examples.md,aiapi/README.md,aiapi/src/controllers/AiApi.cc,aiapi/src/accountManager/accountManager.h,aiapi/src/accountManager/accountManager.cpp,aiapi_web/src/components/LogViewer.tsx,aiapi_web/src/components/LogViewer.css,aiapi_web/src/App.tsx,aiapi_web/src/components/AccountManager.tsx,aiapi_web/src/components/AccountManager.css,aiapi/src/controllers/AiApi.h,aiapi/src/main.cc,aiapi/src/config.json\n\n# Current Time\nCurrent time in ISO 8601 UTC format: 2026-02-07T15:02:22.200Z\nUser time zone: America/Los_Angeles, UTC-8:00\n\n# Current Cost\n$0.00\n\n# Current Mode\n<slug>architect</slug>\n<name>Architect</name>\n<model>Claude Opus 4.6</model>\n<tool_format>native</tool_format>\nYou have not created a todo list yet. Create one with `update_todo_list` if your task is complicated or involves multiple steps.\n</environment_details>"},{"role":"assistant","content":"⁠⁠‌﻿‍‍‌﻿‌﻿‌‌﻿﻿​﻿​‌​﻿‌﻿​﻿‌﻿​﻿​​​﻿‌​​﻿‌﻿​﻿‌‍​﻿‌‌​﻿‌‌​﻿​‌​﻿​​​﻿‌​​﻿​‌‌‌﻿﻿​﻿​﻿​﻿‌​​﻿‌‍​﻿​﻿⁠⁠","tool_calls":[{"id":"call_e95786e14f955fe51939b6b9","type":"function","function":{"name":"list_files","arguments":"{\"path\":\"aiapi/src\",\"recursive\":\"true\"}"}}]},{"role":"tool","tool_call_id":"call_e95786e14f955fe51939b6b9","content":"CMakeLists.txt\nconfig.yaml\nmain.cc\naccountManager/\naccountManager/accountManager.cpp\naccountManager/accountManager.h\napiManager/\napiManager/Apicomn.h\napiManager/ApiFactory.cpp\napiManager/ApiFactory.h\napiManager/ApiManager.cpp\napiManager/ApiManager.h\napipoint/\napipoint/APIinterface.h\napipoint/ProviderResult.h\napipoint/chaynsapi/\napipoint/chaynsapi/chaynsapi.cpp\napipoint/chaynsapi/chaynsapi.h\nbuild/aiapi\nbuild/aichat.db\nbuild/test/aiapi_test\nchannelManager/\nchannelManager/channelManager.cpp\nchannelManager/channelManager.h\ncontrollers/\ncontrollers/AiApi.cc\ncontrollers/AiApi.h\ncontrollers/sinks/\ncontrollers/sinks/ChatJsonSink.cpp\ncontrollers/sinks/ChatJsonSink.h\ncontrollers/sinks/ChatSseSink.cpp\ncontrollers/sinks/ChatSseSink.h\ncontrollers/sinks/ResponsesJsonSink.cpp\ncontrollers/sinks/ResponsesJsonSink.h\ncontrollers/sinks/ResponsesSseSink.cpp\ncontrollers/sinks/ResponsesSseSink.h\ndbManager/\ndbManager/account/\ndbManager/account/accountDbManager.cpp\ndbManager/account/accountDbManager.h\ndbManager/channel/\ndbManager/channel/channelDbManager.cpp\ndbManager/channel/channelDbManager.h\ndbManager/metrics/\ndbManager/metrics/ErrorStatsDbManager.cpp\ndbManager/metrics/ErrorStatsDbManager.h\ndbManager/metrics/StatusDbManager.cpp\ndbManager/metrics/StatusDbManager.h\nmetrics/\nmetrics/ErrorEvent.h\nmetrics/ErrorStatsConfig.cpp\nmetrics/ErrorStatsConfig.h\nmetrics/ErrorStatsService.cpp\nmetrics/ErrorStatsService.h\nmodels/\nmodels/model.json\nsessionManager/\nsessionManager/ClientOutputSanitizer.cpp\nsessionManager/ClientOutputSanitizer.h\nsessionManager/ContinuityResolver.cpp\nsessionManager/ContinuityResolver.h\nsessionManager/Errors.h\nsessionManager/GenerationEvent.h\nsessionManager/GenerationRequest.h\nsessionManager/GenerationService.cpp\nsessionManager/GenerationService.h\nsessionManager/IResponseSink.h\nsessionManager/RequestAdapters.cpp\nsessionManager/RequestAdapters.h\nsessionManager/ResponseIndex.cpp\nsessionManager/ResponseIndex.h\nsessionManager/Session.cpp\nsessionManager/Session.h\nsessionManager/SessionExecutionGate.h\nsessionManager/TextExtractor.cpp\nsessionManager/TextExtractor.h\nsessionManager/ToolCallBridge.cpp\nsessionManager/ToolCallBridge.h\nsessionManager/ToolCallValidator.cpp\nsessionManager/ToolCallValidator.h\nsessionManager/XmlTagToolCallCodec.cpp\nsessionManager/XmlTagToolCallCodec.h\ntest/\ntest/CMakeLists.txt\ntest/test_continuity_resolver.cpp\ntest/test_error_event.cpp\ntest/test_error_stats_config.cpp\ntest/test_main.cc\ntest/test_response_index.cpp\ntools/\ntools/ZeroWidthEncoder.cpp\ntools/ZeroWidthEncoder.h\ntools/accountlogin/\ntools/accountlogin/chayns-login.service\ntools/accountlogin/login_client.cpp\ntools/accountlogin/loginlocal.py\ntools/accountlogin/loginremote.py\ntools/accountlogin/test.py\n<environment_details>\n# VSCode Visible Files\naiapi/src/build/logs/aiapi.log\n\n# VSCode Open Tabs\naiapi/src/build/logs/aiapi.log,aiapi/src/sessionManager/GenerationService.cpp,aiapi/src/build/logs/1.txt,aiapi/src/sessionManager/XmlTagToolCallCodec.cpp,aiapi/src/sessionManager/XmlTagToolCallCodec.h,aiapi/src/apipoint/chaynsapi/chaynsapi.cpp,aiapi/src/apipoint/chaynsapi/chaynsapi.h,aiapi/doc/aiapi_callflow_and_api_examples.md,aiapi/README.md,aiapi/src/controllers/AiApi.cc,aiapi/src/accountManager/accountManager.h,aiapi/src/accountManager/accountManager.cpp,aiapi_web/src/components/LogViewer.tsx,aiapi_web/src/components/LogViewer.css,aiapi_web/src/App.tsx,aiapi_web/src/components/AccountManager.tsx,aiapi_web/src/components/AccountManager.css,aiapi/src/controllers/AiApi.h,aiapi/src/main.cc,aiapi/src/config.json\n\n# Current Time\nCurrent time in ISO 8601 UTC format: 2026-02-07T15:02:33.765Z\nUser time zone: America/Los_Angeles, UTC-8:00\n\n# Current Cost\n$0.00\n\n# Current Mode\n<slug>architect</slug>\n<name>Architect</name>\n<model>Claude Opus 4.6</model>\n<tool_format>native</tool_format>\nYou have not created a todo list yet. Create one with `update_todo_list` if your task is complicated or involves multiple steps.\n</environment_details>"},{"role":"assistant","content":"⁠⁠‌﻿‍‍‌﻿‌﻿‌‌﻿﻿​﻿​‌​﻿‌﻿​﻿‌﻿​﻿​​​﻿‌​​﻿‌﻿​﻿‌‍​﻿‌‌​﻿‌‍​﻿​‌​﻿‌﻿​﻿‌﻿​﻿​‍‌‌﻿﻿​﻿‍‌​﻿‍​​﻿‌​​﻿​‍⁠⁠","tool_calls":[{"id":"call_1e6c1b0cd8b29d9a7061ad6e","type":"function","function":{"name":"read_file","arguments":"{\"files\":[{\"path\":\"aiapi/src/main.cc\"},{\"path\":\"aiapi/src/controllers/AiApi.h\"},{\"path\":\"aiapi/src/sessionManager/GenerationService.h\"},{\"path\":\"aiapi/src/sessionManager/GenerationRequest.h\"},{\"path\":\"aiapi/src/sessionManager/GenerationEvent.h\"},{\"path\":\"aiapi/src/sessionManager/IResponseSink.h\"},{\"path\":\"aiapi/src/apipoint/APIinterface.h\"},{\"path\":\"aiapi/src/apipoint/ProviderResult.h\"}]}"}}]},{"role":"tool","tool_call_id":"call_1e6c1b0cd8b29d9a7061ad6e","content":"Error: Too many files requested. You attempted to read 8 files, but the concurrent file reads limit is 5. Please read files in batches of 5 or fewer.\n<environment_details>\n# VSCode Visible Files\naiapi/src/build/logs/aiapi.log\n\n# VSCode Open Tabs\naiapi/src/build/logs/aiapi.log,aiapi/src/sessionManager/GenerationService.cpp,aiapi/src/build/logs/1.txt,aiapi/src/sessionManager/XmlTagToolCallCodec.cpp,aiapi/src/sessionManager/XmlTagToolCallCodec.h,aiapi/src/apipoint/chaynsapi/chaynsapi.cpp,aiapi/src/apipoint/chaynsapi/chaynsapi.h,aiapi/doc/aiapi_callflow_and_api_examples.md,aiapi/README.md,aiapi/src/controllers/AiApi.cc,aiapi/src/accountManager/accountManager.h,aiapi/src/accountManager/accountManager.cpp,aiapi_web/src/components/LogViewer.tsx,aiapi_web/src/components/LogViewer.css,aiapi_web/src/App.tsx,aiapi_web/src/components/AccountManager.tsx,aiapi_web/src/components/AccountManager.css,aiapi/src/controllers/AiApi.h,aiapi/src/main.cc,aiapi/src/config.json\n\n# Current Time\nCurrent time in ISO 8601 UTC format: 2026-02-07T15:02:45.071Z\nUser time zone: America/Los_Angeles, UTC-8:00\n\n# Current Cost\n$0.00\n\n# Current Mode\n<slug>architect</slug>\n<name>Architect</name>\n<model>Claude Opus 4.6</model>\n<tool_format>native</tool_format>\nYou have not created a todo list yet. Create one with `update_todo_list` if your task is complicated or involves multiple steps.\n</environment_details>"},{"role":"assistant","content":"⁠⁠‌﻿‍‍‌﻿‌﻿‌‌﻿﻿​﻿​‌​﻿‌﻿​﻿‌﻿​﻿​​​﻿‌​​﻿‌﻿​﻿‌‍​﻿‌‌​﻿‌﻿​﻿​​​﻿‍‌​﻿​‍​﻿​​‌‌﻿﻿​﻿‍‌​﻿‌​​﻿‌﻿​﻿‌‌⁠⁠","tool_calls":[{"id":"call_ee5ad3ad892f8020567ef497","type":"function","function":{"name":"read_file","arguments":"{\"files\":[{\"path\":\"aiapi/src/main.cc\"},{\"path\":\"aiapi/src/controllers/AiApi.h\"},{\"path\":\"aiapi/src/sessionManager/GenerationService.h\"},{\"path\":\"aiapi/src/sessionManager/GenerationRequest.h\"},{\"path\":\"aiapi/src/sessionManager/GenerationEvent.h\"}]}"}}]},{"role":"tool","tool_call_id":"call_ee5ad3ad892f8020567ef497","content":"File: aiapi/src/main.cc\nLines 1-71:\n 1 | #include <drogon/drogon.h>\n 2 | #include<accountManager/accountManager.h>\n 3 | #include<apiManager/ApiManager.h>\n 4 | #include<channelManager/channelManager.h>\n 5 | #include<sessionManager/Session.h>\n 6 | #include<metrics/ErrorStatsService.h>\n 7 | int main() {\n 8 |     //Set HTTP listener address and port\n 9 |     //drogon::app().addListener(\"0.0.0.0\", 5555);\n10 |     //Load config file\n11 |     drogon::app().loadConfigFile(\"../config.json\");\n12 |     //drogon::app().loadConfigFile(\"../config.yaml\");\n13 |    \n14 | \n15 |     drogon::app().registerPreRoutingAdvice(\n16 |         [](const drogon::HttpRequestPtr &req,\n17 |            drogon::AdviceCallback &&callback,\n18 |            drogon::AdviceChainCallback &&chainCallback) {\n19 |             if (req->method() == drogon::HttpMethod::Options) {\n20 |                 auto resp = drogon::HttpResponse::newHttpResponse();\n21 |                 resp->addHeader(\"Access-Control-Allow-Origin\", \"*\");\n22 |                 resp->addHeader(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS, PATCH\");\n23 |                 resp->addHeader(\"Access-Control-Allow-Headers\", \"*\");\n24 |                 resp->setStatusCode(drogon::k204NoContent);\n25 |                 callback(resp);\n26 |             } else {\n27 |                 chainCallback();\n28 |             }\n29 |         });\n30 | \n31 |     drogon::app().registerPostHandlingAdvice(\n32 |         [](const drogon::HttpRequestPtr &req, const drogon::HttpResponsePtr &resp) {\n33 |             resp->addHeader(\"Access-Control-Allow-Origin\", \"*\");\n34 |         });\n35 | \n36 | \n37 | \n38 | \n39 |     // 在事件循环开始后立即执行\n40 |     app().getLoop()->queueInLoop([](){\n41 |         std::thread t1([]{\n42 |             LOG_INFO << \"==================【version: 1.1 更新时间：2026/0207/1816】===================\";\n43 |              // 读取会话追踪模式配置\n44 |         auto customConfig = drogon::app().getCustomConfig();\n45 |     if (customConfig.isMember(\"session_tracking\")) {\n46 |         std::string mode = customConfig[\"session_tracking\"].get(\"mode\", \"hash\").asString();\n47 |         if (mode == \"zerowidth\" || mode == \"zero_width\") {\n48 |             chatSession::getInstance()->setTrackingMode(SessionTrackingMode::ZeroWidth);\n49 |             LOG_INFO << \"会话追踪模式: ZeroWidth (零宽字符嵌入)\";\n50 |         } else {\n51 |             chatSession::getInstance()->setTrackingMode(SessionTrackingMode::Hash);\n52 |             LOG_INFO << \"会话追踪模式: Hash (内容哈希)\";\n53 |         }\n54 |     } else {\n55 |         LOG_INFO << \"会话追踪模式: Hash (默认)\";\n56 |     }\n57 |             ChannelManager::getInstance().init();\n58 |             AccountManager::getInstance().init();\n59 |             ApiManager::getInstance().init();\n60 |             // 初始化错误统计服务（使用默认配置）\n61 |             metrics::ErrorStatsConfig statsConfig;\n62 |             metrics::ErrorStatsService::getInstance().init(statsConfig);\n63 | \n64 |         });\n65 |         t1.detach();\n66 |     });\n67 | \n68 |     drogon::app().run();\n69 | \n70 |     return 0;\n71 | }\n\n\n---\n\nFile: aiapi/src/controllers/AiApi.h\nLines 1-83:\n 1 | #pragma once\n 2 | \n 3 | #include <drogon/HttpController.h>\n 4 | using namespace drogon;\n 5 | \n 6 | class AiApi : public drogon::HttpController<AiApi>\n 7 | {\n 8 |   public:\n 9 |     METHOD_LIST_BEGIN\n10 |     // use METHOD_ADD to add your custom processing function here;\n11 |     // METHOD_ADD(AiApi::get, \"/{2}/{1}\", Get); // path is /AiApi/{arg2}/{arg1}\n12 |     // METHOD_ADD(AiApi::your_method_name, \"/{1}/{2}/list\", Get); // path is /AiApi/{arg1}/{arg2}/list\n13 |     // ADD_METHOD_TO(AiApi::your_method_name, \"/absolute/path/{1}/{2}/list\", Get); // path is /absolute/path/{arg1}/{arg2}/list\n14 |     ADD_METHOD_TO(AiApi::chaynsapichat, \"/chaynsapi/v1/chat/completions\", Post); // path is /AiApi/{arg1}/{arg2}/list\n15 |     ADD_METHOD_TO(AiApi::chaynsapimodels, \"/chaynsapi/v1/models\", Get); // path is /AiApi/{arg1}/{arg2}/list\n16 |     ADD_METHOD_TO(AiApi::accountAdd, \"/aichat/account/add\", Post); // path is /AiApi/{arg1}/{arg2}/list\n17 |     ADD_METHOD_TO(AiApi::accountDelete, \"/aichat/account/delete\", Post); // path is /AiApi/{arg1}/{arg2}/list\n18 |     ADD_METHOD_TO(AiApi::accountUpdate, \"/aichat/account/update\", Post); // 更新账号\n19 |     ADD_METHOD_TO(AiApi::accountRefresh, \"/aichat/account/refresh\", Post); // 刷新账号状态（token+类型）\n20 |     ADD_METHOD_TO(AiApi::accountAutoRegister, \"/aichat/account/autoregister\", Post); // 自动注册账号\n21 |     ADD_METHOD_TO(AiApi::accountInfo, \"/aichat/account/info\", Get); // path is /AiApi/{arg1}/{arg2}/list\n22 |     ADD_METHOD_TO(AiApi::accountDbInfo, \"/aichat/account/dbinfo\", Get); // path is /AiApi/{arg1}/{arg2}/list\n23 |     ADD_METHOD_TO(AiApi::channelAdd, \"/aichat/channel/add\", Post); // 添加渠道\n24 |     ADD_METHOD_TO(AiApi::channelInfo, \"/aichat/channel/info\", Get); // 获取渠道列表\n25 |     ADD_METHOD_TO(AiApi::channelDelete, \"/aichat/channel/delete\", Post); // 删除渠道\n26 |     ADD_METHOD_TO(AiApi::channelUpdate, \"/aichat/channel/update\", Post); // 更新渠道\n27 |     ADD_METHOD_TO(AiApi::channelUpdateStatus, \"/aichat/channel/updatestatus\", Post); // 更新渠道状态\n28 |     // OpenAI Responses API 兼容接口\n29 |     ADD_METHOD_TO(AiApi::responsesCreate, \"/chaynsapi/v1/responses\", Post); // 创建响应\n30 |     ADD_METHOD_TO(AiApi::responsesGet, \"/chaynsapi/v1/responses/{1}\", Get); // 获取响应\n31 |     ADD_METHOD_TO(AiApi::responsesDelete, \"/chaynsapi/v1/responses/{1}\", Delete); // 删除响应\n32 |     // 错误统计 API\n33 |     ADD_METHOD_TO(AiApi::getRequestsSeries, \"/aichat/metrics/requests/series\", Get); // 请求时序统计\n34 |     ADD_METHOD_TO(AiApi::getErrorsSeries, \"/aichat/metrics/errors/series\", Get); // 错误时序统计\n35 |     ADD_METHOD_TO(AiApi::getErrorsEvents, \"/aichat/metrics/errors/events\", Get); // 错误事件列表\n36 |     ADD_METHOD_TO(AiApi::getErrorsEventById, \"/aichat/metrics/errors/events/{1}\", Get); // 错误事件详情\n37 |     // 服务状态监控 API\n38 |     ADD_METHOD_TO(AiApi::getStatusSummary, \"/aichat/status/summary\", Get); // 服务状态概览\n39 |     ADD_METHOD_TO(AiApi::getStatusChannels, \"/aichat/status/channels\", Get); // 渠道状态列表\n40 |     ADD_METHOD_TO(AiApi::getStatusModels, \"/aichat/status/models\", Get); // 模型状态列表\n41 |     // 日志查看 API\n42 |     ADD_METHOD_TO(AiApi::logsList, \"/aichat/logs/list\", Get);\n43 |     ADD_METHOD_TO(AiApi::logsTail, \"/aichat/logs/tail\", Get);\n44 | \n45 |     METHOD_LIST_END\n46 |     // your declaration of processing function maybe like this:\n47 |     // void get(const HttpRequestPtr& req, std::function<void (const HttpResponsePtr &)> &&callback, int p1, std::string p2);\n48 |     // void your_method_name(const HttpRequestPtr& req, std::function<void (const HttpResponsePtr &)> &&callback, double p1, int p2) const;\n49 |     void chaynsapichat(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n50 |     void chaynsapimodels(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n51 |     void accountAdd(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n52 |     void accountDelete(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n53 |     void accountUpdate(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n54 |     void accountRefresh(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n55 |     void accountAutoRegister(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n56 |     void accountInfo(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n57 |     void accountDbInfo(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n58 |     void channelAdd(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n59 |     void channelInfo(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n60 |     void channelDelete(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n61 |     void channelUpdate(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n62 |     void channelUpdateStatus(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n63 |     // OpenAI Responses API 兼容接口\n64 |     void responsesCreate(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n65 |     void responsesGet(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback, std::string response_id);\n66 |     void responsesDelete(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback, std::string response_id);\n67 |     // 错误统计 API\n68 |     void getRequestsSeries(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n69 |     void getErrorsSeries(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n70 |     void getErrorsEvents(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n71 |     void getErrorsEventById(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback, int64_t id);\n72 |     // 服务状态监控 API\n73 |     void getStatusSummary(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n74 |     void getStatusChannels(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n75 |     void getStatusModels(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n76 |    // 日志查看 API\n77 |     void logsList(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n78 |     void logsTail(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback);\n79 | \n80 |     //custom function\n81 |   std::string generateClientId(const HttpRequestPtr &req);\n82 |   bool isCreateNewSession(const HttpRequestPtr &req);\n83 | };\n\n\n---\n\nFile: aiapi/src/sessionManager/GenerationService.h\nLines 1-220:\n  1 | #ifndef GENERATION_SERVICE_H\n  2 | #define GENERATION_SERVICE_H\n  3 | \n  4 | #include \"GenerationRequest.h\"\n  5 | #include \"GenerationEvent.h\"\n  6 | #include \"IResponseSink.h\"\n  7 | #include \"Session.h\"\n  8 | #include \"SessionExecutionGate.h\"\n  9 | #include \"Errors.h\"\n 10 | #include \"ToolCallBridge.h\"\n 11 | #include \"XmlTagToolCallCodec.h\"\n 12 | \n 13 | /**\n 14 |  * @brief 生成服务\n 15 |  *\n 16 |  * 统一的业务编排层，负责：\n 17 |  * 1. 接收 GenerationRequest + IResponseSink\n 18 |  * 2. 通过 SessionStore 获取/更新会话上下文\n 19 |  * 3. 调用 provider 执行一次生成\n 20 |  * 4. 将结果（或 provider 事件）转换成 GenerationEvent 发送给 sink\n 21 |  * 5. 统一错误捕获、映射与清理\n 22 |  *\n 23 |  * 参考设计文档: plans/aiapi-refactor-design.md 第 5.1 节\n 24 |  */\n 25 | class GenerationService {\n 26 | public:\n 27 |     GenerationService() = default;\n 28 |     ~GenerationService() = default;\n 29 |     \n 30 |     // 禁止拷贝和移动\n 31 |     GenerationService(const GenerationService&) = delete;\n 32 |     GenerationService& operator=(const GenerationService&) = delete;\n 33 |     GenerationService(GenerationService&&) = delete;\n 34 |     GenerationService& operator=(GenerationService&&) = delete;\n 35 |     \n 36 |     // ========== 新主入口（接收 GenerationRequest）==========\n 37 |     \n 38 |     /**\n 39 |      * @brief 【新主入口】从 GenerationRequest 执行生成（带执行门控）\n 40 |      *\n 41 |      * Controller 统一只调用此方法。职责：\n 42 |      * 1. materialize: GenerationRequest → session_st\n 43 |      * 2. create/update session（必须发生在门控前）\n 44 |      * 3. 调用共享 helper executeGuardedWithSession()\n 45 |      *\n 46 |      * @param req 生成请求（由 RequestAdapters 构建）\n 47 |      * @param sink 输出通道\n 48 |      * @param policy 并发策略\n 49 |      * @return 应用层错误（如果有）\n 50 |      */\n 51 |     std::optional<error::AppError> runGuarded(\n 52 |         const GenerationRequest& req,\n 53 |         IResponseSink& sink,\n 54 |         session::ConcurrencyPolicy policy = session::ConcurrencyPolicy::RejectConcurrent\n 55 |     );\n 56 |     \n 57 | private:\n 58 |     // ========== 共享 helper（新旧入口复用）==========\n 59 |     \n 60 |     /**\n 61 |      * @brief 计算执行门控的 key\n 62 |      *\n 63 |      * 门控 key 统一使用 sessionId（即 session.curConversationId）。\n 64 |      * Responses API 的 response.id 为每次请求生成，不参与门控（避免同一会话并发打架）。\n 65 |      *\n 66 |      * @param session 会话状态\n 67 |      * @return 门控 key，空字符串表示不使用门控\n 68 |      */\n 69 |     static std::string computeExecutionKey(const session_st& session);\n 70 |     \n 71 |     /**\n 72 |      * @brief 【核心 helper】带门控执行生成\n 73 |      *\n 74 |      * 核心执行逻辑，负责：\n 75 |      * - guard key 计算入口（调用 computeExecutionKey）\n 76 |      * - ExecutionGuard 生命周期（构造/获取/失败分支处理）\n 77 |      * - 取消检查：guard.isCancelled() 前后各一次\n 78 |      * - guard 内执行包裹：Started/Provider调用/emitResultEvents/会话写回/afterResponseProcess\n 79 |      * - 错误/关闭语义\n 80 |      *\n 81 |      * @param session 已初始化的会话状态（会被修改）\n 82 |      * @param sink 输出通道\n 83 |      * @param stream 是否流式输出\n 84 |      * @param policy 并发策略\n 85 |      * @return 应用层错误（如果有）\n 86 |      */\n 87 |     std::optional<error::AppError> executeGuardedWithSession(\n 88 |         session_st& session,\n 89 |         IResponseSink& sink,\n 90 |         bool stream,\n 91 |         session::ConcurrencyPolicy policy\n 92 |     );\n 93 |     \n 94 |     /**\n 95 |      * @brief 将 GenerationRequest 物化为 session_st\n 96 |      *\n 97 |      * 唯一实现点：GenerationRequest → session_st 的字段映射\n 98 |      *\n 99 |      * @param req 生成请求\n100 |      * @return 初始化的 session_st\n101 |      */\n102 |     static session_st materializeSession(const GenerationRequest& req);\n103 |     \n104 |     /**\n105 |      * @brief 调用 Provider 执行生成\n106 |      *\n107 |      * @param session 会话状态（包含输入和输出）\n108 |      * @return 是否成功\n109 |      */\n110 |     bool executeProvider(session_st& session);\n111 |     \n112 |     /**\n113 |      * @brief 将 Provider 结果转换为事件并发送\n114 |      *\n115 |      * @param session 会话状态\n116 |      * @param sink 输出通道\n117 |      */\n118 |     void emitResultEvents(const session_st& session, IResponseSink& sink);\n119 |     \n120 |     /**\n121 |      * @brief 发送错误事件\n122 |      *\n123 |      * @param code 错误代码\n124 |      * @param message 错误信息\n125 |      * @param sink 输出通道\n126 |      */\n127 |     void emitError(\n128 |         generation::ErrorCode code,\n129 |         const std::string& message,\n130 |         IResponseSink& sink\n131 |     );\n132 |     \n133 |     /**\n134 |      * @brief 应用输出清洗\n135 |      *\n136 |      * 使用 ClientOutputSanitizer 清洗输出文本\n137 |      *\n138 |      * @param clientInfo 客户端信息\n139 |      * @param text 原始文本\n140 |      * @return 清洗后的文本\n141 |      */\n142 |     std::string sanitizeOutput(const Json::Value& clientInfo, const std::string& text);\n143 |     \n144 |     /**\n145 |      * @brief 获取通道的 tool call 支持能力\n146 |      *\n147 |      * @param channelName 通道名称\n148 |      * @return 是否支持 tool calls\n149 |      */\n150 |     static bool getChannelSupportsToolCalls(const std::string& channelName);\n151 |     \n152 |     /**\n153 |      * @brief 为 ToolCallBridge 转换请求\n154 |      *\n155 |      * 当通道不支持 tool calls 时，将工具定义注入到 currentInput 前面\n156 |      * 使用 XmlTagToolCallCodec::encodeToolDefinitions() 生成文本格式的工具定义\n157 |      *\n158 |      * @param session 会话状态（会被修改）\n159 |      */\n160 |     static void transformRequestForToolBridge(session_st& session);\n161 |     \n162 |     // ========== emitResultEvents 辅助函数 ==========\n163 |      \n164 |      /**\n165 |       * @brief 解析 XML 格式的 tool calls（Toolify-style）\n166 |       *\n167 |       * @param xmlInput XML 输入文本\n168 |       * @param outTextContent 输出的纯文本内容\n169 |       * @param outToolCalls 输出的 tool calls 列表\n170 |       */\n171 |      static void parseXmlToolCalls(\n172 |          const std::string& xmlInput,\n173 |          std::string& outTextContent,\n174 |          std::vector<generation::ToolCallDone>& outToolCalls,\n175 |          const std::string& sentinel\n176 |      );\n177 |     \n178 |     /**\n179 |      * @brief 生成 tool_choice=required 时的兜底 tool call\n180 |      *\n181 |      * @param session 会话状态\n182 |      * @param outToolCalls 输出的 tool calls 列表\n183 |      * @param outTextContent 输出的文本内容（会被清空）\n184 |      */\n185 |     static void generateForcedToolCall(\n186 |         const session_st& session,\n187 |         std::vector<generation::ToolCallDone>& outToolCalls,\n188 |         std::string& outTextContent\n189 |     );\n190 |     \n191 |     /**\n192 |      * @brief 规范化 tool call 参数形状\n193 |      *\n194 |      * 根据客户端提供的 JSONSchema 规范化参数\n195 |      *\n196 |      * @param session 会话状态\n197 |      * @param toolCalls tool calls 列表（会被修改）\n198 |      */\n199 |     static void normalizeToolCallArguments(\n200 |         const session_st& session,\n201 |         std::vector<generation::ToolCallDone>& toolCalls\n202 |     );\n203 |     \n204 |     /**\n205 |      * @brief 应用严格客户端规则\n206 |      *\n207 |      * 包括：包装为 attempt_completion、限制单个 tool call\n208 |      *\n209 |      * @param clientType 客户端类型\n210 |      * @param textContent 文本内容（会被修改）\n211 |      * @param toolCalls tool calls 列表（会被修改）\n212 |      */\n213 |     static void applyStrictClientRules(\n214 |         const std::string& clientType,\n215 |         std::string& textContent,\n216 |         std::vector<generation::ToolCallDone>& toolCalls\n217 |     );\n218 | };\n219 | \n220 | #endif // GENERATION_SERVICE_H\n\n\n---\n\nFile: aiapi/src/sessionManager/GenerationRequest.h\nLines 1-175:\n  1 | #ifndef GENERATION_REQUEST_H\n  2 | #define GENERATION_REQUEST_H\n  3 | \n  4 | #include <string>\n  5 | #include <vector>\n  6 | #include <optional>\n  7 | #include <json/json.h>\n  8 | \n  9 | /**\n 10 |  * @brief 请求入口类型（API endpoint）\n 11 |  *\n 12 |  * 用于区分 Chat Completions 与 Responses 两类入口。\n 13 |  */\n 14 | enum class EndpointType {\n 15 |     ChatCompletions,   // OpenAI Chat Completions API (/v1/chat/completions)\n 16 |     Responses          // OpenAI Responses API (/v1/responses)\n 17 | };\n 18 | \n 19 | /**\n 20 |  * @brief 消息角色\n 21 |  */\n 22 | enum class MessageRole {\n 23 |     System,\n 24 |     User,\n 25 |     Assistant,\n 26 |     Tool\n 27 | };\n 28 | \n 29 | /**\n 30 |  * @brief 内容部分类型\n 31 |  */\n 32 | enum class ContentPartType {\n 33 |     Text,\n 34 |     Image\n 35 | };\n 36 | \n 37 | /**\n 38 |  * @brief 内容部分\n 39 |  * \n 40 |  * 消息可以包含多个内容部分（文本、图片等）\n 41 |  */\n 42 | struct ContentPart {\n 43 |     ContentPartType type = ContentPartType::Text;\n 44 |     std::string text;          // 文本内容\n 45 |     std::string imageUrl;      // 图片URL或base64\n 46 |     std::string mediaType;     // 图片媒体类型 (image/png, image/jpeg等)\n 47 | };\n 48 | \n 49 | /**\n 50 |  * @brief 消息结构\n 51 |  *\n 52 |  * 内部强类型消息表示\n 53 |  */\n 54 | struct Message {\n 55 |     MessageRole role = MessageRole::User;\n 56 |     std::vector<ContentPart> content;\n 57 |     \n 58 |     // Tool call 相关字段\n 59 |     std::vector<Json::Value> toolCalls;  // assistant 消息中的 tool calls\n 60 |     std::string toolCallId;               // tool 消息对应的 tool call ID\n 61 |     \n 62 |     // 便捷构造函数\n 63 |     static Message user(const std::string& text) {\n 64 |         Message msg;\n 65 |         msg.role = MessageRole::User;\n 66 |         ContentPart part;\n 67 |         part.type = ContentPartType::Text;\n 68 |         part.text = text;\n 69 |         msg.content.push_back(part);\n 70 |         return msg;\n 71 |     }\n 72 |     \n 73 |     static Message assistant(const std::string& text) {\n 74 |         Message msg;\n 75 |         msg.role = MessageRole::Assistant;\n 76 |         ContentPart part;\n 77 |         part.type = ContentPartType::Text;\n 78 |         part.text = text;\n 79 |         msg.content.push_back(part);\n 80 |         return msg;\n 81 |     }\n 82 |     \n 83 |     static Message system(const std::string& text) {\n 84 |         Message msg;\n 85 |         msg.role = MessageRole::System;\n 86 |         ContentPart part;\n 87 |         part.type = ContentPartType::Text;\n 88 |         part.text = text;\n 89 |         msg.content.push_back(part);\n 90 |         return msg;\n 91 |     }\n 92 |     \n 93 |     // 获取纯文本内容\n 94 |     std::string getTextContent() const {\n 95 |         std::string result;\n 96 |         for (const auto& part : content) {\n 97 |             if (part.type == ContentPartType::Text) {\n 98 |                 result += part.text;\n 99 |             }\n100 |         }\n101 |         return result;\n102 |     }\n103 | };\n104 | \n105 | /**\n106 |  * @brief 图片信息\n107 |  *\n108 |  * 当前请求中的图片列表\n109 |  */\n110 | struct ImageInfo {\n111 |     std::string base64Data;      // base64编码的图片数据\n112 |     std::string mediaType;       // 图片类型如 image/png, image/jpeg\n113 |     std::string uploadedUrl;     // 上传后的图片URL\n114 |     int width = 0;\n115 |     int height = 0;\n116 | };\n117 | \n118 | /**\n119 |  * @brief 统一生成请求\n120 |  *\n121 |  * 统一\"业务语义\"，而不是强行对齐 HTTP 字段。\n122 |  * Chat Completions 和 Responses API 都映射到这个结构。\n123 |  *\n124 |  * 参考设计文档: plans/aiapi-refactor-design.md 第 4.1 节\n125 |  */\n126 | struct GenerationRequest {\n127 |     // ========== 入口/会话连续性 ==========\n128 |     EndpointType endpointType = EndpointType::ChatCompletions;\n129 |     std::optional<std::string> previousResponseId;   // /v1/responses: previous_response_id（可选）\n130 |     std::vector<std::string> continuityTexts;        // 原始文本集合（用于 ZeroWidth / 其它续聊解析，保留零宽字符）\n131 |     Json::Value clientInfo;                          // 后续可换成强类型\n132 |     \n133 |     // ========== 生成目标 ==========\n134 |     std::string provider;           // 如 \"chaynsapi\"\n135 |     std::string model;              // 模型名称\n136 |     std::string systemPrompt;       // 系统提示词\n137 |     \n138 |     // ========== 输入 ==========\n139 |     std::vector<Message> messages;  // 内部强类型消息列表\n140 |     std::string currentInput;       // 当前用户输入（纯文本）\n141 |     std::vector<ImageInfo> images;  // 当前请求中的图片列表\n142 |     \n143 |     // ========== 工具调用 ==========\n144 |     Json::Value tools;               // 工具定义列表\n145 |     std::string toolChoice;          // 工具选择策略 (auto/none/required)\n146 |     \n147 |     // ========== 输出要求 ==========\n148 |     bool stream = false;            // 是否流式输出\n149 |     \n150 |     // ========== 追踪 ==========\n151 |     std::string requestId;          // 请求 ID（可选）\n152 |     std::string traceId;            // 追踪 ID（可选）\n153 |     \n154 |     // ========== 辅助方法 ==========\n155 |     \n156 |     /**\n157 |      * @brief 检查是否为 Response API 请求\n158 |      */\n159 |     bool isResponseApi() const {\n160 |         return endpointType == EndpointType::Responses;\n161 |     }\n162 |     \n163 |     /**\n164 |      * @brief 获取所有消息的纯文本内容（用于日志等）\n165 |      */\n166 |     std::string getMessagesText() const {\n167 |         std::string result;\n168 |         for (const auto& msg : messages) {\n169 |             result += msg.getTextContent() + \"\\n\";\n170 |         }\n171 |         return result;\n172 |     }\n173 | };\n174 | \n175 | #endif // GENERATION_REQUEST_H\n\n\n---\n\nFile: aiapi/src/sessionManager/GenerationEvent.h\nLines 1-192:\n  1 | #ifndef GENERATION_EVENT_H\n  2 | #define GENERATION_EVENT_H\n  3 | \n  4 | #include <string>\n  5 | #include <variant>\n  6 | #include <optional>\n  7 | \n  8 | /**\n  9 |  * @brief 统一输出事件模型\n 10 |  * \n 11 |  * Session/UseCase 产生\"事件\"（delta、done、error、usage等）。\n 12 |  * Controller 只负责提供不同编码的 sink（Chat SSE / Chat JSON / Responses SSE / Responses JSON）。\n 13 |  * \n 14 |  * 注意：Responses API 的\"多事件序列\"是编码层差异，不应要求 Session 层直接知道\n 15 |  * `response.output_item.added` 等具体 eventName。Session 层只产生语义事件，\n 16 |  * Sink 负责映射为协议事件序列。\n 17 |  * \n 18 |  * 参考设计文档: plans/aiapi-refactor-design.md 第 4.2 节\n 19 |  */\n 20 | \n 21 | namespace generation {\n 22 | \n 23 | // ========== 事件类型定义 ==========\n 24 | \n 25 | /**\n 26 |  * @brief 生成开始事件\n 27 |  */\n 28 | struct Started {\n 29 |     std::string responseId;     // 生成的 response_id\n 30 |     std::string model;          // 使用的模型\n 31 | };\n 32 | \n 33 | /**\n 34 |  * @brief 文本增量事件\n 35 |  * \n 36 |  * 在流式输出时，每次产生新的文本片段时触发\n 37 |  */\n 38 | struct OutputTextDelta {\n 39 |     std::string delta;          // 增量文本\n 40 |     int index = 0;              // 输出项索引（用于多输出）\n 41 | };\n 42 | \n 43 | /**\n 44 |  * @brief 文本完成事件\n 45 |  * \n 46 |  * 完整文本生成完毕时触发\n 47 |  */\n 48 | struct OutputTextDone {\n 49 |     std::string text;           // 完整文本\n 50 |     int index = 0;              // 输出项索引\n 51 | };\n 52 | \n 53 | /**\n 54 |  * @brief 工具调用完成事件\n 55 |  */\n 56 | struct ToolCallDone {\n 57 |     std::string id;             // call_id\n 58 |     std::string name;           // function name\n 59 |     std::string arguments;      // function arguments (json)\n 60 |     int index = 0;              // tool call index\n 61 | };\n 62 | \n 63 | /**\n 64 |  * @brief Token 使用量\n 65 |  */\n 66 | struct Usage {\n 67 |     int inputTokens = 0;        // 输入 token 数\n 68 |     int outputTokens = 0;       // 输出 token 数\n 69 |     int totalTokens = 0;        // 总 token 数\n 70 | };\n 71 | \n 72 | /**\n 73 |  * @brief 生成完成事件\n 74 |  */\n 75 | struct Completed {\n 76 |     std::string finishReason;   // 完成原因: \"stop\", \"length\", \"content_filter\", \"tool_calls\"\n 77 |     std::optional<Usage> usage; // 可选的使用量信息\n 78 | };\n 79 | \n 80 | /**\n 81 |  * @brief 错误代码\n 82 |  * \n 83 |  * 统一错误类型，与 HTTP 状态码分离\n 84 |  */\n 85 | enum class ErrorCode {\n 86 |     BadRequest,         // 请求格式错误 -> 400\n 87 |     Unauthorized,       // 未授权 -> 401\n 88 |     Forbidden,          // 禁止访问 -> 403\n 89 |     NotFound,           // 资源不存在 -> 404\n 90 |     Conflict,           // 冲突（如并发请求） -> 409\n 91 |     RateLimited,        // 限流 -> 429\n 92 |     Timeout,            // 超时 -> 504 或 408\n 93 |     ProviderError,      // Provider 错误 -> 502\n 94 |     Internal,           // 内部错误 -> 500\n 95 |     Cancelled           // 请求被取消 -> 499\n 96 | };\n 97 | \n 98 | /**\n 99 |  * @brief 错误事件\n100 |  */\n101 | struct Error {\n102 |     ErrorCode code = ErrorCode::Internal;\n103 |     std::string message;        // 错误信息\n104 |     std::string providerCode;   // Provider 原始错误码（可选）\n105 |     std::string detail;         // 详细信息（可选）\n106 | };\n107 | \n108 | // ========== 统一事件类型 ==========\n109 | \n110 | /**\n111 |  * @brief 生成事件\n112 |  * \n113 |  * 使用 std::variant 实现类型安全的事件多态\n114 |  */\n115 | using GenerationEvent = std::variant<\n116 |     Started,\n117 |     OutputTextDelta,\n118 |     OutputTextDone,\n119 |     ToolCallDone,\n120 |     Usage,\n121 |     Completed,\n122 |     Error\n123 | >;\n124 | \n125 | // ========== 辅助函数 ==========\n126 | \n127 | /**\n128 |  * @brief 判断事件是否为终结事件\n129 |  * \n130 |  * @param event 事件\n131 |  * @return true 如果是 Completed 或 Error\n132 |  */\n133 | inline bool isTerminalEvent(const GenerationEvent& event) {\n134 |     return std::holds_alternative<Completed>(event) || \n135 |            std::holds_alternative<Error>(event);\n136 | }\n137 | \n138 | /**\n139 |  * @brief 获取事件类型名称（用于日志）\n140 |  */\n141 | inline std::string getEventTypeName(const GenerationEvent& event) {\n142 |     if (std::holds_alternative<Started>(event)) return \"Started\";\n143 |     if (std::holds_alternative<OutputTextDelta>(event)) return \"OutputTextDelta\";\n144 |     if (std::holds_alternative<OutputTextDone>(event)) return \"OutputTextDone\";\n145 |     if (std::holds_alternative<ToolCallDone>(event)) return \"ToolCallDone\";\n146 |     if (std::holds_alternative<Usage>(event)) return \"Usage\";\n147 |     if (std::holds_alternative<Completed>(event)) return \"Completed\";\n148 |     if (std::holds_alternative<Error>(event)) return \"Error\";\n149 |     return \"Unknown\";\n150 | }\n151 | \n152 | /**\n153 |  * @brief ErrorCode 转换为 HTTP 状态码\n154 |  */\n155 | inline int errorCodeToHttpStatus(ErrorCode code) {\n156 |     switch (code) {\n157 |         case ErrorCode::BadRequest:     return 400;\n158 |         case ErrorCode::Unauthorized:   return 401;\n159 |         case ErrorCode::Forbidden:      return 403;\n160 |         case ErrorCode::NotFound:       return 404;\n161 |         case ErrorCode::Conflict:       return 409;\n162 |         case ErrorCode::RateLimited:    return 429;\n163 |         case ErrorCode::Timeout:        return 504;\n164 |         case ErrorCode::ProviderError:  return 502;\n165 |         case ErrorCode::Internal:       return 500;\n166 |         case ErrorCode::Cancelled:      return 499;\n167 |         default:                        return 500;\n168 |     }\n169 | }\n170 | \n171 | /**\n172 |  * @brief ErrorCode 转换为字符串\n173 |  */\n174 | inline std::string errorCodeToString(ErrorCode code) {\n175 |     switch (code) {\n176 |         case ErrorCode::BadRequest:     return \"bad_request\";\n177 |         case ErrorCode::Unauthorized:   return \"unauthorized\";\n178 |         case ErrorCode::Forbidden:      return \"forbidden\";\n179 |         case ErrorCode::NotFound:       return \"not_found\";\n180 |         case ErrorCode::Conflict:       return \"conflict\";\n181 |         case ErrorCode::RateLimited:    return \"rate_limited\";\n182 |         case ErrorCode::Timeout:        return \"timeout\";\n183 |         case ErrorCode::ProviderError:  return \"provider_error\";\n184 |         case ErrorCode::Internal:       return \"internal_error\";\n185 |         case ErrorCode::Cancelled:      return \"cancelled\";\n186 |         default:                        return \"unknown_error\";\n187 |     }\n188 | }\n189 | \n190 | } // namespace generation\n191 | \n192 | #endif // GENERATION_EVENT_H\n\n<environment_details>\n# VSCode Visible Files\naiapi/src/build/logs/aiapi.log\n\n# VSCode Open Tabs\naiapi/src/build/logs/aiapi.log,aiapi/src/sessionManager/GenerationService.cpp,aiapi/src/build/logs/1.txt,aiapi/src/sessionManager/XmlTagToolCallCodec.cpp,aiapi/src/sessionManager/XmlTagToolCallCodec.h,aiapi/src/apipoint/chaynsapi/chaynsapi.cpp,aiapi/src/apipoint/chaynsapi/chaynsapi.h,aiapi/doc/aiapi_callflow_and_api_examples.md,aiapi/README.md,aiapi/src/controllers/AiApi.cc,aiapi/src/accountManager/accountManager.h,aiapi/src/accountManager/accountManager.cpp,aiapi_web/src/components/LogViewer.tsx,aiapi_web/src/components/LogViewer.css,aiapi_web/src/App.tsx,aiapi_web/src/components/AccountManager.tsx,aiapi_web/src/components/AccountManager.css,aiapi/src/controllers/AiApi.h,aiapi/src/main.cc,aiapi/src/config.json\n\n# Current Time\nCurrent time in ISO 8601 UTC format: 2026-02-07T15:02:54.820Z\nUser time zone: America/Los_Angeles, UTC-8:00\n\n# Current Cost\n$0.00\n\n# Current Mode\n<slug>architect</slug>\n<name>Architect</name>\n<model>Claude Opus 4.6</model>\n<tool_format>native</tool_format>\nYou have not created a todo list yet. Create one with `update_todo_list` if your task is complicated or involves multiple steps.\n</environment_details>"},{"role":"assistant","content":"⁠⁠‌﻿‍‍‌﻿‌﻿‌‌﻿﻿​﻿​‌​﻿‌﻿​﻿‌﻿​﻿​​​﻿‌​​﻿‌﻿​﻿‌‍​﻿‌‌​﻿‍​​﻿‌​​﻿‌‌​﻿​﻿​﻿‍‌‌‌﻿﻿​﻿‌‌​﻿​﻿​﻿​‍​﻿​‍⁠⁠","tool_calls":[{"id":"call_52eb329a10ee67f09a3bea2a","type":"function","function":{"name":"read_file","arguments":"{\"files\":[{\"path\":\"aiapi/src/apipoint/APIinterface.h\"},{\"path\":\"aiapi/src/apipoint/ProviderResult.h\"},{\"path\":\"aiapi/src/sessionManager/IResponseSink.h\"},{\"path\":\"aiapi/src/sessionManager/Session.h\"},{\"path\":\"aiapi/src/sessionManager/Errors.h\"}]}"}}]},{"role":"tool","tool_call_id":"call_52eb329a10ee67f09a3bea2a","content":"File: aiapi/src/apipoint/APIinterface.h\nLines 1-56:\n 1 | #ifndef APIINTERFACE_H\n 2 | #define APIINTERFACE_H\n 3 | #include <string>\n 4 | #include <map>\n 5 | #include \"../sessionManager/Session.h\"\n 6 | #include \"ProviderResult.h\"\n 7 | \n 8 | using namespace std;\n 9 | \n10 | struct modelInfo\n11 | {\n12 |     string modelName;\n13 |     bool status=true;\n14 | };\n15 | \n16 | class APIinterface\n17 | {\n18 |     public:\n19 |     virtual ~APIinterface() = default;\n20 |     \n21 |     /**\n22 |      * @brief 发送聊天消息（旧接口，写入 session.responsemessage）\n23 |      * @deprecated 建议使用 generate() 替代\n24 |      */\n25 |     virtual void postChatMessage(session_st& session) = 0;\n26 |     \n27 |     /**\n28 |      * @brief 发送聊天消息并返回结构化结果（新接口）\n29 |      *\n30 |      * 默认实现调用旧的 postChatMessage 并转换结果，\n31 |      * Provider 可以重写此方法以直接返回 ProviderResult。\n32 |      *\n33 |      * @param session 会话状态\n34 |      * @return ProviderResult 结构化结果\n35 |      */\n36 |     virtual provider::ProviderResult generate(session_st& session) {\n37 |         // 默认实现：调用旧接口并转换结果\n38 |         postChatMessage(session);\n39 |         return provider::ProviderResult::fromLegacyResponse(\n40 |             session.responsemessage.get(\"message\", \"\").asString(),\n41 |             session.responsemessage.get(\"statusCode\", 500).asInt()\n42 |         );\n43 |     }\n44 |     \n45 |     virtual void checkAlivableTokens() = 0;\n46 |     virtual void checkModels() = 0;\n47 |     virtual Json::Value getModels() = 0;\n48 |     virtual void init() = 0;\n49 |     virtual void afterResponseProcess(session_st& session) = 0;\n50 |     virtual void eraseChatinfoMap(std::string ConversationId) = 0;\n51 |     virtual void transferThreadContext(const std::string& oldId, const std::string& newId) = 0;\n52 |     \n53 |     map<string,modelInfo> ModelInfoMap;\n54 | };\n55 | \n56 | #endif // APIINTERFACE_H\n\n\n---\n\nFile: aiapi/src/apipoint/ProviderResult.h\nLines 1-160:\n  1 | #ifndef PROVIDER_RESULT_H\n  2 | #define PROVIDER_RESULT_H\n  3 | \n  4 | #include <string>\n  5 | #include <optional>\n  6 | \n  7 | /**\n  8 |  * @brief Provider 层返回的结构化结果\n  9 |  * \n 10 |  * 替代原有的隐式写入 session.responsemessage 的方式，\n 11 |  * 使 Provider 返回显式的结构化数据。\n 12 |  * \n 13 |  * 参考设计文档: plans/aiapi-refactor-design.md 第 6.2 节\n 14 |  */\n 15 | namespace provider {\n 16 | \n 17 | /**\n 18 |  * @brief Provider 层错误码\n 19 |  */\n 20 | enum class ProviderErrorCode {\n 21 |     None = 0,           // 无错误\n 22 |     NetworkError,       // 网络错误\n 23 |     AuthError,          // 认证错误\n 24 |     RateLimited,        // 限流\n 25 |     InvalidRequest,     // 无效请求\n 26 |     Timeout,            // 超时\n 27 |     ServiceUnavailable, // 服务不可用\n 28 |     InternalError,      // 内部错误\n 29 |     Unknown             // 未知错误\n 30 | };\n 31 | \n 32 | /**\n 33 |  * @brief Provider 层错误信息\n 34 |  */\n 35 | struct ProviderError {\n 36 |     ProviderErrorCode code = ProviderErrorCode::None;\n 37 |     std::string message;        // 错误消息\n 38 |     std::string providerCode;   // Provider 原始错误码\n 39 |     int httpStatusCode = 0;     // HTTP 状态码（如果适用）\n 40 |     \n 41 |     bool hasError() const {\n 42 |         return code != ProviderErrorCode::None;\n 43 |     }\n 44 |     \n 45 |     static ProviderError none() {\n 46 |         return ProviderError{ProviderErrorCode::None, \"\", \"\", 0};\n 47 |     }\n 48 |     \n 49 |     static ProviderError network(const std::string& msg) {\n 50 |         return ProviderError{ProviderErrorCode::NetworkError, msg, \"\", 0};\n 51 |     }\n 52 |     \n 53 |     static ProviderError auth(const std::string& msg) {\n 54 |         return ProviderError{ProviderErrorCode::AuthError, msg, \"\", 401};\n 55 |     }\n 56 |     \n 57 |     static ProviderError rateLimited(const std::string& msg) {\n 58 |         return ProviderError{ProviderErrorCode::RateLimited, msg, \"\", 429};\n 59 |     }\n 60 |     \n 61 |     static ProviderError timeout(const std::string& msg) {\n 62 |         return ProviderError{ProviderErrorCode::Timeout, msg, \"\", 504};\n 63 |     }\n 64 |     \n 65 |     static ProviderError internal(const std::string& msg) {\n 66 |         return ProviderError{ProviderErrorCode::InternalError, msg, \"\", 500};\n 67 |     }\n 68 | };\n 69 | \n 70 | /**\n 71 |  * @brief Token 使用量统计\n 72 |  */\n 73 | struct Usage {\n 74 |     int inputTokens = 0;\n 75 |     int outputTokens = 0;\n 76 |     int totalTokens = 0;\n 77 |     \n 78 |     bool isValid() const {\n 79 |         return totalTokens > 0;\n 80 |     }\n 81 | };\n 82 | \n 83 | /**\n 84 |  * @brief Provider 层返回结果\n 85 |  * \n 86 |  * 包含:\n 87 |  * - 生成的文本内容\n 88 |  * - Token 使用量（可选）\n 89 |  * - 错误信息（如果有）\n 90 |  * - 原始响应数据（用于调试）\n 91 |  */\n 92 | struct ProviderResult {\n 93 |     std::string text;                   // 生成的文本\n 94 |     std::optional<Usage> usage;         // Token 使用量\n 95 |     ProviderError error;                // 错误信息\n 96 |     \n 97 |     // 兼容旧接口的字段（渐进式迁移用）\n 98 |     int statusCode = 200;               // HTTP 状态码\n 99 |     std::string rawResponse;            // 原始响应（调试用）\n100 |     \n101 |     /**\n102 |      * @brief 判断是否成功\n103 |      */\n104 |     bool isSuccess() const {\n105 |         return !error.hasError() && statusCode == 200;\n106 |     }\n107 |     \n108 |     /**\n109 |      * @brief 创建成功结果\n110 |      */\n111 |     static ProviderResult success(const std::string& text) {\n112 |         ProviderResult result;\n113 |         result.text = text;\n114 |         result.statusCode = 200;\n115 |         result.error = ProviderError::none();\n116 |         return result;\n117 |     }\n118 |     \n119 |     /**\n120 |      * @brief 创建带 Usage 的成功结果\n121 |      */\n122 |     static ProviderResult successWithUsage(const std::string& text, const Usage& usage) {\n123 |         ProviderResult result = success(text);\n124 |         result.usage = usage;\n125 |         return result;\n126 |     }\n127 |     \n128 |     /**\n129 |      * @brief 创建错误结果\n130 |      */\n131 |     static ProviderResult fail(const ProviderError& err) {\n132 |         ProviderResult result;\n133 |         result.error = err;\n134 |         result.statusCode = err.httpStatusCode > 0 ? err.httpStatusCode : 500;\n135 |         return result;\n136 |     }\n137 |     \n138 |     /**\n139 |      * @brief 从旧格式的 session.responsemessage 转换（兼容层）\n140 |      * \n141 |      * 用于渐进式迁移，Provider 可以先返回 ProviderResult，\n142 |      * 同时保持向后兼容。\n143 |      */\n144 |     static ProviderResult fromLegacyResponse(const std::string& message, int statusCode) {\n145 |         ProviderResult result;\n146 |         result.text = message;\n147 |         result.statusCode = statusCode;\n148 |         if (statusCode == 200) {\n149 |             result.error = ProviderError::none();\n150 |         } else {\n151 |             result.error = ProviderError{ProviderErrorCode::InternalError, \n152 |                 \"Provider returned error\", \"\", statusCode};\n153 |         }\n154 |         return result;\n155 |     }\n156 | };\n157 | \n158 | } // namespace provider\n159 | \n160 | #endif // PROVIDER_RESULT_H\n\n\n---\n\nFile: aiapi/src/sessionManager/IResponseSink.h\nLines 1-131:\n  1 | #ifndef IRESPONSE_SINK_H\n  2 | #define IRESPONSE_SINK_H\n  3 | \n  4 | #include \"GenerationEvent.h\"\n  5 | \n  6 | /**\n  7 |  * @brief 输出通道接口\n  8 |  * \n  9 |  * Session/UseCase 产生语义事件，通过 IResponseSink 接口输出。\n 10 |  * Controller 侧提供不同协议的 Sink 实现（Chat SSE / Chat JSON / Responses SSE / Responses JSON）。\n 11 |  * \n 12 |  * 这样 Session 层不需要知道具体的输出协议细节。\n 13 |  * \n 14 |  * 参考设计文档: plans/aiapi-refactor-design.md 第 4.3 节\n 15 |  */\n 16 | class IResponseSink {\n 17 | public:\n 18 |     virtual ~IResponseSink() = default;\n 19 |     \n 20 |     /**\n 21 |      * @brief 接收生成事件\n 22 |      * \n 23 |      * @param event 生成事件（Started/OutputTextDelta/OutputTextDone/Usage/Completed/Error）\n 24 |      */\n 25 |     virtual void onEvent(const generation::GenerationEvent& event) = 0;\n 26 |     \n 27 |     /**\n 28 |      * @brief 关闭输出通道\n 29 |      * \n 30 |      * 在所有事件发送完毕后调用，用于清理资源和关闭连接\n 31 |      */\n 32 |     virtual void onClose() = 0;\n 33 |     \n 34 |     /**\n 35 |      * @brief 检查输出通道是否仍然有效\n 36 |      * \n 37 |      * @return true 如果通道仍可用于发送事件\n 38 |      */\n 39 |     virtual bool isValid() const { return true; }\n 40 |     \n 41 |     /**\n 42 |      * @brief 获取 Sink 类型名称（用于日志）\n 43 |      * \n 44 |      * @return Sink 类型的描述字符串\n 45 |      */\n 46 |     virtual std::string getSinkType() const = 0;\n 47 | };\n 48 | \n 49 | /**\n 50 |  * @brief 空 Sink 实现\n 51 |  * \n 52 |  * 用于测试或丢弃输出的场景\n 53 |  */\n 54 | class NullSink : public IResponseSink {\n 55 | public:\n 56 |     void onEvent(const generation::GenerationEvent& /*event*/) override {}\n 57 |     void onClose() override {}\n 58 |     std::string getSinkType() const override { return \"NullSink\"; }\n 59 | };\n 60 | \n 61 | /**\n 62 |  * @brief 收集器 Sink 实现\n 63 |  * \n 64 |  * 收集所有事件，用于测试或需要完整结果的场景\n 65 |  */\n 66 | #include <vector>\n 67 | \n 68 | class CollectorSink : public IResponseSink {\n 69 | public:\n 70 |     void onEvent(const generation::GenerationEvent& event) override {\n 71 |         events_.push_back(event);\n 72 |     }\n 73 |     \n 74 |     void onClose() override {\n 75 |         closed_ = true;\n 76 |     }\n 77 |     \n 78 |     std::string getSinkType() const override { return \"CollectorSink\"; }\n 79 |     \n 80 |     const std::vector<generation::GenerationEvent>& getEvents() const {\n 81 |         return events_;\n 82 |     }\n 83 |     \n 84 |     bool isClosed() const {\n 85 |         return closed_;\n 86 |     }\n 87 |     \n 88 |     /**\n 89 |      * @brief 获取最终的完整文本\n 90 |      * \n 91 |      * 从 OutputTextDone 事件中提取\n 92 |      */\n 93 |     std::string getFinalText() const {\n 94 |         for (const auto& event : events_) {\n 95 |             if (std::holds_alternative<generation::OutputTextDone>(event)) {\n 96 |                 return std::get<generation::OutputTextDone>(event).text;\n 97 |             }\n 98 |         }\n 99 |         return \"\";\n100 |     }\n101 |     \n102 |     /**\n103 |      * @brief 检查是否有错误\n104 |      */\n105 |     bool hasError() const {\n106 |         for (const auto& event : events_) {\n107 |             if (std::holds_alternative<generation::Error>(event)) {\n108 |                 return true;\n109 |             }\n110 |         }\n111 |         return false;\n112 |     }\n113 |     \n114 |     /**\n115 |      * @brief 获取错误事件（如果有）\n116 |      */\n117 |     std::optional<generation::Error> getError() const {\n118 |         for (const auto& event : events_) {\n119 |             if (std::holds_alternative<generation::Error>(event)) {\n120 |                 return std::get<generation::Error>(event);\n121 |             }\n122 |         }\n123 |         return std::nullopt;\n124 |     }\n125 |     \n126 | private:\n127 |     std::vector<generation::GenerationEvent> events_;\n128 |     bool closed_ = false;\n129 | };\n130 | \n131 | #endif // IRESPONSE_SINK_H\n\n\n---\n\nFile: aiapi/src/sessionManager/Session.h\nLines 1-465:\n  1 | #ifndef SESSION_H\n  2 | #define SESSION_H\n  3 | #include <string>\n  4 | #include <map>\n  5 | #include <unordered_map>\n  6 | #include <mutex>\n  7 | #include <json/json.h>\n  8 | #include <sstream>\n  9 | #include <openssl/evp.h>\n 10 | #include <openssl/sha.h>\n 11 | #include <openssl/err.h>\n 12 | #include <iomanip>\n 13 | #include <stdexcept>\n 14 | #include <deque>\n 15 | #include <list>\n 16 | #include <memory>\n 17 | \n 18 | // 前向声明 drogon 类型，避免在头文件中直接 include drogon\n 19 | namespace drogon {\n 20 |     class HttpRequest;\n 21 |     using HttpRequestPtr = std::shared_ptr<HttpRequest>;\n 22 | }\n 23 | \n 24 | /**\n 25 |  * @brief 会话追踪模式\n 26 |  *\n 27 |  * 定义如何在连续对话中追踪会话上下文：\n 28 |  * - Hash: 使用消息内容的 SHA256 哈希作为会话ID（原有方式）\n 29 |  * - ZeroWidth: 使用零宽字符在响应末尾隐式嵌入会话ID（新方式）\n 30 |  */\n 31 | enum class SessionTrackingMode {\n 32 |     Hash,       // 基于消息内容哈希的会话追踪（默认，向后兼容）\n 33 |     ZeroWidth   // 基于零宽字符嵌入的会话追踪\n 34 | };\n 35 | \n 36 | /**\n 37 |  * @brief API 类型枚举\n 38 |  *\n 39 |  * 区分不同的 API 接口类型，替代原来的 bool is_response_api\n 40 |  */\n 41 | enum class ApiType {\n 42 |     ChatCompletions,  // Chat Completions API (/v1/chat/completions)\n 43 |     Responses         // Responses API (/v1/responses)\n 44 | };\n 45 | \n 46 | static const int SESSION_EXPIRE_TIME = 86400; //24小时，单位秒数,会话过期时间\n 47 | //static const int SESSION_MAX_MESSAGES = 4; //上下文会话最大消息条数,一轮两条\n 48 | // ImageInfo 定义在 GenerationRequest.h 中\n 49 | #include \"GenerationRequest.h\"\n 50 | \n 51 | struct session_st\n 52 | {\n 53 |   // ========== 通用字段（Chat API 和 Response API 共用）==========\n 54 |   std::string selectapi=\"\";             // API 提供者名称 (如 \"chaynsapi\")\n 55 |   std::string selectmodel=\"\";           // 模型名称 (如 \"GPT-4o\")\n 56 |   std::string systemprompt=\"\";          // 系统提示词 (Chat: system role, Response: instructions)\n 57 |   std::string requestmessage=\"\";        // 当前用户输入的文本内容\n 58 |   std::vector<ImageInfo> requestImages; // 当前请求中的图片列表\n 59 |   Json::Value tools;                    // 工具定义列表\n 60 |   Json::Value tools_raw;                // 原始工具定义（用于 tool bridge 兜底）\n 61 |   std::string toolChoice;               // 工具选择策略\n 62 |   bool supportsToolCalls = true;        // 渠道是否支持工具调用\n 63 |   Json::Value responsemessage;          // AI 响应内容 (消息文本)\n 64 |   Json::Value api_response_data;        // 完整的 API 响应数据 (Chat/Response 格式)\n 65 |   Json::Value client_info;              // 客户端信息 (user-agent, authorization 等)\n 66 |   Json::Value message_context=Json::Value(Json::arrayValue);  // 对话上下文消息数组\n 67 |   std::string requestmessage_raw=\"\";    // 原始当前输入（注入 tool bridge 提示词前）\n 68 |   std::string tool_bridge_trigger=\"\";   // tool bridge 本次请求触发标记（随机生成，用于只解析本次调用）\n 69 |   time_t created_time=0;                // 会话创建时间\n 70 |   time_t last_active_time=0;            // 最后活跃时间\n 71 |   \n 72 |   // ========== hash模式 专用字段 ==========\n 73 |   std::string contextConversationId=\"\"; // 上下文映射 ID (context_map 使用，仅 Hash 模式)\n 74 |   int contextlength=0;                  // 上下文消息数量\n 75 |   bool contextIsFull=false;             // 上下文是否已满\n 76 |   \n 77 |   // ========== 会话状态标记（Chat 和 Response 接口公用）==========\n 78 |   ApiType apiType = ApiType::ChatCompletions;  // API 类型（替代原 is_response_api）\n 79 |   bool has_previous_response_id=false;  // 标记客户端是否携带了 previous_response_id\n 80 |   bool is_continuation=false;           // 标记是否是继续会话（用于决定是否转移 provider 线程上下文）\n 81 |   std::string prev_provider_key=\"\";     // 上一次会话提取到的 ID（用于线程上下文转移和 m_threadMap 查找）\n 82 |   std::string curConversationId=\"\";     // sessionId：会话主键（session_map 的 key）\n 83 |                                         // - Hash 模式：SHA256(hashKey)（保持旧规则）\n 84 |                                         // - ZeroWidth 模式：sess_<timestamp>_<rand>\n 85 |   //===============response api 专用字段=============\n 86 |   std::string response_id=\"\";           // Response API 本次请求的 response id (resp_xxx 格式)\n 87 |   std::string lastResponseId=\"\";        // 最近一次完成的 response id（用于观测/调试，可选）\n 88 |   \n 89 |   //===============ZeroWidth 模式专用字段=============\n 90 |   std::string nextSessionId=\"\";         // ZeroWidth/Hash 模式：下一轮的 sessionId\n 91 |                                         // 由 prepareNextSessionId() 预生成\n 92 |                                         // 嵌入响应后由 commitSessionTransfer() 执行转移\n 93 |   // ========== 辅助方法 ==========\n 94 |   /**\n 95 |    * @brief 检查是否为 Response API 会话\n 96 |    * @return true 如果是 Response API\n 97 |    */\n 98 |   bool isResponseApi() const { return apiType == ApiType::Responses; }\n 99 |   \n100 |   /**\n101 |    * @brief 检查是否为 Chat Completions API 会话\n102 |    * @return true 如果是 Chat API\n103 |    */\n104 |   bool isChatApi() const { return apiType == ApiType::ChatCompletions; }\n105 | \n106 |   // ========== 错误统计追踪字段 ==========\n107 |   std::string request_id=\"\";            // 请求唯一 ID（用于错误追踪，格式：req_xxx）\n108 |   \n109 |   // ========== 现有方法 ==========\n110 |   void clearMessageContext()\n111 |   {\n112 |     message_context.clear();\n113 |   }\n114 |   void addMessageToContext(const Json::Value& message)\n115 |   {\n116 |     /*\n117 |     if(message_context.size() >= SESSION_MAX_MESSAGES)\n118 |     {\n119 |       message_context.pop_front();\n120 |     }\n121 |     */\n122 |     message_context.append(message);\n123 |   }\n124 | \n125 | };\n126 | \n127 | class chatSession\n128 | {\n129 |   private:\n130 |     chatSession();\n131 |     ~chatSession();\n132 |     static chatSession *instance;\n133 |     std::mutex mutex_;\n134 |     std::unordered_map<std::string, session_st> session_map;\n135 |     std::unordered_map<std::string, std::string> context_map;//上下文会话id与会话id的映射\n136 |     SessionTrackingMode trackingMode_ = SessionTrackingMode::Hash;  // 默认使用Hash模式\n137 | public:\n138 |     static chatSession *getInstance()\n139 |     {\n140 |         static chatSession instance;\n141 |         return &instance;\n142 |     }\n143 |     \n144 |     // ========== 会话追踪模式相关方法 ==========\n145 |     /**\n146 |      * @brief 设置会话追踪模式\n147 |      * @param mode 追踪模式\n148 |      */\n149 |     void setTrackingMode(SessionTrackingMode mode) { trackingMode_ = mode; }\n150 |     \n151 |     /**\n152 |      * @brief 获取当前会话追踪模式\n153 |      * @return 当前追踪模式\n154 |      */\n155 |     SessionTrackingMode getTrackingMode() const { return trackingMode_; }\n156 |     \n157 |     /**\n158 |      * @brief 检查是否使用零宽字符追踪模式\n159 |      * @return true 如果使用零宽字符模式\n160 |      */\n161 |     bool isZeroWidthMode() const { return trackingMode_ == SessionTrackingMode::ZeroWidth; }\n162 |     \n163 |     // ========== 基础会话操作方法 ==========\n164 |     void addSession(const std::string &ConversationId,session_st &session);\n165 |     void delSession(const std::string &ConversationId);\n166 |     void getSession(const std::string &ConversationId, session_st &session);\n167 |     void updateSession(const std::string &ConversationId,session_st &session);\n168 |     void clearExpiredSession();\n169 |     void startClearExpiredSession();\n170 |     bool sessionIsExist(const std::string &ConversationId);\n171 |     bool sessionIsExist(session_st &sessio);\n172 | \n173 |     /**\n174 |      * @brief Hash 模式：消费一次 context_map 映射\n175 |      *\n176 |      * 当 Hash key 未命中 session_map，但命中 context_map 时，说明处于“上下文裁剪”边界。\n177 |      * 该方法会：\n178 |      * - 返回映射后的真实 sessionId\n179 |      * - 删除 context_map 中对应项（一次性映射）\n180 |      * - 将目标会话标记为 contextIsFull=true（保持旧行为）\n181 |      */\n182 |     bool consumeContextMapping(const std::string& contextConversationId, std::string& outSessionId);\n183 | \n184 |     void coverSessionresponse(session_st& session);\n185 |     static std::string generateConversationKey(const Json::Value& keyData);\n186 |     static std::string generateSHA256(const std::string& input);\n187 |     static Json::Value getClientInfo(const drogon::HttpRequestPtr &req);\n188 |     \n189 |     // ========== 会话创建/更新方法（外层包装，含模式判断）==========\n190 |     /**\n191 |      * @brief [Chat API] 创建或更新会话\n192 |      *\n193 |      * 根据当前配置的追踪模式自动选择：\n194 |      * - Hash模式：调用 createOrUpdateSessionHash()\n195 |      * - 零宽字符模式：调用 createOrUpdateSessionZeroWidth()\n196 |      *\n197 |      * @param session 会话对象（会被修改）\n198 |      * @return 处理后的会话引用\n199 |      */\n200 |     session_st& createOrUpdateChatSession(session_st& session);\n201 |     \n202 |     /**\n203 |      * @brief [Response API] 创建或更新会话\n204 |      *\n205 |      * 按优先级处理：\n206 |      * 1. 如果有 previous_response_id → 调用 createOrUpdateSessionByPreviousResponseId()\n207 |      * 2. 否则根据配置的追踪模式选择 Hash 或 ZeroWidth 方法\n208 |      *\n209 |      * @param session 会话对象（会被修改）\n210 |      * @return 处理后的会话引用\n211 |      */\n212 |     session_st& createOrUpdateResponseSession(session_st& session);\n213 | \n214 |     /**\n215 |      * @brief 按 sessionId 获取或创建会话（新主路径）\n216 |      *\n217 |      * GenerationService 在完成会话连续性决策后，使用该方法：\n218 |      * - 若 sessionId 已存在：合并本次请求字段到存量会话（保留 message_context）\n219 |      * - 若 sessionId 不存在：创建新会话\n220 |      *\n221 |      * 该方法会设置：\n222 |      * - session.curConversationId = sessionId\n223 |      * - session.prev_provider_key = sessionId（用于 provider thread map 查找）\n224 |      * - session.is_continuation\n225 |      */\n226 |     session_st& getOrCreateSession(const std::string& sessionId, session_st& session);\n227 |     \n228 |     // ========== 会话创建/更新方法（底层实现，独立功能）==========\n229 |     /**\n230 |      * @brief [Hash模式] 基于消息内容哈希创建或更新会话\n231 |      *\n232 |      * 功能：\n233 |      * - 根据消息内容生成会话ID（SHA256哈希）\n234 |      * - 如果会话存在则更新，否则创建新会话\n235 |      * - 支持 context_map 的上下文映射查找\n236 |      *\n237 |      * @param session 会话对象（会被修改）\n238 |      * @return 处理后的会话引用\n239 |      */\n240 |     session_st& createOrUpdateSessionHash(session_st& session);\n241 |     \n242 |     /**\n243 |      * @brief [Previous Response ID模式] 基于previous_response_id延续会话\n244 |      *\n245 |      * 功能：\n246 |      * - 根据 session.curConversationId（已从previous_response_id解析）查找会话\n247 |      * - 如果会话存在则更新并延续上下文\n248 |      * - 如果会话不存在则创建新会话\n249 |      *\n250 |      * @param session 会话对象（会被修改，需要预先设置 curConversationId）\n251 |      * @return 处理后的会话引用\n252 |      */\n253 |     session_st& createOrUpdateSessionByPreviousResponseId(session_st& session);\n254 |     \n255 |     /**\n256 |      * @deprecated 请使用 createOrUpdateSessionHash() 或 createOrUpdateChatSession()\n257 |      * 此方法保留用于向后兼容，内部已重定向到新方法\n258 |      */\n259 |     [[deprecated(\"Use createOrUpdateSessionHash() or createOrUpdateChatSession() instead\")]]\n260 |     session_st& createNewSessionOrUpdateSession(session_st& session);\n261 |     \n262 |     /**\n263 |      * @brief [DEPRECATED] 从 HTTP 请求构建 session_st (Chat API)\n264 |      *\n265 |      * @deprecated 请使用 RequestAdapters::buildGenerationRequestFromChat() + GenerationService::runGuarded() 替代\n266 |      *\n267 |      * 此方法已弃用，Controller 不应再直接调用此方法来构建 session。\n268 |      * 新的调用路径：RequestAdapters -> GenerationRequest -> GenerationService::runGuarded()\n269 |      */\n270 |     [[deprecated(\"Use RequestAdapters::buildGenerationRequestFromChat() + GenerationService::runGuarded() instead\")]]\n271 |     session_st gennerateSessionstByReq(const drogon::HttpRequestPtr &req);\n272 |     \n273 |     Json::Value generateJsonbySession(const session_st& session,bool contextIsFull);\n274 |     \n275 |     // ========== 新增方法（Response API 使用）==========\n276 |     // 生成唯一的 response_id (resp_xxx 格式)\n277 |     static std::string generateResponseId();\n278 |     \n279 |     /**\n280 |      * @brief 根据 API 类型和追踪模式生成 curConversationId\n281 |      *\n282 |      * 生成规则：\n283 |      * - Response API + has_previous_response_id → \"resp_xxx\" 格式\n284 |      * - Response API + ZeroWidth → \"zw_xxx\" 格式\n285 |      * - Response API + Hash → \"\" (延迟生成)\n286 |      * - Chat API + ZeroWidth → \"zw_xxx\" 格式\n287 |      * - Chat API + Hash → \"\" (延迟生成)\n288 |      *\n289 |      * @param apiType API 类型\n290 |      * @param mode 会话追踪模式\n291 |      * @param has_previous_response_id 是否携带 previous_response_id\n292 |      * @return 生成的会话ID，空字符串表示需要延迟生成（Hash模式）\n293 |      */\n294 |     static std::string generateCurConversationId(ApiType apiType, SessionTrackingMode mode, bool has_previous_response_id);\n295 |     \n296 |     // 为 Response API 创建会话（使用 response_id 作为键）\n297 |     std::string createResponseSession(session_st& session);\n298 |     \n299 |     // 通过 response_id 获取会话\n300 |     bool getResponseSession(const std::string& response_id, session_st& session);\n301 |     \n302 |     // 通过 response_id 删除会话\n303 |     bool deleteResponseSession(const std::string& response_id);\n304 |     \n305 |     // 更新 Response API 会话（不删除旧 session，直接更新）\n306 |     void updateResponseSession(session_st& session);\n307 | \n308 |     // 更新/写入 Response API 的完整响应数据（用于 GET /responses/{id}）。\n309 |     // 只更新 api_response_data，不覆盖 message_context 等上下文字段。\n310 |     bool updateResponseApiData(const std::string& response_id, const Json::Value& apiData);\n311 |     \n312 |     /**\n313 |      * @brief [DEPRECATED] 从 HTTP 请求构建 session_st (Response API)\n314 |      *\n315 |      * @deprecated 请使用 RequestAdapters::buildGenerationRequestFromResponses() + GenerationService::runGuarded() 替代\n316 |      *\n317 |      * 此方法已弃用，Controller 不应再直接调用此方法来构建 session。\n318 |      * 新的调用路径：RequestAdapters -> GenerationRequest -> GenerationService::runGuarded()\n319 |      */\n320 |     [[deprecated(\"Use RequestAdapters::buildGenerationRequestFromResponses() + GenerationService::runGuarded() instead\")]]\n321 |     session_st gennerateSessionstByResponseReq(const drogon::HttpRequestPtr &req);\n322 |     \n323 |     // ========== 零宽字符追踪模式方法 ==========\n324 |     /**\n325 |      * @brief 生成用于零宽字符模式的唯一会话ID\n326 |      * @return 格式为 \"zw_timestamp_random\" 的会话ID\n327 |      */\n328 |     static std::string generateZeroWidthSessionId();\n329 |     \n330 |     /**\n331 |      * @brief 在零宽字符模式下创建或更新会话\n332 |      * \n333 |      * 与 createNewSessionOrUpdateSession 不同，此方法：\n334 |      * 1. 先从请求消息中提取嵌入的会话ID\n335 |      * 2. 如果找到，则更新现有会话\n336 |      * 3. 如果未找到，则创建新会话并生成新的会话ID\n337 |      * \n338 |      * @param session 会话对象（会被修改）\n339 |      * @return 处理后的会话引用\n340 |      */\n341 |     session_st& createOrUpdateSessionZeroWidth(session_st& session);\n342 |     \n343 |     /**\n344 |      * @brief 从消息文本中提取嵌入的会话ID\n345 |      * \n346 |      * @param text 包含零宽字符的文本\n347 |      * @return 提取的会话ID，如果未找到返回空字符串\n348 |      */\n349 |     static std::string extractSessionIdFromText(const std::string& text);\n350 |     \n351 |     /**\n352 |      * @brief 从消息文本中提取并移除嵌入的会话ID\n353 |      * \n354 |      * @param text 包含零宽字符的文本（会被修改，移除零宽字符）\n355 |      * @return 提取的会话ID，如果未找到返回空字符串\n356 |      */\n357 |     static std::string extractAndRemoveSessionIdFromText(std::string& text);\n358 |     \n359 |     /**\n360 |      * @brief 将会话ID嵌入到文本末尾\n361 |      *\n362 |      * @param text 原始文本\n363 |      * @param sessionId 要嵌入的会话ID\n364 |      * @return 带有嵌入会话ID的文本\n365 |      */\n366 |     static std::string embedSessionIdInText(const std::string& text, const std::string& sessionId);\n367 |     \n368 |     // ========== 会话转移两阶段方法（ZeroWidth/Hash 模式共用）==========\n369 |     /**\n370 |      * @brief 阶段1：预生成下一轮的 sessionId\n371 |      *\n372 |      * 在响应嵌入之前调用，生成新的 sessionId 并存储到 session.nextSessionId。\n373 |      * 调用方应将 nextSessionId 嵌入到响应中发送给客户端。\n374 |      *\n375 |      * @param session 会话对象（会设置 nextSessionId 字段）\n376 |      * @return 生成的新 sessionId\n377 |      */\n378 |     std::string prepareNextSessionId(session_st& session);\n379 |     \n380 |     /**\n381 |      * @brief 阶段2：执行会话转移\n382 |      *\n383 |      * 在响应发送给客户端之后调用，执行实际的会话转移：\n384 |      * - 更新 message_context（添加本轮对话）\n385 |      * - 转移 provider 线程上下文\n386 |      * - 更新 session_map（添加新会话，删除旧会话）\n387 |      *\n388 |      * @param session 会话对象（需要预先设置 nextSessionId）\n389 |      */\n390 |     void commitSessionTransfer(session_st& session);\n391 |     \n392 | private:\n393 |     // ========== 图片解析辅助方法（Chat API 和 Response API 共用）==========\n394 |     // 从 content 数组中提取图片信息\n395 |     static void extractImagesFromContent(const Json::Value& content, std::vector<ImageInfo>& images);\n396 |     // 解析单个图片项\n397 |     static void parseImageItem(const Json::Value& item, std::vector<ImageInfo>& images);\n398 |     // 将 content 转换为字符串，同时提取图片\n399 |     static std::string getContentAsString(const Json::Value& content, std::vector<ImageInfo>& images);\n400 |     \n401 |     // ========== Response API 专用辅助方法 ==========\n402 |     /**\n403 |      * @brief 在 Response API input 数组中查找最后一条 assistant 消息的索引\n404 |      * @param input Response API 的 input 数组\n405 |      * @return 最后一条 assistant 消息的索引，未找到返回 -1\n406 |      */\n407 |     static int findLastAssistantIndexInInput(const Json::Value& input);\n408 |     \n409 |     /**\n410 |      * @brief 从 Response API 的 content 中提取纯文本\n411 |      * @param content content 字段（可以是字符串或数组）\n412 |      * @param stripZeroWidth 是否移除零宽字符\n413 |      * @return 提取的文本内容\n414 |      */\n415 |     static std::string extractTextFromResponseContent(const Json::Value& content, bool stripZeroWidth = false);\n416 |     \n417 |     /**\n418 |      * @brief 从 Response API input 中提取零宽字符编码的会话ID\n419 |      * @param input Response API 的 input 数组\n420 |      * @param splitIndex 最后一条 assistant 消息的索引\n421 |      * @return 提取的会话ID，未找到返回空字符串\n422 |      */\n423 |     static std::string extractZeroWidthSessionIdFromResponseInput(const Json::Value& input, int splitIndex);\n424 |     \n425 |     /**\n426 |      * @brief 解析 Response API input 数组中的单个消息项\n427 |      * @param item input 数组中的单个元素\n428 |      * @param index 当前元素在数组中的索引\n429 |      * @param splitIndex 最后一条 assistant 消息的索引\n430 |      * @param session 会话对象（会被修改）\n431 |      * @param isZeroWidthMode 是否启用零宽字符模式\n432 |      */\n433 |     static void parseResponseInputItem(const Json::Value& item, int index, int splitIndex, \n434 |                                        session_st& session, bool isZeroWidthMode);\n435 |     \n436 |     /**\n437 |      * @brief 处理 previous_response_id 逻辑\n438 |      * @param prevId previous_response_id 值\n439 |      * @param session 会话对象（会被修改）\n440 |      */\n441 |     void handlePreviousResponseId(const std::string& prevId, session_st& session);\n442 |     \n443 |     // ========== 会话创建/更新辅助方法（消除重复代码）==========\n444 |     /**\n445 |      * @brief 从请求数据更新现有会话\n446 |      *\n447 |      * 将 session 中的 requestmessage、requestImages 更新到 session_map 中的目标会话，\n448 |      * 并将 session_map 中的完整会话赋值回 session。\n449 |      *\n450 |      * @param sessionId 目标会话ID\n451 |      * @param session 请求会话对象（会被修改为 session_map 中的会话）\n452 |      */\n453 |     void updateExistingSessionFromRequest(const std::string& sessionId, session_st& session);\n454 |     \n455 |     /**\n456 |      * @brief 初始化新会话并添加到 session_map\n457 |      *\n458 |      * 设置会话的各种ID字段，并将会话添加到 session_map。\n459 |      *\n460 |      * @param sessionId 新会话ID\n461 |      * @param session 会话对象（会被修改）\n462 |      */\n463 |     void initializeNewSession(const std::string& sessionId, session_st& session);\n464 | };\n465 | #endif  \n\n\n---\n\nFile: aiapi/src/sessionManager/Errors.h\nLines 1-186:\n  1 | #ifndef ERRORS_H\n  2 | #define ERRORS_H\n  3 | \n  4 | #include <string>\n  5 | #include <optional>\n  6 | \n  7 | /**\n  8 |  * @brief 统一错误模型\n  9 |  * \n 10 |  * 定义应用层错误类型，与 HTTP 状态码映射。\n 11 |  * \n 12 |  * 参考设计文档: plans/aiapi-refactor-design.md 第 8 节\n 13 |  */\n 14 | \n 15 | namespace error {\n 16 | \n 17 | /**\n 18 |  * @brief 错误码枚举\n 19 |  */\n 20 | enum class ErrorCode {\n 21 |     None = 0,           // 无错误\n 22 |     BadRequest,         // 400 - 请求格式错误\n 23 |     Unauthorized,       // 401 - 未授权\n 24 |     Forbidden,          // 403 - 禁止访问\n 25 |     NotFound,           // 404 - 资源不存在\n 26 |     Conflict,           // 409 - 冲突（如并发请求）\n 27 |     RateLimited,        // 429 - 请求过于频繁\n 28 |     Timeout,            // 504 - 超时\n 29 |     ProviderError,      // 502 - 上游服务错误\n 30 |     Internal,           // 500 - 内部错误\n 31 |     Cancelled           // 499 - 请求被取消\n 32 | };\n 33 | \n 34 | /**\n 35 |  * @brief 错误码转字符串\n 36 |  */\n 37 | inline std::string errorCodeToString(ErrorCode code) {\n 38 |     switch (code) {\n 39 |         case ErrorCode::None: return \"none\";\n 40 |         case ErrorCode::BadRequest: return \"bad_request\";\n 41 |         case ErrorCode::Unauthorized: return \"unauthorized\";\n 42 |         case ErrorCode::Forbidden: return \"forbidden\";\n 43 |         case ErrorCode::NotFound: return \"not_found\";\n 44 |         case ErrorCode::Conflict: return \"conflict\";\n 45 |         case ErrorCode::RateLimited: return \"rate_limited\";\n 46 |         case ErrorCode::Timeout: return \"timeout\";\n 47 |         case ErrorCode::ProviderError: return \"provider_error\";\n 48 |         case ErrorCode::Internal: return \"internal_error\";\n 49 |         case ErrorCode::Cancelled: return \"cancelled\";\n 50 |         default: return \"unknown\";\n 51 |     }\n 52 | }\n 53 | \n 54 | /**\n 55 |  * @brief 错误码转 HTTP 状态码\n 56 |  */\n 57 | inline int errorCodeToHttpStatus(ErrorCode code) {\n 58 |     switch (code) {\n 59 |         case ErrorCode::None: return 200;\n 60 |         case ErrorCode::BadRequest: return 400;\n 61 |         case ErrorCode::Unauthorized: return 401;\n 62 |         case ErrorCode::Forbidden: return 403;\n 63 |         case ErrorCode::NotFound: return 404;\n 64 |         case ErrorCode::Conflict: return 409;\n 65 |         case ErrorCode::RateLimited: return 429;\n 66 |         case ErrorCode::Timeout: return 504;\n 67 |         case ErrorCode::ProviderError: return 502;\n 68 |         case ErrorCode::Internal: return 500;\n 69 |         case ErrorCode::Cancelled: return 499;\n 70 |         default: return 500;\n 71 |     }\n 72 | }\n 73 | \n 74 | /**\n 75 |  * @brief 应用错误结构\n 76 |  */\n 77 | struct AppError {\n 78 |     ErrorCode code = ErrorCode::None;\n 79 |     std::string message;\n 80 |     std::string detail;\n 81 |     std::string providerCode;  // 上游错误码（可选）\n 82 |     \n 83 |     AppError() = default;\n 84 |     \n 85 |     AppError(ErrorCode c, const std::string& msg, const std::string& det = \"\")\n 86 |         : code(c), message(msg), detail(det) {}\n 87 |     \n 88 |     /**\n 89 |      * @brief 是否有错误\n 90 |      */\n 91 |     bool hasError() const {\n 92 |         return code != ErrorCode::None;\n 93 |     }\n 94 |     \n 95 |     /**\n 96 |      * @brief 获取 HTTP 状态码\n 97 |      */\n 98 |     int httpStatus() const {\n 99 |         return errorCodeToHttpStatus(code);\n100 |     }\n101 |     \n102 |     /**\n103 |      * @brief 获取错误类型字符串\n104 |      */\n105 |     std::string type() const {\n106 |         return errorCodeToString(code);\n107 |     }\n108 |     \n109 |     // 工厂方法\n110 |     static AppError badRequest(const std::string& msg, const std::string& det = \"\") {\n111 |         return AppError(ErrorCode::BadRequest, msg, det);\n112 |     }\n113 |     \n114 |     static AppError unauthorized(const std::string& msg = \"Unauthorized\") {\n115 |         return AppError(ErrorCode::Unauthorized, msg);\n116 |     }\n117 |     \n118 |     static AppError forbidden(const std::string& msg = \"Forbidden\") {\n119 |         return AppError(ErrorCode::Forbidden, msg);\n120 |     }\n121 |     \n122 |     static AppError notFound(const std::string& msg = \"Resource not found\") {\n123 |         return AppError(ErrorCode::NotFound, msg);\n124 |     }\n125 |     \n126 |     static AppError conflict(const std::string& msg = \"Request conflict\") {\n127 |         return AppError(ErrorCode::Conflict, msg);\n128 |     }\n129 |     \n130 |     static AppError rateLimited(const std::string& msg = \"Too many requests\") {\n131 |         return AppError(ErrorCode::RateLimited, msg);\n132 |     }\n133 |     \n134 |     static AppError timeout(const std::string& msg = \"Request timeout\") {\n135 |         return AppError(ErrorCode::Timeout, msg);\n136 |     }\n137 |     \n138 |     static AppError providerError(const std::string& msg, const std::string& providerCode = \"\") {\n139 |         AppError err(ErrorCode::ProviderError, msg);\n140 |         err.providerCode = providerCode;\n141 |         return err;\n142 |     }\n143 |     \n144 |     static AppError internal(const std::string& msg = \"Internal server error\") {\n145 |         return AppError(ErrorCode::Internal, msg);\n146 |     }\n147 |     \n148 |     static AppError cancelled(const std::string& msg = \"Request cancelled\") {\n149 |         return AppError(ErrorCode::Cancelled, msg);\n150 |     }\n151 | };\n152 | \n153 | /**\n154 |  * @brief 将 generation::ErrorCode 转换为 AppError\n155 |  * \n156 |  * @param genCode generation 层的错误码\n157 |  * @param message 错误消息\n158 |  * @return AppError 应用层错误\n159 |  */\n160 | inline AppError fromGenerationError(int genCode, const std::string& message) {\n161 |     // generation::ErrorCode 映射\n162 |     // 0: Unknown -> Internal\n163 |     // 1: ProviderError -> ProviderError\n164 |     // 2: AuthenticationError -> Unauthorized\n165 |     // 3: RateLimitError -> RateLimited\n166 |     // 4: InvalidRequest -> BadRequest\n167 |     // 5: NetworkError -> ProviderError\n168 |     // 6: Timeout -> Timeout\n169 |     // 7: Cancelled -> Cancelled\n170 |     \n171 |     switch (genCode) {\n172 |         case 0: return AppError::internal(message);\n173 |         case 1: return AppError::providerError(message);\n174 |         case 2: return AppError::unauthorized(message);\n175 |         case 3: return AppError::rateLimited(message);\n176 |         case 4: return AppError::badRequest(message);\n177 |         case 5: return AppError::providerError(message);\n178 |         case 6: return AppError::timeout(message);\n179 |         case 7: return AppError::cancelled(message);\n180 |         default: return AppError::internal(message);\n181 |     }\n182 | }\n183 | \n184 | } // namespace error\n185 | \n186 | #endif // ERRORS_H\n\n<environment_details>\n# VSCode Visible Files\naiapi/src/build/logs/aiapi.log\n\n# VSCode Open Tabs\naiapi/src/build/logs/aiapi.log,aiapi/src/sessionManager/GenerationService.cpp,aiapi/src/build/logs/1.txt,aiapi/src/sessionManager/XmlTagToolCallCodec.cpp,aiapi/src/sessionManager/XmlTagToolCallCodec.h,aiapi/src/apipoint/chaynsapi/chaynsapi.cpp,aiapi/src/apipoint/chaynsapi/chaynsapi.h,aiapi/doc/aiapi_callflow_and_api_examples.md,aiapi/README.md,aiapi/src/controllers/AiApi.cc,aiapi/src/accountManager/accountManager.h,aiapi/src/accountManager/accountManager.cpp,aiapi_web/src/components/LogViewer.tsx,aiapi_web/src/components/LogViewer.css,aiapi_web/src/App.tsx,aiapi_web/src/components/AccountManager.tsx,aiapi_web/src/components/AccountManager.css,aiapi/src/controllers/AiApi.h,aiapi/src/main.cc,aiapi/src/config.json\n\n# Current Time\nCurrent time in ISO 8601 UTC format: 2026-02-07T15:03:09.300Z\nUser time zone: America/Los_Angeles, UTC-8:00\n\n# Current Cost\n$0.00\n\n# Current Mode\n<slug>architect</slug>\n<name>Architect</name>\n<model>Claude Opus 4.6</model>\n<tool_format>native</tool_format>\nYou have not created a todo list yet. Create one with `update_todo_list` if your task is complicated or involves multiple steps.\n</environment_details>"},{"role":"assistant","content":"⁠⁠‌﻿‍‍‌﻿‌﻿‌‌﻿﻿​﻿​‌​﻿‌﻿​﻿‌﻿​﻿​​​﻿‌​​﻿‌﻿​﻿‌‍​﻿‌‌​﻿‍‌​﻿‍​​﻿​﻿​﻿‌‍​﻿‍​‌‌﻿﻿​﻿‌﻿​﻿‌﻿​﻿​‌​﻿​‍⁠⁠","tool_calls":[{"id":"call_6b5ed8b0b406940cfe45657b","type":"function","function":{"name":"read_file","arguments":"{\"files\":[{\"path\":\"aiapi/src/sessionManager/ToolCallBridge.h\"},{\"path\":\"aiapi/src/sessionManager/SessionExecutionGate.h\"},{\"path\":\"aiapi/src/sessionManager/ContinuityResolver.h\"},{\"path\":\"aiapi/src/sessionManager/RequestAdapters.h\"},{\"path\":\"aiapi/src/apiManager/ApiManager.h\"}]}"}}]},{"role":"tool","tool_call_id":"call_6b5ed8b0b406940cfe45657b","content":"File: aiapi/src/sessionManager/ToolCallBridge.h\nLines 1-257:\n  1 | #ifndef TOOL_CALL_BRIDGE_H\n  2 | #define TOOL_CALL_BRIDGE_H\n  3 | \n  4 | #include <string>\n  5 | #include <vector>\n  6 | #include <memory>\n  7 | #include <json/json.h>\n  8 | #include \"GenerationRequest.h\"\n  9 | \n 10 | namespace toolcall {\n 11 | \n 12 | /**\n 13 |  * @brief Tool Call 事件类型\n 14 |  * \n 15 |  * 用于表示解析过程中产生的事件\n 16 |  */\n 17 | enum class EventType {\n 18 |     Text,           // 普通文本 delta\n 19 |     ToolCallBegin,  // 工具调用开始\n 20 |     ToolCallArgsDelta,  // 工具调用参数增量\n 21 |     ToolCallEnd,    // 工具调用结束\n 22 |     Error           // 解析错误\n 23 | };\n 24 | \n 25 | /**\n 26 |  * @brief Tool Call 事件\n 27 |  * \n 28 |  * 解析器产出的事件结构\n 29 |  */\n 30 | struct ToolCallEvent {\n 31 |     EventType type = EventType::Text;\n 32 |     std::string text;           // Text 类型时的文本内容\n 33 |     std::string toolCallId;     // 工具调用 ID\n 34 |     std::string toolName;       // 工具名称\n 35 |     std::string argumentsDelta; // 参数增量 (JSON 片段)\n 36 |     std::string errorMessage;   // 错误信息\n 37 | };\n 38 | \n 39 | /**\n 40 |  * @brief Tool Call 结构\n 41 |  * \n 42 |  * 完整的工具调用表示\n 43 |  */\n 44 | struct ToolCall {\n 45 |     std::string id;             // 工具调用 ID\n 46 |     std::string name;           // 工具名称\n 47 |     std::string arguments;      // 参数 JSON 字符串\n 48 |     \n 49 |     // 从 JSON 构造\n 50 |     static ToolCall fromJson(const Json::Value& json);\n 51 |     // 转换为 JSON\n 52 |     Json::Value toJson() const;\n 53 | };\n 54 | \n 55 | /**\n 56 |  * @brief Tool Result 结构\n 57 |  * \n 58 |  * 工具执行结果表示\n 59 |  */\n 60 | struct ToolResult {\n 61 |     std::string toolCallId;     // 对应的工具调用 ID\n 62 |     std::string content;        // 结果内容\n 63 |     bool isError = false;       // 是否为错误结果\n 64 |     \n 65 |     // 从 JSON 构造\n 66 |     static ToolResult fromJson(const Json::Value& json);\n 67 |     // 转换为 JSON\n 68 |     Json::Value toJson() const;\n 69 | };\n 70 | \n 71 | /**\n 72 |  * @brief 桥接模式\n 73 |  * \n 74 |  * 决定如何处理 tool calls\n 75 |  */\n 76 | enum class BridgeMode {\n 77 |     Native,     // 上游原生支持 tool calls，直接透传\n 78 |     TextBridge  // 上游不支持 tool calls，需要转换为文本协议\n 79 | };\n 80 | \n 81 | /**\n 82 |  * @brief 通道能力\n 83 |  * \n 84 |  * 描述通道的功能特性\n 85 |  */\n 86 | struct ChannelCapabilities {\n 87 |     bool supportsToolCalls = true;      // 是否支持工具调用\n 88 |     bool supportsStreamingToolCalls = true;  // 是否支持流式工具调用\n 89 |     int maxToolPayloadBytes = 0;        // 最大工具载荷大小 (0=无限制)\n 90 |     \n 91 |     // 根据能力决定桥接模式\n 92 |     BridgeMode getBridgeMode() const {\n 93 |         return supportsToolCalls ? BridgeMode::Native : BridgeMode::TextBridge;\n 94 |     }\n 95 | };\n 96 | \n 97 | /**\n 98 |  * @brief 文本协议编解码器接口\n 99 |  * \n100 |  * 用于在不支持 tool calls 的通道上进行转换\n101 |  */\n102 | class IToolCallTextCodec {\n103 | public:\n104 |     virtual ~IToolCallTextCodec() = default;\n105 |     \n106 |     /**\n107 |      * @brief 将工具调用编码为文本\n108 |      * @param toolCall 工具调用结构\n109 |      * @return 编码后的文本\n110 |      */\n111 |     virtual std::string encodeToolCall(const ToolCall& toolCall) = 0;\n112 |     \n113 |     /**\n114 |      * @brief 将工具结果编码为文本\n115 |      * @param result 工具结果\n116 |      * @return 编码后的文本\n117 |      */\n118 |     virtual std::string encodeToolResult(const ToolResult& result) = 0;\n119 |     \n120 |     /**\n121 |      * @brief 生成工具定义的提示词\n122 |      * @param tools 工具定义列表\n123 |      * @return 注入到 system prompt 的文本\n124 |      */\n125 |     virtual std::string encodeToolDefinitions(const Json::Value& tools) = 0;\n126 |     \n127 |     /**\n128 |      * @brief 增量解析文本中的工具调用\n129 |      * @param chunk 输入的文本片段\n130 |      * @param events 输出的事件列表\n131 |      * @return 是否需要更多数据\n132 |      */\n133 |     virtual bool decodeIncremental(const std::string& chunk, std::vector<ToolCallEvent>& events) = 0;\n134 |     \n135 |     /**\n136 |      * @brief 刷新解析器缓冲区\n137 |      * @param events 输出的最终事件列表\n138 |      */\n139 |     virtual void flush(std::vector<ToolCallEvent>& events) = 0;\n140 |     \n141 |     /**\n142 |      * @brief 重置解析器状态\n143 |      */\n144 |     virtual void reset() = 0;\n145 | };\n146 | \n147 | /**\n148 |  * @brief ToolCallBridge 核心类\n149 |  * \n150 |  * 根据通道能力，选择执行请求/响应的转换\n151 |  */\n152 | class ToolCallBridge {\n153 | public:\n154 |     /**\n155 |      * @brief 构造函数\n156 |      * @param capabilities 通道能力\n157 |      */\n158 |     explicit ToolCallBridge(const ChannelCapabilities& capabilities);\n159 |     \n160 |     /**\n161 |      * @brief 获取桥接模式\n162 |      */\n163 |     BridgeMode getMode() const { return capabilities_.getBridgeMode(); }\n164 |     \n165 |     /**\n166 |      * @brief 是否需要进行转换\n167 |      */\n168 |     bool needsTransform() const { return getMode() == BridgeMode::TextBridge; }\n169 |     \n170 |     // ========== 请求侧转换 ==========\n171 |     \n172 |     /**\n173 |      * @brief 转换请求\n174 |      * \n175 |      * 当上游不支持 tool calls 时：\n176 |      * - 将 tool definitions 注入到 system prompt\n177 |      * - 将 tool calls 消息转换为文本格式\n178 |      * \n179 |      * @param messages 原始消息列表\n180 |      * @param tools 工具定义\n181 |      * @param systemPrompt 系统提示词（会被修改）\n182 |      * @return 转换后的消息列表\n183 |      */\n184 |     std::vector<Message> transformRequest(\n185 |         const std::vector<Message>& messages,\n186 |         const Json::Value& tools,\n187 |         std::string& systemPrompt\n188 |     );\n189 |     \n190 |     /**\n191 |      * @brief 转换单个消息中的 tool calls\n192 |      * @param toolCalls 工具调用列表\n193 |      * @return 转换后的文本\n194 |      */\n195 |     std::string transformToolCallsToText(const std::vector<ToolCall>& toolCalls);\n196 |     \n197 |     /**\n198 |      * @brief 转换 tool result 消息\n199 |      * @param result 工具结果\n200 |      * @return 转换后的文本\n201 |      */\n202 |     std::string transformToolResultToText(const ToolResult& result);\n203 |     \n204 |     // ========== 响应侧转换 ==========\n205 |     \n206 |     /**\n207 |      * @brief 处理响应文本块（流式）\n208 |      * \n209 |      * 当上游不支持 tool calls 时，解析文本中的工具调用标签\n210 |      * \n211 |      * @param chunk 输入的文本片段\n212 |      * @param events 输出的事件列表\n213 |      */\n214 |     void transformResponseChunk(\n215 |         const std::string& chunk,\n216 |         std::vector<ToolCallEvent>& events\n217 |     );\n218 |     \n219 |     /**\n220 |      * @brief 刷新响应解析器\n221 |      * @param events 输出的最终事件列表\n222 |      */\n223 |     void flushResponse(std::vector<ToolCallEvent>& events);\n224 |     \n225 |     /**\n226 |      * @brief 重置响应解析器状态\n227 |      */\n228 |     void resetResponseParser();\n229 |     \n230 |     // ========== 工具方法 ==========\n231 |     \n232 |     /**\n233 |      * @brief 设置文本编解码器\n234 |      * @param codec 编解码器实例\n235 |      */\n236 |     void setTextCodec(std::shared_ptr<IToolCallTextCodec> codec);\n237 |     \n238 |     /**\n239 |      * @brief 获取当前编解码器\n240 |      */\n241 |     std::shared_ptr<IToolCallTextCodec> getTextCodec() const { return codec_; }\n242 |     \n243 | private:\n244 |     ChannelCapabilities capabilities_;\n245 |     std::shared_ptr<IToolCallTextCodec> codec_;\n246 | };\n247 | \n248 | /**\n249 |  * @brief 创建默认的 ToolCallBridge\n250 |  * @param supportsToolCalls 是否支持工具调用\n251 |  * @return ToolCallBridge 实例\n252 |  */\n253 | std::shared_ptr<ToolCallBridge> createToolCallBridge(bool supportsToolCalls);\n254 | \n255 | } // namespace toolcall\n256 | \n257 | #endif // TOOL_CALL_BRIDGE_H\n\n\n---\n\nFile: aiapi/src/sessionManager/SessionExecutionGate.h\nLines 1-295:\n  1 | #ifndef SESSION_EXECUTION_GATE_H\n  2 | #define SESSION_EXECUTION_GATE_H\n  3 | \n  4 | #include <string>\n  5 | #include <mutex>\n  6 | #include <unordered_map>\n  7 | #include <memory>\n  8 | #include <atomic>\n  9 | #include <functional>\n 10 | \n 11 | /**\n 12 |  * @brief 会话执行门控\n 13 |  * \n 14 |  * 用于控制同一会话的并发执行，防止同一 sessionKey 的请求并发执行导致输出互相打架。\n 15 |  * \n 16 |  * 策略：\n 17 |  * - RejectConcurrent: 拒绝并发请求（返回 409 Conflict）\n 18 |  * - CancelPrevious: 取消之前的请求，执行新请求\n 19 |  * \n 20 |  * 参考设计文档: plans/aiapi-refactor-design.md 第 9 节\n 21 |  */\n 22 | \n 23 | namespace session {\n 24 | \n 25 | /**\n 26 |  * @brief 取消令牌\n 27 |  * \n 28 |  * 用于请求级取消标记。请求执行过程中可以检查是否已被取消。\n 29 |  */\n 30 | class CancellationToken {\n 31 | public:\n 32 |     CancellationToken() : cancelled_(false) {}\n 33 |     \n 34 |     /**\n 35 |      * @brief 请求取消\n 36 |      */\n 37 |     void cancel() {\n 38 |         cancelled_.store(true, std::memory_order_release);\n 39 |     }\n 40 |     \n 41 |     /**\n 42 |      * @brief 检查是否已取消\n 43 |      */\n 44 |     bool isCancelled() const {\n 45 |         return cancelled_.load(std::memory_order_acquire);\n 46 |     }\n 47 |     \n 48 |     /**\n 49 |      * @brief 重置取消状态\n 50 |      */\n 51 |     void reset() {\n 52 |         cancelled_.store(false, std::memory_order_release);\n 53 |     }\n 54 |     \n 55 | private:\n 56 |     std::atomic<bool> cancelled_;\n 57 | };\n 58 | \n 59 | using CancellationTokenPtr = std::shared_ptr<CancellationToken>;\n 60 | \n 61 | /**\n 62 |  * @brief 并发策略\n 63 |  */\n 64 | enum class ConcurrencyPolicy {\n 65 |     RejectConcurrent,   // 拒绝并发请求\n 66 |     CancelPrevious      // 取消之前的请求\n 67 | };\n 68 | \n 69 | /**\n 70 |  * @brief 执行门控结果\n 71 |  */\n 72 | enum class GateResult {\n 73 |     Acquired,           // 成功获取执行权\n 74 |     Rejected,           // 被拒绝（已有请求在执行）\n 75 |     Cancelled           // 之前的请求被取消\n 76 | };\n 77 | \n 78 | /**\n 79 |  * @brief 会话执行槽位\n 80 |  * \n 81 |  * 表示一个会话的执行状态\n 82 |  */\n 83 | struct SessionSlot {\n 84 |     std::mutex mutex;                   // 执行互斥锁\n 85 |     CancellationTokenPtr currentToken;  // 当前执行的取消令牌\n 86 |     std::atomic<bool> executing{false}; // 是否正在执行\n 87 |     \n 88 |     SessionSlot() : currentToken(nullptr) {}\n 89 | };\n 90 | \n 91 | using SessionSlotPtr = std::shared_ptr<SessionSlot>;\n 92 | \n 93 | /**\n 94 |  * @brief 会话执行门控\n 95 |  * \n 96 |  * 单例模式，管理所有会话的执行状态\n 97 |  */\n 98 | class SessionExecutionGate {\n 99 | public:\n100 |     /**\n101 |      * @brief 获取单例实例\n102 |      */\n103 |     static SessionExecutionGate& getInstance() {\n104 |         static SessionExecutionGate instance;\n105 |         return instance;\n106 |     }\n107 |     \n108 |     /**\n109 |      * @brief 尝试获取执行权\n110 |      * \n111 |      * @param sessionKey 会话标识\n112 |      * @param policy 并发策略\n113 |      * @param outToken 输出参数，成功获取时返回取消令牌\n114 |      * @return GateResult 获取结果\n115 |      */\n116 |     GateResult tryAcquire(\n117 |         const std::string& sessionKey,\n118 |         ConcurrencyPolicy policy,\n119 |         CancellationTokenPtr& outToken\n120 |     ) {\n121 |         SessionSlotPtr slot = getOrCreateSlot(sessionKey);\n122 |         \n123 |         // 尝试获取槽位锁\n124 |         std::unique_lock<std::mutex> lock(slot->mutex, std::try_to_lock);\n125 |         \n126 |         if (!lock.owns_lock()) {\n127 |             // 无法立即获取锁，说明有请求正在执行\n128 |             if (policy == ConcurrencyPolicy::RejectConcurrent) {\n129 |                 return GateResult::Rejected;\n130 |             }\n131 |             \n132 |             // CancelPrevious 策略：取消之前的请求\n133 |             if (slot->currentToken) {\n134 |                 slot->currentToken->cancel();\n135 |             }\n136 |             \n137 |             // 等待获取锁\n138 |             lock.lock();\n139 |         }\n140 |         \n141 |         // 成功获取执行权\n142 |         outToken = std::make_shared<CancellationToken>();\n143 |         slot->currentToken = outToken;\n144 |         slot->executing.store(true, std::memory_order_release);\n145 |         \n146 |         return GateResult::Acquired;\n147 |     }\n148 |     \n149 |     /**\n150 |      * @brief 释放执行权\n151 |      * \n152 |      * @param sessionKey 会话标识\n153 |      */\n154 |     void release(const std::string& sessionKey) {\n155 |         std::lock_guard<std::mutex> mapLock(mapMutex_);\n156 |         auto it = slots_.find(sessionKey);\n157 |         if (it != slots_.end()) {\n158 |             it->second->executing.store(false, std::memory_order_release);\n159 |             it->second->currentToken = nullptr;\n160 |         }\n161 |     }\n162 |     \n163 |     /**\n164 |      * @brief 检查会话是否正在执行\n165 |      * \n166 |      * @param sessionKey 会话标识\n167 |      * @return true 正在执行\n168 |      */\n169 |     bool isExecuting(const std::string& sessionKey) const {\n170 |         std::lock_guard<std::mutex> mapLock(mapMutex_);\n171 |         auto it = slots_.find(sessionKey);\n172 |         if (it != slots_.end()) {\n173 |             return it->second->executing.load(std::memory_order_acquire);\n174 |         }\n175 |         return false;\n176 |     }\n177 |     \n178 |     /**\n179 |      * @brief 清理过期的槽位（可选，用于内存管理）\n180 |      * \n181 |      * @param maxIdleSlots 最大空闲槽位数\n182 |      */\n183 |     void cleanup(size_t maxIdleSlots = 1000) {\n184 |         std::lock_guard<std::mutex> mapLock(mapMutex_);\n185 |         \n186 |         // 移除未在执行的槽位，保留最多 maxIdleSlots 个\n187 |         std::vector<std::string> toRemove;\n188 |         for (const auto& pair : slots_) {\n189 |             if (!pair.second->executing.load(std::memory_order_acquire)) {\n190 |                 toRemove.push_back(pair.first);\n191 |             }\n192 |         }\n193 |         \n194 |         // 如果空闲槽位超过限制，移除多余的\n195 |         if (toRemove.size() > maxIdleSlots) {\n196 |             for (size_t i = maxIdleSlots; i < toRemove.size(); ++i) {\n197 |                 slots_.erase(toRemove[i]);\n198 |             }\n199 |         }\n200 |     }\n201 |     \n202 | private:\n203 |     SessionExecutionGate() = default;\n204 |     ~SessionExecutionGate() = default;\n205 |     \n206 |     // 禁用拷贝\n207 |     SessionExecutionGate(const SessionExecutionGate&) = delete;\n208 |     SessionExecutionGate& operator=(const SessionExecutionGate&) = delete;\n209 |     \n210 |     /**\n211 |      * @brief 获取或创建会话槽位\n212 |      */\n213 |     SessionSlotPtr getOrCreateSlot(const std::string& sessionKey) {\n214 |         std::lock_guard<std::mutex> lock(mapMutex_);\n215 |         auto it = slots_.find(sessionKey);\n216 |         if (it == slots_.end()) {\n217 |             auto slot = std::make_shared<SessionSlot>();\n218 |             slots_[sessionKey] = slot;\n219 |             return slot;\n220 |         }\n221 |         return it->second;\n222 |     }\n223 |     \n224 |     mutable std::mutex mapMutex_;\n225 |     std::unordered_map<std::string, SessionSlotPtr> slots_;\n226 | };\n227 | \n228 | /**\n229 |  * @brief RAII 风格的执行门控守卫\n230 |  * \n231 |  * 自动在作用域结束时释放执行权\n232 |  */\n233 | class ExecutionGuard {\n234 | public:\n235 |     ExecutionGuard(\n236 |         const std::string& sessionKey,\n237 |         ConcurrencyPolicy policy = ConcurrencyPolicy::RejectConcurrent\n238 |     ) : sessionKey_(sessionKey), acquired_(false) {\n239 |         result_ = SessionExecutionGate::getInstance().tryAcquire(\n240 |             sessionKey, policy, token_\n241 |         );\n242 |         acquired_ = (result_ == GateResult::Acquired);\n243 |     }\n244 |     \n245 |     ~ExecutionGuard() {\n246 |         if (acquired_) {\n247 |             SessionExecutionGate::getInstance().release(sessionKey_);\n248 |         }\n249 |     }\n250 |     \n251 |     // 禁用拷贝\n252 |     ExecutionGuard(const ExecutionGuard&) = delete;\n253 |     ExecutionGuard& operator=(const ExecutionGuard&) = delete;\n254 |     \n255 |     // 允许移动\n256 |     ExecutionGuard(ExecutionGuard&& other) noexcept\n257 |         : sessionKey_(std::move(other.sessionKey_)),\n258 |           token_(std::move(other.token_)),\n259 |           result_(other.result_),\n260 |           acquired_(other.acquired_) {\n261 |         other.acquired_ = false;\n262 |     }\n263 |     \n264 |     /**\n265 |      * @brief 是否成功获取执行权\n266 |      */\n267 |     bool isAcquired() const { return acquired_; }\n268 |     \n269 |     /**\n270 |      * @brief 获取门控结果\n271 |      */\n272 |     GateResult getResult() const { return result_; }\n273 |     \n274 |     /**\n275 |      * @brief 获取取消令牌\n276 |      */\n277 |     CancellationTokenPtr getToken() const { return token_; }\n278 |     \n279 |     /**\n280 |      * @brief 检查是否已被取消\n281 |      */\n282 |     bool isCancelled() const {\n283 |         return token_ && token_->isCancelled();\n284 |     }\n285 |     \n286 | private:\n287 |     std::string sessionKey_;\n288 |     CancellationTokenPtr token_;\n289 |     GateResult result_;\n290 |     bool acquired_;\n291 | };\n292 | \n293 | } // namespace session\n294 | \n295 | #endif // SESSION_EXECUTION_GATE_H\n\n\n---\n\nFile: aiapi/src/sessionManager/ContinuityResolver.h\nLines 1-43:\n 1 | #ifndef CONTINUITY_RESOLVER_H\n 2 | #define CONTINUITY_RESOLVER_H\n 3 | \n 4 | #include <string>\n 5 | \n 6 | #include \"GenerationRequest.h\"\n 7 | #include \"Session.h\"\n 8 | \n 9 | /**\n10 |  * @brief 会话连续性决策结果\n11 |  */\n12 | struct ContinuityDecision {\n13 |     enum class Source {\n14 |         PreviousResponseId,  // /v1/responses: previous_response_id 命中\n15 |         ZeroWidth,           // 零宽字符解析命中\n16 |         Hash,                // Hash 规则\n17 |         NewSession           // 创建新会话\n18 |     };\n19 | \n20 |     Source source = Source::NewSession;\n21 |     SessionTrackingMode mode = SessionTrackingMode::Hash;\n22 |     std::string sessionId;\n23 |     std::string debug;\n24 | };\n25 | \n26 | /**\n27 |  * @brief 会话连续性决策器\n28 |  *\n29 |  * 只负责“从请求得到应该使用的 sessionId”，不直接编排 provider 调用。\n30 |  */\n31 | class ContinuityResolver {\n32 | public:\n33 |     ContinuityDecision resolve(const GenerationRequest& req) const;\n34 | \n35 |     static std::string generateNewSessionId();  // sess_<timestamp>_<rand>\n36 | \n37 | private:\n38 |     static std::string resolveHashSessionId(const GenerationRequest& req);\n39 |     static std::string resolveZeroWidthSessionId(const GenerationRequest& req);\n40 | };\n41 | \n42 | #endif // CONTINUITY_RESOLVER_H\n\n\n---\n\nFile: aiapi/src/sessionManager/RequestAdapters.h\nLines 1-138:\n  1 | #ifndef REQUEST_ADAPTERS_H\n  2 | #define REQUEST_ADAPTERS_H\n  3 | \n  4 | #include \"GenerationRequest.h\"\n  5 | #include \"Session.h\"\n  6 | #include <drogon/HttpRequest.h>\n  7 | #include <json/json.h>\n  8 | \n  9 | /**\n 10 |  * @brief 请求适配器\n 11 |  * \n 12 |  * 负责将 HTTP 请求转换为统一的 GenerationRequest。\n 13 |  * 这是 \"HTTP → GenerationRequest\" 转换的唯一实现点。\n 14 |  * \n 15 |  * 参考设计文档: plans/single-entrypoint-generationrequest-plan.md PR1\n 16 |  */\n 17 | class RequestAdapters {\n 18 | public:\n 19 |     /**\n 20 |      * @brief 从 Chat Completions API 请求构建 GenerationRequest\n 21 |      * \n 22 |      * 解析 OpenAI Chat Completions API 格式的请求，提取：\n 23 |      * - model: 模型名称\n 24 |      * - messages: 消息数组（包含 system/user/assistant 角色）\n 25 |      * - stream: 是否流式输出\n 26 |      * - 客户端信息（从 HTTP 头提取）\n 27 |      * \n 28 |      * @param req HTTP 请求\n 29 |      * @return GenerationRequest 统一生成请求\n 30 |      */\n 31 |     static GenerationRequest buildGenerationRequestFromChat(\n 32 |         const drogon::HttpRequestPtr& req\n 33 |     );\n 34 |     \n 35 |     /**\n 36 |      * @brief 从 Responses API 请求构建 GenerationRequest\n 37 |      * \n 38 |      * 解析 OpenAI Responses API 格式的请求，提取：\n 39 |      * - model: 模型名称\n 40 |      * - input: 输入内容（字符串或数组）\n 41 |      * - instructions: 系统指令（映射到 systemPrompt）\n 42 |      * - previous_response_id: 前一个响应ID（用于续聊）\n 43 |      * - stream: 是否流式输出\n 44 |      * - 客户端信息（从 HTTP 头提取）\n 45 |      * \n 46 |      * @param req HTTP 请求\n 47 |      * @return GenerationRequest 统一生成请求\n 48 |      */\n 49 |     static GenerationRequest buildGenerationRequestFromResponses(\n 50 |         const drogon::HttpRequestPtr& req\n 51 |     );\n 52 |     \n 53 | private:\n 54 |     /**\n 55 |      * @brief 从 HTTP 请求中提取客户端信息\n 56 |      * \n 57 |      * @param req HTTP 请求\n 58 |      * @return Json::Value 客户端信息\n 59 |      */\n 60 |     static Json::Value extractClientInfo(const drogon::HttpRequestPtr& req);\n 61 |     \n 62 |     /**\n 63 |      * @brief 解析 Chat API 的 messages 数组\n 64 |      *\n 65 |      * 将 JSON 格式的 messages 数组转换为内部 Message 结构。\n 66 |      * 支持：\n 67 |      * - 简单字符串 content\n 68 |      * - 数组格式 content（包含 text 和 image_url 类型）\n 69 |      *\n 70 |      * @param messages JSON messages 数组\n 71 |      * @param[out] result 解析后的消息列表\n 72 |      * @param[out] systemPrompt 提取的系统提示词\n 73 |      * @param[out] currentInput 当前用户输入\n 74 |      * @param[out] images 提取的图片信息\n 75 |      */\n 76 |     static void parseChatMessages(\n 77 |         const Json::Value& messages,\n 78 |         std::vector<Message>& result,\n 79 |         std::string& systemPrompt,\n 80 |         std::string& currentInput,\n 81 |         std::vector<ImageInfo>& images\n 82 |     );\n 83 |     \n 84 |     /**\n 85 |      * @brief 解析 Responses API 的 input 字段\n 86 |      * \n 87 |      * 支持：\n 88 |      * - 简单字符串输入\n 89 |      * - 数组格式输入（包含历史消息和当前输入）\n 90 |      * \n 91 |      * @param input JSON input 字段\n 92 |      * @param[out] messages 解析后的历史消息\n 93 |      * @param[out] currentInput 当前用户输入\n 94 |      * @param[out] images 提取的图片信息\n 95 |      */\n 96 |     static void parseResponseInput(\n 97 |         const Json::Value& input,\n 98 |         std::vector<Message>& messages,\n 99 |         std::string& currentInput,\n100 |         std::vector<ImageInfo>& images\n101 |     );\n102 | \n103 |     /**\n104 |      * @brief 解析 Responses API 的 input_items 字段（部分客户端使用）\n105 |      *\n106 |      * 目前仅将其中的文本汇总到 currentInput，并解析图片。\n107 |      */\n108 |     static void parseResponseInputItems(\n109 |         const Json::Value& inputItems,\n110 |         std::string& currentInput,\n111 |         std::vector<ImageInfo>& images\n112 |     );\n113 |     \n114 |     /**\n115 |      * @brief 从 content 字段中提取文本和图片\n116 |      * \n117 |      * @param content JSON content 字段（字符串或数组）\n118 |      * @param[out] images 提取的图片信息\n119 |      * @param stripZeroWidth 是否移除零宽字符\n120 |      * @return std::string 提取的文本内容\n121 |      */\n122 |     static std::string extractContentText(\n123 |         const Json::Value& content,\n124 |         std::vector<ImageInfo>& images,\n125 |         bool stripZeroWidth = false,\n126 |         std::vector<std::string>* outRawTexts = nullptr\n127 |     );\n128 |     \n129 |     /**\n130 |      * @brief 解析图片 URL 为 ImageInfo\n131 |      * \n132 |      * @param url 图片 URL（可以是 data: URL 或普通 URL）\n133 |      * @return ImageInfo 图片信息\n134 |      */\n135 |     static ImageInfo parseImageUrl(const std::string& url);\n136 | };\n137 | \n138 | #endif // REQUEST_ADAPTERS_H\n\n\n---\n\nFile: aiapi/src/apiManager/ApiManager.h\nLines 1-44:\n 1 | #include \"ApiFactory.h\"\n 2 | #include \"./apipoint/APIinterface.h\"\n 3 | #include <unordered_map>\n 4 | #include <queue>\n 5 | \n 6 | using namespace std;\n 7 | struct ApiInfo\n 8 | {\n 9 |     string apiName;\n10 |    shared_ptr<APIinterface> api;\n11 |    bool status=true;\n12 |    int apiUseCount=0;\n13 |    ApiInfo(string apiName,shared_ptr<APIinterface> api):apiName(apiName),api(api){}\n14 | };\n15 | class Compare\n16 | {\n17 | public:\n18 |     bool operator()(const std::shared_ptr<ApiInfo>& a, const std::shared_ptr<ApiInfo>& b)\n19 |     {\n20 |         return a->apiUseCount > b->apiUseCount;\n21 |     }\n22 | };\n23 | class ApiManager\n24 | {\n25 | private:\n26 |     /* data */\n27 |     unordered_map<string, std::priority_queue<std::shared_ptr<ApiInfo>,vector<std::shared_ptr<ApiInfo>>,Compare>> m_ModelnameApiQueueMap;\n28 |     unordered_map<string,std::shared_ptr<ApiInfo>> m_ApiNameApiMap;\n29 | public:\n30 |     ApiManager();\n31 |     ~ApiManager();\n32 |     void init();\n33 |     static ApiManager& getInstance();\n34 |     void addApiInfo(std::shared_ptr<ApiInfo> apiInfo);\n35 |     void updateApiInfo(std::shared_ptr<ApiInfo> apiInfo);\n36 |     std::shared_ptr<ApiInfo> getApiInfoByApiName(string apiName);\n37 |     std::shared_ptr<ApiInfo> getApiInfoByModelName(string modelName);\n38 |     std::shared_ptr<APIinterface> getApiByApiName(string apiName);\n39 |     void  disableApiByApiName(const string& apiName);\n40 |     void disableModel_Api(const string& modelName,const string& apiName);\n41 |     void enableApiByApiName(const string& apiName);\n42 |     void enableModel_Api(const string& modelName,const string& apiName);\n43 |    void flushModelnameApiQueueMap(const string& modelName);\n44 | };\n\n<environment_details>\n# VSCode Visible Files\naiapi/src/build/logs/aiapi.log\n\n# VSCode Open Tabs\naiapi/src/build/logs/aiapi.log,aiapi/src/sessionManager/GenerationService.cpp,aiapi/src/build/logs/1.txt,aiapi/src/sessionManager/XmlTagToolCallCodec.cpp,aiapi/src/sessionManager/XmlTagToolCallCodec.h,aiapi/src/apipoint/chaynsapi/chaynsapi.cpp,aiapi/src/apipoint/chaynsapi/chaynsapi.h,aiapi/doc/aiapi_callflow_and_api_examples.md,aiapi/README.md,aiapi/src/controllers/AiApi.cc,aiapi/src/accountManager/accountManager.h,aiapi/src/accountManager/accountManager.cpp,aiapi_web/src/components/LogViewer.tsx,aiapi_web/src/components/LogViewer.css,aiapi_web/src/App.tsx,aiapi_web/src/components/AccountManager.tsx,aiapi_web/src/components/AccountManager.css,aiapi/src/controllers/AiApi.h,aiapi/src/main.cc,aiapi/src/config.json\n\n# Current Time\nCurrent time in ISO 8601 UTC format: 2026-02-07T15:03:23.108Z\nUser time zone: America/Los_Angeles, UTC-8:00\n\n# Current Cost\n$0.00\n\n# Current Mode\n<slug>architect</slug>\n<name>Architect</name>\n<model>Claude Opus 4.6</model>\n<tool_format>native</tool_format>\nYou have not created a todo list yet. Create one with `update_todo_list` if your task is complicated or involves multiple steps.\n</environment_details>"},{"role":"assistant","content":"⁠⁠‌﻿‍‍‌﻿‌﻿‌‌﻿﻿​﻿​‌​﻿‌﻿​﻿‌﻿​﻿​​​﻿‌​​﻿‌﻿​﻿‌‍​﻿‌‍​﻿‍​​﻿‍‌​﻿‌‌​﻿‍​​﻿‌﻿‌‌﻿﻿​﻿‌​​﻿​﻿​﻿‌‍​﻿​​⁠⁠","tool_calls":[{"id":"call_e9d191c419e173793808c07c","type":"function","function":{"name":"attempt_completion","arguments":"{\"result\":\"# aiapi 项目深度解析\\n\\n## 一、项目概述\\n\\n`aiapi` 是一个基于 **C++17/20 + Drogon 框架** 构建的 **AI API 网关服务**，提供与 OpenAI 兼容的 Chat Completions API 和 Responses API 接口。项目版本为 **1.1**（更新时间 2026/02/07），采用 MIT 许可证。\\n\\n核心定位：**作为 AI 模型的统一接入网关**，在客户端和上游 AI Provider 之间提供请求适配、会话管理、工具调用桥接、并发控制、错误统计等能力。\\n\\n---\\n\\n## 二、技术栈\\n\\n| 组件 | 技术 |\\n|------|------|\\n| 语言 | C++17/20 |\\n| Web 框架 | [Drogon](https://github.com/drogonframework/drogon) |\\n| 构建系统 | CMake 3.5+ |\\n| JSON 库 | JsonCpp |\\n| 加密 | OpenSSL（SHA256 哈希） |\\n| 日志 | spdlog |\\n| 数据库 | PostgreSQL / SQLite3（可配置） |\\n| 监控 | Prometheus（通过 Drogon PromExporter 插件） |\\n| 容器化 | Docker + Docker Compose |\\n| Python 辅助 | FastAPI + Selenium（账号登录/注册服务） |\\n\\n---\\n\\n## 三、架构分层\\n\\n项目采用**分层架构**，自上而下分为 5 层：\\n\\n```mermaid\\ngraph TB\\n    subgraph HTTP层\\n        A[AiApi Controller<br/>25+ API 端点]\\n    end\\n    subgraph 适配层\\n        B[RequestAdapters<br/>HTTP请求 → GenerationRequest]\\n    end\\n    subgraph 编排层\\n        C[GenerationService<br/>核心编排服务]\\n        D[ContinuityResolver<br/>会话连续性决策]\\n        E[SessionExecutionGate<br/>并发门控]\\n        F[ToolCallBridge<br/>工具调用桥接]\\n        G[ClientOutputSanitizer<br/>输出清洗]\\n        H[ToolCallValidator<br/>工具调用校验]\\n    end\\n    subgraph Provider层\\n        I[ApiManager<br/>路由 + 负载均衡]\\n        J[APIinterface<br/>Provider 抽象接口]\\n        K[chaynsapi<br/>Provider 实现]\\n    end\\n    subgraph 输出层\\n        L[IResponseSink<br/>输出通道接口]\\n        M[ChatJsonSink / ChatSseSink]\\n        N[ResponsesJsonSink / ResponsesSseSink]\\n        O[CollectorSink / NullSink]\\n    end\\n\\n    A --> B\\n    B --> C\\n    C --> D\\n    C --> E\\n    C --> F\\n    C --> G\\n    C --> H\\n    C --> I\\n    I --> J\\n    J --> K\\n    C --> L\\n    L --> M\\n    L --> N\\n    L --> O\\n```\\n\\n---\\n\\n## 四、核心模块详解\\n\\n### 4.1 HTTP 层 — [`AiApi`](aiapi/src/controllers/AiApi.h:6) Controller\\n\\n- 继承自 `drogon::HttpController<AiApi>`\\n- 注册了 **25+ 个 API 端点**，分为：\\n  - **AI 核心 API**：Chat Completions、Responses（CRUD）、Models\\n  - **账号管理 API**：增删改查 + Token 刷新 + 自动注册\\n  - **渠道管理 API**：增删改 + 状态控制\\n  - **监控 API**：请求时序、错误统计、服务状态\\n  - **日志 API**：日志文件列表、尾部读取\\n\\n### 4.2 适配层 — [`RequestAdapters`](aiapi/src/sessionManager/RequestAdapters.h:17)\\n\\n**唯一职责**：将 HTTP 请求转换为统一的 [`GenerationRequest`](aiapi/src/sessionManager/GenerationRequest.h:126) 结构。\\n\\n- `buildGenerationRequestFromChat()` — 解析 Chat Completions API 格式\\n- `buildGenerationRequestFromResponses()` — 解析 Responses API 格式\\n- 统一提取：model、messages、tools、stream、clientInfo、images 等\\n\\n[`GenerationRequest`](aiapi/src/sessionManager/GenerationRequest.h:126) 是一个**协议无关的统一请求结构**，包含：\\n- 入口类型（`EndpointType`：ChatCompletions / Responses）\\n- 强类型消息列表（`std::vector<Message>`）\\n- 工具定义 + 工具选择策略\\n- 图片信息（`std::vector<ImageInfo>`）\\n- 会话连续性字段（`previousResponseId`、`continuityTexts`）\\n\\n### 4.3 编排层 — [`GenerationService`](aiapi/src/sessionManager/GenerationService.h:25)（核心）\\n\\n**整个系统的心脏**，编排完整的生成流程：\\n\\n```mermaid\\nflowchart TD\\n    A[runGuarded] --> B[materializeSession<br/>GenerationRequest → session_st]\\n    B --> C[ContinuityResolver::resolve<br/>会话连续性决策]\\n    C --> D[getOrCreateSession<br/>获取或创建会话]\\n    D --> E[executeGuardedWithSession]\\n    E --> F[ExecutionGuard - RAII<br/>获取并发锁]\\n    F --> G{锁获取成功?}\\n    G -- 否 --> H[返回 409 Conflict]\\n    G -- 是 --> I[transformRequestForToolBridge<br/>工具定义注入 - Bridge模式]\\n    I --> J[executeProvider<br/>调用上游 AI]\\n    J --> K[emitResultEvents<br/>结果处理 + 事件发送]\\n    K --> K1[sanitizeOutput - 文本清洗]\\n    K1 --> K2[parseXmlToolCalls - XML工具调用解析]\\n    K2 --> K3[normalizeToolCallArguments - 参数规范化]\\n    K3 --> K4[ToolCallValidator - Schema校验]\\n    K4 --> K5[applyStrictClientRules - 严格客户端规则]\\n    K5 --> K6[零宽字符会话ID嵌入]\\n    K6 --> L[coverSessionresponse<br/>会话上下文更新 + 转移]\\n```\\n\\n### 4.4 会话管理 — [`chatSession`](aiapi/src/sessionManager/Session.h:127)\\n\\n**单例模式**，管理所有会话生命周期：\\n\\n- **两种追踪模式**：\\n  - **Hash 模式**：基于 `systemPrompt + messages` 的 SHA256 哈希作为 sessionId\\n  - **ZeroWidth 模式**：在 AI 回复中嵌入零宽字符编码的 sessionId\\n\\n- **两阶段会话转移**（ZeroWidth/Hash 共用）：\\n  1. `prepareNextSessionId()` — 预生成下一轮 sessionId\\n  2. `commitSessionTransfer()` — 响应发送后执行实际转移\\n\\n- 核心数据结构 [`session_st`](aiapi/src/sessionManager/Session.h:51)：包含 API 类型、模型、系统提示、请求/响应消息、工具定义、会话状态标记等\\n\\n### 4.5 并发门控 — [`SessionExecutionGate`](aiapi/src/sessionManager/SessionExecutionGate.h:98)\\n\\n防止同一会话的并发请求互相打架：\\n\\n- **RejectConcurrent**：拒绝并发，返回 409 Conflict\\n- **CancelPrevious**：取消前一个请求，执行新请求\\n- 使用 [`CancellationToken`](aiapi/src/sessionManager/SessionExecutionGate.h:30)（原子标记）实现取消通知\\n- 使用 RAII [`ExecutionGuard`](aiapi/src/sessionManager/SessionExecutionGate.h:233) 自动管理生命周期\\n\\n### 4.6 工具调用桥接 — [`ToolCallBridge`](aiapi/src/sessionManager/ToolCallBridge.h:152)\\n\\n为**不支持原生 Tool Calls 的上游通道**提供 XML 文本桥接：\\n\\n- **请求侧**：将工具定义编码为 `<tool_instructions>` 文本注入请求\\n- **响应侧**：使用 `XmlTagToolCallCodec` 解析 `<function_calls>/<function_call>` XML 结构\\n- 支持两种模式：`BridgeMode::Native`（透传）和 `BridgeMode::TextBridge`（文本桥接）\\n- 使用**随机触发标记**（如 `<Function_Ab1c_Start/>`）防止误解析历史消息\\n\\n### 4.7 会话连续性决策 — [`ContinuityResolver`](aiapi/src/sessionManager/ContinuityResolver.h:31)\\n\\n纯决策组件，根据请求确定应使用的 sessionId：\\n\\n| 优先级 | 来源 | 说明 |\\n|--------|------|------|\\n| 1 | PreviousResponseId | Responses API 的 `previous_response_id` 命中 |\\n| 2 | ZeroWidth | 零宽字符解析出 sessionId |\\n| 3 | Hash | Hash 规则计算 sessionId |\\n| 4 | NewSession | 创建全新会话 |\\n\\n### 4.8 Provider 层\\n\\n- [`APIinterface`](aiapi/src/apipoint/APIinterface.h:16) — 抽象接口，定义 `generate()`、`postChatMessage()`、`getModels()` 等方法\\n- [`ProviderResult`](aiapi/src/apipoint/ProviderResult.h:92) — Provider 返回的结构化结果（text + usage + error）\\n- [`ApiManager`](aiapi/src/apiManager/ApiManager.h:23) — Provider 路由选择，使用**优先队列**实现负载均衡（基于使用计数）\\n- 目前仅有 `chaynsapi` 一个 Provider 实现\\n\\n### 4.9 输出层 — [`IResponseSink`](aiapi/src/sessionManager/IResponseSink.h:16)\\n\\n**策略模式**，Session 层产生语义事件，Sink 负责编码为协议格式：\\n\\n| Sink | 功能 |\\n|------|------|\\n| `ChatJsonSink` | Chat 非流式 JSON 响应 |\\n| `ChatSseSink` | Chat 流式 SSE 响应 |\\n| `ResponsesJsonSink` | Responses 非流式 JSON 响应 |\\n| `ResponsesSseSink` | Responses 流式 SSE 响应 |\\n| `CollectorSink` | 事件收集器（内部使用） |\\n| `NullSink` | 空 Sink（测试用） |\\n\\n### 4.10 统一事件模型 — [`GenerationEvent`](aiapi/src/sessionManager/GenerationEvent.h:115)\\n\\n使用 `std::variant` 实现类型安全的事件多态：\\n\\n- `Started` → 生成开始（responseId, model）\\n- `OutputTextDelta` → 文本增量（流式）\\n- `OutputTextDone` → 文本完成\\n- `ToolCallDone` → 工具调用完成\\n- `Usage` → Token 使用量\\n- `Completed` → 生成完成（finishReason）\\n- `Error` → 错误（code, message）\\n\\n---\\n\\n## 五、错误处理体系\\n\\n项目有**三层错误模型**：\\n\\n1. **Provider 层** — [`ProviderError`](aiapi/src/apipoint/ProviderResult.h:35)：网络、认证、限流、超时等\\n2. **Generation 层** — [`generation::Error`](aiapi/src/sessionManager/GenerationEvent.h:101)：事件模型中的错误\\n3. **应用层** — [`error::AppError`](aiapi/src/sessionManager/Errors.h:77)：统一错误结构，映射到 HTTP 状态码\\n\\n错误统计按 4 个域分类：`SESSION_GATE`、`UPSTREAM`、`TOOL_BRIDGE`、`INTERNAL`。\\n\\n---\\n\\n## 六、基础设施\\n\\n### 6.1 账号管理\\n- 账号池管理（`accountManager`）：CRUD + Token 刷新 + 类型检测 + 自动注册\\n- 数据持久化（`accountDbManager`）：支持 PostgreSQL/SQLite3\\n- 外部登录服务：通过 Python FastAPI + Selenium 实现浏览器自动化登录\\n\\n### 6.2 渠道管理\\n- 渠道 CRUD + 状态控制（启用/禁用）\\n- 支持 `supports_tool_calls` 字段控制是否启用 Tool Bridge\\n- 并发限制配置（`maxconcurrent`）\\n\\n### 6.3 监控与日志\\n- Prometheus 指标导出（`/metrics`）\\n- 服务状态概览、渠道状态、模型状态 API\\n- 错误时序统计 + 错误事件详情查询\\n- 日志文件列表 + 尾部读取 + 级别/关键词过滤\\n\\n---\\n\\n## 七、客户端适配\\n\\n| 客户端 | 标识 | 特殊处理 |\\n|--------|------|----------|\\n| Kilo-Code | `Kilo-Code` | 严格模式：每次只能 1 个 tool call，纯文本自动包装为 `attempt_completion` |\\n| RooCode | `RooCode` | 同 Kilo-Code |\\n| Claude Code | `claudecode` | 零宽会话 ID 在 tool_calls 前单独发送 |\\n| 其他 | — | 宽松模式 |\\n\\n---\\n\\n## 八、部署方式\\n\\n1. **本地构建**：`cmake .. && make -j$(nproc)` → `./aiapi`（默认监听 `0.0.0.0:5555`）\\n2. **Docker（环境变量注入）**：`docker compose -f docker-compose.env.yml up`\\n3. **Docker（卷挂载）**：`docker compose -f docker-compose.volume.yml up`\\n\\n---\\n\\n## 九、当前开发状态\\n\\n**已完成**：Chat/Responses API、流式输出、工具调用（原生+Bridge）、会话追踪（Hash/ZeroWidth）、并发门控、输出清洗、错误统计、账号/渠道管理、监控\\n\\n**待完成**：\\n- 真正的流式 Provider 回调（当前为 CollectorSink 伪流式）\\n- 更多 Provider 实现（当前仅 chaynsapi）\\n- 完善单元测试（目前仅有 5 个测试文件）\\n\\n---\\n\\n## 十、设计亮点总结\\n\\n1. **分层清晰**：HTTP → 适配 → 编排 → Provider → 输出，职责分离\\n2. **统一请求/事件模型**：`GenerationRequest` + `GenerationEvent` 解耦协议差异\\n3. **策略模式的 Sink 体系**：Session 层不感知输出协议\\n4. **Tool Bridge 机制**：让不支持 tool calls 的上游也能使用工具调用\\n5. **两阶段会话转移**：保证会话 ID 嵌入和转移的原子性\\n6. **RAII 并发门控**：`ExecutionGuard` 自动管理生命周期，防止资源泄漏\\n7. **渐进式迁移**：`ProviderResult::fromLegacyResponse()` 兼容旧接口\"}"}}]},{"role":"tool","tool_call_id":"call_e9d191c419e173793808c07c","content":"The user has provided feedback on the results. Consider their input to continue the task, and then attempt completion again.\n<feedback>\n详细分析，还有什么优化改进的地方\n</feedback>\n<environment_details>\n# VSCode Visible Files\naiapi/src/build/logs/aiapi.log\n\n# VSCode Open Tabs\naiapi/src/build/logs/aiapi.log,aiapi/src/sessionManager/GenerationService.cpp,aiapi/src/build/logs/1.txt,aiapi/src/sessionManager/XmlTagToolCallCodec.cpp,aiapi/src/sessionManager/XmlTagToolCallCodec.h,aiapi/src/apipoint/chaynsapi/chaynsapi.cpp,aiapi/src/apipoint/chaynsapi/chaynsapi.h,aiapi/doc/aiapi_callflow_and_api_examples.md,aiapi/README.md,aiapi/src/controllers/AiApi.cc,aiapi/src/accountManager/accountManager.h,aiapi/src/accountManager/accountManager.cpp,aiapi_web/src/components/LogViewer.tsx,aiapi_web/src/components/LogViewer.css,aiapi_web/src/App.tsx,aiapi_web/src/components/AccountManager.tsx,aiapi_web/src/components/AccountManager.css,aiapi/src/controllers/AiApi.h,aiapi/src/main.cc,aiapi/src/config.json\n\n# Current Time\nCurrent time in ISO 8601 UTC format: 2026-02-07T15:07:41.781Z\nUser time zone: America/Los_Angeles, UTC-8:00\n\n# Current Cost\n$0.00\n\n# Current Mode\n<slug>architect</slug>\n<name>Architect</name>\n<model>Claude Opus 4.6</model>\n<tool_format>native</tool_format>\nYou have not created a todo list yet. Create one with `update_todo_list` if your task is complicated or involves multiple steps.\n</environment_details>"},{"role":"assistant","content":"⁠⁠‌﻿‍‍‌﻿‌﻿‌‌﻿﻿​﻿​‌​﻿‌﻿​﻿‌﻿​﻿​​​﻿‌​​﻿‌﻿​﻿‌‍​﻿‍​​﻿‌‍​﻿‍‌​﻿​‍​﻿‌​​﻿​‍‌‌﻿﻿​﻿‌‍​﻿‍​​﻿‌‌​﻿‍​⁠⁠","tool_calls":[{"id":"call_61f9efd7c96e776aa29717bc","type":"function","function":{"name":"read_file","arguments":"{\"files\":[{\"path\":\"aiapi/src/sessionManager/GenerationService.cpp\"},{\"path\":\"aiapi/src/controllers/AiApi.cc\"},{\"path\":\"aiapi/src/apipoint/chaynsapi/chaynsapi.h\"}]}"}}]},{"role":"tool","tool_call_id":"call_61f9efd7c96e776aa29717bc","content":"File: aiapi/src/sessionManager/GenerationService.cpp\nLines 1-2109:\n   1 | #include \"GenerationService.h\"\n   2 | #include \"ClientOutputSanitizer.h\"\n   3 | #include \"ContinuityResolver.h\"\n   4 | #include \"ResponseIndex.h\"\n   5 | #include \"ToolCallBridge.h\"\n   6 | #include \"ToolCallValidator.h\"\n   7 | #include \"XmlTagToolCallCodec.h\"\n   8 | #include <apiManager/ApiManager.h>\n   9 | #include <apipoint/ProviderResult.h>\n  10 | #include <tools/ZeroWidthEncoder.h>\n  11 | #include <dbManager/channel/channelDbManager.h>\n  12 | #include <metrics/ErrorStatsService.h>\n  13 | #include <metrics/ErrorEvent.h>\n  14 | #include <drogon/drogon.h>\n  15 | #include <iomanip>\n  16 | #include <random>\n  17 | #include <sstream>\n  18 | #include <unordered_set>\n  19 | \n  20 | using namespace drogon;\n  21 | using namespace provider;\n  22 | using namespace session;\n  23 | using namespace error;\n  24 | \n  25 | // ========== 共享 helper 实现 ==========\n  26 | \n  27 | namespace {\n  28 | \n  29 | // ========== 通用辅助函数 ==========\n  30 | \n  31 | std::string trimWhitespace(std::string s) {\n  32 |     const auto start = s.find_first_not_of(\" \\t\\n\\r\");\n  33 |     if (start == std::string::npos) return \"\";\n  34 |     const auto end = s.find_last_not_of(\" \\t\\n\\r\");\n  35 |     return s.substr(start, end - start + 1);\n  36 | }\n  37 | \n  38 | std::string stripMarkdownCodeFence(std::string s) {\n  39 |     s = trimWhitespace(std::move(s));\n  40 |     if (s.rfind(\"```\", 0) != 0) return s;\n  41 |     size_t firstNl = s.find('\\n');\n  42 |     if (firstNl == std::string::npos) return s;\n  43 |     size_t lastFence = s.rfind(\"```\");\n  44 |     if (lastFence == std::string::npos || lastFence <= firstNl) return s;\n  45 |     return trimWhitespace(s.substr(firstNl + 1, lastFence - (firstNl + 1)));\n  46 | }\n  47 | \n  48 | \n  49 | // Normalize whitespace that may break the XML tool-call bridge parser.\n  50 | // - NBSP (U+00A0) encoded as UTF-8: 0xC2 0xA0\n  51 | // - IDEOGRAPHIC SPACE (U+3000) encoded as UTF-8: 0xE3 0x80 0x80\n  52 | static void replaceAllBytes(std::string& s, const std::string& from, const std::string& to) {\n  53 |         if (from.empty()) return;\n  54 |         size_t pos = 0;\n  55 |         while ((pos = s.find(from, pos)) != std::string::npos) {\n  56 |             s.replace(pos, from.size(), to);\n  57 |             pos += to.size();\n  58 |         }\n  59 |     }\n  60 |     std::string normalizeBridgeXml(std::string s) {\n  61 |         // Normalize line endings\n  62 |         replaceAllBytes(s, \"\\r\\n\", \"\\n\");\n  63 |         replaceAllBytes(s, \"\\r\", \"\\n\");\n  64 |     \n  65 |         // Normalize non-ASCII spaces that some UIs/models output (or templates accidentally contain)\n  66 |         replaceAllBytes(s, \"\\xC2\\xA0\", \" \");       // NBSP\n  67 |         replaceAllBytes(s, \"\\xE3\\x80\\x80\", \" \");   // U+3000\n  68 |     \n  69 |         return s;\n  70 | }\n  71 |     \n  72 | \n  73 | // (removed) JSON tool-call parsing helper (bridge output is XML-only now)\n  74 | \n  75 | std::string toLowerStr(std::string s) {\n  76 |     for (auto& c : s) c = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));\n  77 |     return s;\n  78 | }\n  79 | \n  80 | // 安全地将 Json::Value 转换为字符串，处理非字符串类型\n  81 | std::string safeJsonAsString(const Json::Value& val, const std::string& defaultVal = \"\") {\n  82 |     if (val.isString()) {\n  83 |         return val.asString();\n  84 |     }\n  85 |     if (val.isNull()) {\n  86 |         return defaultVal;\n  87 |     }\n  88 |     // 对于其他类型（对象、数组、数字等），序列化为 JSON 字符串\n  89 |     Json::StreamWriterBuilder writer;\n  90 |     writer[\"indentation\"] = \"\";\n  91 |     return Json::writeString(writer, val);\n  92 | }\n  93 | \n  94 | std::string_view ltrimView(const std::string& s) {\n  95 |     size_t i = 0;\n  96 |     while (i < s.size() && std::isspace(static_cast<unsigned char>(s[i]))) i++;\n  97 |     return std::string_view(s).substr(i);\n  98 | }\n  99 | \n 100 | bool startsWithStr(std::string_view s, std::string_view prefix) {\n 101 |     return s.size() >= prefix.size() && s.substr(0, prefix.size()) == prefix;\n 102 | }\n 103 | \n 104 | size_t findFunctionCallsPos(std::string_view s) {\n 105 |     size_t p1 = s.find(\"<function_calls\");\n 106 |     size_t p2 = s.find(\"<antml:function_calls\");\n 107 |     if (p1 == std::string_view::npos) return p2;\n 108 |     if (p2 == std::string_view::npos) return p1;\n 109 |     return (p1 < p2) ? p1 : p2;\n 110 | }\n 111 | /*\n 112 | std::string extractXmlInputForToolCalls(const session_st& session, const std::string& rawText) {\n 113 |     // Avoid false positives:\n 114 |     // Some model outputs include <function_calls> blocks as examples inside normal text.\n 115 |     // Prefer parsing the Toolify-style trigger marker (<Function_..._Start/>) when present.\n 116 |     // Otherwise, only parse when the response *starts* with a tool marker.\n 117 |     std::string xmlCandidate = stripMarkdownCodeFence(rawText);\n 118 |     const std::string_view trimmed = ltrimView(xmlCandidate);\n 119 | \n 120 |     std::string xmlInput;\n 121 | \n 122 |     if (!session.tool_bridge_trigger.empty()) {\n 123 |         // Only parse tool calls belonging to this request when the trigger matches.\n 124 |         // However, upstream UIs/models occasionally echo an older trigger marker. If the\n 125 |         // response starts with a tool marker, still parse it to avoid dropping valid calls.\n 126 |         size_t triggerPos = xmlCandidate.rfind(session.tool_bridge_trigger);\n 127 |         if (triggerPos != std::string::npos) {\n 128 |             xmlInput = xmlCandidate.substr(triggerPos);\n 129 | \n 130 |             // Strip the Toolify trigger marker (<Function_..._Start/>) so the XML codec\n 131 |             // doesn't emit it as normal text before <function_calls>.\n 132 |             const std::string_view t2 = ltrimView(xmlInput);\n 133 |             if (startsWithStr(t2, \"<Function_\")) {\n 134 |                 size_t fcPos = findFunctionCallsPos(t2);\n 135 |                 if (fcPos != std::string_view::npos && fcPos <= 512) {\n 136 |                     xmlInput = std::string(t2.substr(fcPos));\n 137 |                 }\n 138 |             }\n 139 |         } else {\n 140 |             const bool startsLikeToolCall =\n 141 |                 startsWithStr(trimmed, \"<function_calls\") ||\n 142 |                 startsWithStr(trimmed, \"<antml:function_calls\") ||\n 143 |                 startsWithStr(trimmed, \"<Function_\");\n 144 |             if (startsLikeToolCall) {\n 145 |                 if (startsWithStr(trimmed, \"<Function_\")) {\n 146 |                     // Require a real <function_calls> tag very early to reduce false positives.\n 147 |                     size_t fcPos = findFunctionCallsPos(trimmed);\n 148 |                     if (fcPos != std::string_view::npos && fcPos <= 512) {\n 149 |                         // Strip the trigger marker line, keep only the <function_calls> XML.\n 150 |                         xmlInput = std::string(trimmed.substr(fcPos));\n 151 |                         LOG_WARN << \"[GenerationService] tool_bridge_trigger 不匹配，已从响应开头解析 tool call\";\n 152 |                     }\n 153 |                 } else {\n 154 |                     xmlInput = std::string(trimmed);\n 155 |                     LOG_WARN << \"[GenerationService] tool_bridge_trigger 缺失，已从响应开头解析 tool call\";\n 156 |                 }\n 157 |             }\n 158 |         }\n 159 |     } else {\n 160 |         // Legacy fixed trigger fallback (backwards compatible).\n 161 |         size_t triggerPos = xmlCandidate.rfind(\"<Function_o2gx_Start/>\");\n 162 |         if (triggerPos != std::string::npos) {\n 163 |             xmlInput = xmlCandidate.substr(triggerPos);\n 164 | \n 165 |             // Same as above: avoid leaking the trigger marker as normal text.\n 166 |             const std::string_view t2 = ltrimView(xmlInput);\n 167 |             if (startsWithStr(t2, \"<Function_\")) {\n 168 |                 size_t fcPos = findFunctionCallsPos(t2);\n 169 |                 if (fcPos != std::string_view::npos && fcPos <= 512) {\n 170 |                     xmlInput = std::string(t2.substr(fcPos));\n 171 |                 }\n 172 |             }\n 173 |         } else {\n 174 |             const bool looksLikeToolCall =\n 175 |                 startsWithStr(trimmed, \"<function_calls\") ||\n 176 |                 startsWithStr(trimmed, \"<antml:function_calls\") ||\n 177 |                 startsWithStr(trimmed, \"<Function_\");\n 178 |             if (looksLikeToolCall) {\n 179 |                 if (startsWithStr(trimmed, \"<Function_\")) {\n 180 |                     // Strip the trigger marker and parse only the XML.\n 181 |                     size_t fcPos = findFunctionCallsPos(trimmed);\n 182 |                     if (fcPos != std::string_view::npos && fcPos <= 512) {\n 183 |                         xmlInput = std::string(trimmed.substr(fcPos));\n 184 |                     }\n 185 |                 } else {\n 186 |                     xmlInput = std::string(trimmed);\n 187 |                 }\n 188 |             }\n 189 |         }\n 190 |     }\n 191 | \n 192 |     return xmlInput;\n 193 | }\n 194 | */\n 195 | // GenerationService.cpp 中的 helper 函数\n 196 | \n 197 | std::string extractXmlInputForToolCalls(const session_st& session, const std::string& rawText) {\n 198 |     std::string xmlCandidate = stripMarkdownCodeFence(rawText);\n 199 |     const std::string_view trimmed = ltrimView(xmlCandidate);\n 200 | \n 201 |     // 1. 如果有随机 Trigger，优先使用它定位\n 202 |     if (!session.tool_bridge_trigger.empty()) {\n 203 |         size_t triggerPos = trimmed.find(session.tool_bridge_trigger);\n 204 |         if (triggerPos != std::string::npos) {\n 205 |             // [关键修改] 直接返回包含 Trigger 的子串，不要在后面把 Trigger 切掉！\n 206 |             // 这样 Codec 才能读到 \"<Function_.../>\" 并进行匹配\n 207 |             return std::string(trimmed.substr(triggerPos));\n 208 |         }\n 209 |     }\n 210 | \n 211 |     // 2. 兜底逻辑：如果找不到 Trigger，尝试直接找 <function_calls>\n 212 |     // 这种情况下，返回的字符串不含 Sentinel，Codec 的 setSentinel 应该传入空，或者 Codec 发现不匹配时回退\n 213 |     size_t tagPos = trimmed.find(\"<function_calls\"); // 简略匹配\n 214 |     if (tagPos == std::string::npos) tagPos = trimmed.find(\"<antml:function_calls\");\n 215 |     \n 216 |     if (tagPos != std::string::npos) {\n 217 |         return std::string(trimmed.substr(tagPos));\n 218 |     }\n 219 | \n 220 |     return \"\";\n 221 | }\n 222 | std::string generateFallbackToolCallId() {\n 223 |     // Keep the same \"call_xxx\" style as common tool call ids\n 224 |     std::ostringstream oss;\n 225 |     oss << \"call_\" << std::hex << std::setfill('0');\n 226 | \n 227 |     std::random_device rd;\n 228 |     std::mt19937 gen(rd());\n 229 |     std::uniform_int_distribution<> dis(0, 255);\n 230 | \n 231 |     for (int i = 0; i < 12; ++i) {\n 232 |         oss << std::setw(2) << dis(gen);\n 233 |     }\n 234 | \n 235 |     return oss.str();\n 236 | }\n 237 | \n 238 | std::string generateRandomTriggerSignal() {\n 239 |     // Toolify-style random trigger, e.g. <Function_AB1c_Start/>\n 240 |     static const std::string kChars =\n 241 |         \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n 242 | \n 243 |     std::random_device rd;\n 244 |     std::mt19937 gen(rd());\n 245 |     std::uniform_int_distribution<> dis(0, static_cast<int>(kChars.size() - 1));\n 246 | \n 247 |     std::string randomStr;\n 248 |     randomStr.reserve(4);\n 249 |     for (int i = 0; i < 4; ++i) {\n 250 |         randomStr.push_back(kChars[dis(gen)]);\n 251 |     }\n 252 | \n 253 |     return \"<Function_\" + randomStr + \"_Start/>\";\n 254 | }\n 255 | \n 256 | // ========== 错误统计辅助函数 ==========\n 257 | \n 258 | /**\n 259 |  * @brief 从 session 中提取客户端类型\n 260 |  */\n 261 | std::string getClientTypeFromSession(const session_st& session) {\n 262 |     return safeJsonAsString(session.client_info.get(\"client_type\", \"\"), \"\");\n 263 | }\n 264 | \n 265 | /**\n 266 |  * @brief 获取 API 类型字符串\n 267 |  */\n 268 | std::string getApiKindFromSession(const session_st& session) {\n 269 |     return session.isResponseApi() ? \"responses\" : \"chat_completions\";\n 270 | }\n 271 | \n 272 | /**\n 273 |  * @brief 记录错误事件到统计服务\n 274 |  */\n 275 | void recordErrorStat(\n 276 |     const session_st& session,\n 277 |     metrics::Domain domain,\n 278 |     const std::string& type,\n 279 |     const std::string& message,\n 280 |     int httpStatus = 0,\n 281 |     const Json::Value& detail = Json::Value(),\n 282 |     const std::string& rawSnippet = \"\",\n 283 |     const std::string& toolName = \"\"\n 284 | ) {\n 285 |     metrics::ErrorStatsService::getInstance().recordError(\n 286 |         domain,\n 287 |         type,\n 288 |         message,\n 289 |         session.request_id,\n 290 |         session.selectapi,\n 291 |         session.selectmodel,\n 292 |         getClientTypeFromSession(session),\n 293 |         getApiKindFromSession(session),\n 294 |         false,  // stream - 暂时设为 false\n 295 |         httpStatus,\n 296 |         detail,\n 297 |         rawSnippet,\n 298 |         toolName\n 299 |     );\n 300 | }\n 301 | \n 302 | /**\n 303 |  * @brief 记录警告事件到统计服务\n 304 |  */\n 305 | void recordWarnStat(\n 306 |     const session_st& session,\n 307 |     metrics::Domain domain,\n 308 |     const std::string& type,\n 309 |     const std::string& message,\n 310 |     const Json::Value& detail = Json::Value(),\n 311 |     const std::string& rawSnippet = \"\",\n 312 |     const std::string& toolName = \"\"\n 313 | ) {\n 314 |     metrics::ErrorStatsService::getInstance().recordWarn(\n 315 |         domain,\n 316 |         type,\n 317 |         message,\n 318 |         session.request_id,\n 319 |         session.selectapi,\n 320 |         session.selectmodel,\n 321 |         getClientTypeFromSession(session),\n 322 |         getApiKindFromSession(session),\n 323 |         false,  // stream\n 324 |         0,      // httpStatus\n 325 |         detail,\n 326 |         rawSnippet,\n 327 |         toolName\n 328 |     );\n 329 | }\n 330 | \n 331 | /**\n 332 |  * @brief 记录请求完成事件\n 333 |  */\n 334 | void recordRequestCompletedStat(const session_st& session, int httpStatus) {\n 335 |     metrics::RequestCompletedData data;\n 336 |     data.provider = session.selectapi;\n 337 |     data.model = session.selectmodel;\n 338 |     data.clientType = getClientTypeFromSession(session);\n 339 |     data.apiKind = getApiKindFromSession(session);\n 340 |     data.stream = false;  // 暂时设为 false\n 341 |     data.httpStatus = httpStatus;\n 342 |     data.ts = std::chrono::system_clock::now();\n 343 |     \n 344 |     metrics::ErrorStatsService::getInstance().recordRequestCompleted(data);\n 345 | }\n 346 | \n 347 | } // namespace\n 348 | \n 349 | std::string GenerationService::computeExecutionKey(const session_st& session) {\n 350 |     // 门控 key 统一使用 sessionId（session.curConversationId）\n 351 |     return session.curConversationId;\n 352 | }\n 353 | \n 354 | session_st GenerationService::materializeSession(const GenerationRequest& req) {\n 355 |     LOG_INFO << \"[生成服务] 物化 GenerationRequest -> session_st\";\n 356 |     \n 357 |     session_st session;\n 358 |     \n 359 |     // 基本参数映射\n 360 |     session.selectmodel = req.model;\n 361 |     session.selectapi = req.provider.empty() ? \"chaynsapi\" : req.provider;\n 362 |     session.systemprompt = req.systemPrompt;\n 363 |     session.client_info = req.clientInfo;\n 364 |     session.requestmessage = req.currentInput;\n 365 |     session.requestImages = req.images;  // 传递图片列表\n 366 |     session.tools = req.tools;           // 传递工具定义\n 367 |     session.tools_raw = req.tools;       // 保留原始工具定义（用于 tool bridge 兜底）\n 368 |     session.toolChoice = req.toolChoice; // 传递工具选择策略\n 369 |     session.requestmessage_raw = req.currentInput; // 保留原始输入（tool bridge 注入前）\n 370 |     session.last_active_time = time(nullptr);\n 371 |     session.created_time = time(nullptr);\n 372 |     \n 373 |     // 协议相关 - 使用新的 ApiType 枚举\n 374 |     session.apiType = req.isResponseApi() ? ApiType::Responses : ApiType::ChatCompletions;\n 375 |     session.has_previous_response_id = req.previousResponseId.has_value() &&\n 376 |                                       !req.previousResponseId->empty();\n 377 |     // prev_provider_key / curConversationId 由会话连续性决策器与 SessionStore 在后续阶段赋值\n 378 |     \n 379 |     \n 380 |     // 转换消息上下文（从强类型 Message 转换为 Json::Value）\n 381 |     for (const auto& msg : req.messages) {\n 382 |         Json::Value jsonMsg;\n 383 |         switch (msg.role) {\n 384 |             case MessageRole::User:\n 385 |                 jsonMsg[\"role\"] = \"user\";\n 386 |                 break;\n 387 |             case MessageRole::Assistant:\n 388 |                 jsonMsg[\"role\"] = \"assistant\";\n 389 |                 break;\n 390 |             case MessageRole::System:\n 391 |                 jsonMsg[\"role\"] = \"system\";\n 392 |                 break;\n 393 |             case MessageRole::Tool:\n 394 |                 jsonMsg[\"role\"] = \"tool\";\n 395 |                 break;\n 396 |         }\n 397 |         jsonMsg[\"content\"] = msg.getTextContent();\n 398 |         session.addMessageToContext(jsonMsg);\n 399 |     }\n 400 |     \n 401 |     LOG_INFO << \"[生成服务] 物化完成, model: \" << session.selectmodel\n 402 |              << \", apiType: \" << (session.isResponseApi() ? \"Responses\" : \"ChatCompletions\")\n 403 |              << \", message_context size: \" << session.message_context.size();\n 404 |     \n 405 |     return session;\n 406 | }\n 407 | \n 408 | std::optional<AppError> GenerationService::executeGuardedWithSession(\n 409 |     session_st& session,\n 410 |     IResponseSink& sink,\n 411 |     bool stream,\n 412 |     ConcurrencyPolicy policy\n 413 | ) {\n 414 |     // 计算执行 key\n 415 |     std::string sessionKey = computeExecutionKey(session);\n 416 |     LOG_INFO << \"[生成服务] 执行门控, 会话密钥: \" << sessionKey\n 417 |              << \", 策略: \" << (policy == ConcurrencyPolicy::RejectConcurrent ? \"拒绝并发\" : \"取消前一个\");\n 418 |     \n 419 |     // 使用 RAII 执行守卫\n 420 |     ExecutionGuard guard(sessionKey, policy);\n 421 |     \n 422 |     if (!guard.isAcquired()) {\n 423 |         GateResult result = guard.getResult();\n 424 |         if (result == GateResult::Rejected) {\n 425 |             LOG_WARN << \"[生成服务] 因并发执行被拒绝, 会话密钥: \" << sessionKey;\n 426 |             // 记录 SESSION_GATE 错误统计\n 427 |             recordErrorStat(\n 428 |                 session,\n 429 |                 metrics::Domain::SESSION_GATE,\n 430 |                 metrics::EventType::SESSIONGATE_REJECTED_CONFLICT,\n 431 |                 \"Request rejected due to concurrent execution\",\n 432 |                 409  // HTTP 409 Conflict\n 433 |             );\n 434 |             return AppError::conflict(\"Another request is already in progress for this session\");\n 435 |         }\n 436 |         // 其他情况理论上不应该发生\n 437 |         LOG_ERROR << \"[生成服务] 意外的门控结果: \" << static_cast<int>(result);\n 438 |         return AppError::internal(\"Failed to acquire execution gate\");\n 439 |     }\n 440 |     \n 441 |     LOG_INFO << \"[生成服务] 已获取执行门控, 会话: \" << sessionKey;\n 442 |     \n 443 | \t    try {\n 444 | \t        auto& sessionManager = *chatSession::getInstance();\n 445 | \t        // Per-request field: only valid for the current upstream call.\n 446 | \t        session.tool_bridge_trigger.clear();\n 447 | \t        \n 448 | \t        // 0. 检查通道是否支持 tool calls，如果不支持则注入工具定义到 systemprompt 和 requestmessage\n 449 | \t        bool supportsToolCalls = getChannelSupportsToolCalls(session.selectapi);\n 450 | \t        LOG_INFO<<\" supportsToolCalls\"<<supportsToolCalls<<\" session.tools.isNull()\"<<session.tools.isNull()<<\"session.tools.isArray()\"<<session.tools.isArray()<<\"session.tools.size()\"<<session.tools.size();\n 451 | \t        const Json::Value& toolsForBridge =\n 452 | \t            (!session.tools.isNull() && session.tools.isArray() && session.tools.size() > 0)\n 453 | \t                ? session.tools\n 454 | \t                : session.tools_raw;\n 455 | \t        auto normalizeLower = [](std::string s) {\n 456 | \t            for (auto& c : s) c = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));\n 457 | \t            return s;\n 458 | \t        };\n 459 | \t        const bool toolChoiceNone = (normalizeLower(session.toolChoice) == \"none\");\n 460 | \t        if (!supportsToolCalls && !toolChoiceNone && !toolsForBridge.isNull() && toolsForBridge.isArray() && toolsForBridge.size() > 0) {\n 461 | \t            LOG_INFO << \"[生成服务] 通道不支持 tool calls，注入工具定义到 systemprompt 和 requestmessage\";\n 462 | \t            if (session.tools.isNull() || !session.tools.isArray() || session.tools.size() == 0) {\n 463 | \t                session.tools = toolsForBridge;\n 464 | \t            }\n 465 | \t            transformRequestForToolBridge(session);\n 466 | \t        }\n 467 |         \n 468 |         // 1. Responses API: 生成 responseId 并尽早绑定到 ResponseIndex（用于 previous_response_id 续接）\n 469 |         if (session.isResponseApi() && session.response_id.empty()) {\n 470 |             session.response_id = chatSession::generateResponseId();\n 471 |         }\n 472 |         if (session.isResponseApi() && !session.response_id.empty()) {\n 473 |             ResponseIndex::instance().bind(session.response_id, session.curConversationId);\n 474 |         }\n 475 | \n 476 |         // 2. 发送 Started 事件（Responses: response.id；Chat: sessionId（仅日志用途））\n 477 |         generation::Started startEvent;\n 478 |         startEvent.responseId = session.isResponseApi() ? session.response_id : session.curConversationId;\n 479 |         startEvent.model = session.selectmodel;\n 480 |         sink.onEvent(startEvent);\n 481 |         \n 482 |         // 2. 检查取消状态\n 483 |         if (guard.isCancelled()) {\n 484 |             LOG_INFO << \"[生成服务] 调用提供者前请求被取消\";\n 485 |             // 记录 SESSION_GATE 取消统计\n 486 |             recordWarnStat(\n 487 |                 session,\n 488 |                 metrics::Domain::SESSION_GATE,\n 489 |                 metrics::EventType::SESSIONGATE_CANCELLED,\n 490 |                 \"Request cancelled before provider call\"\n 491 |             );\n 492 |             emitError(generation::ErrorCode::Cancelled, \"Request cancelled\", sink);\n 493 |             sink.onClose();\n 494 |             return AppError::cancelled(\"Request was cancelled\");\n 495 |         }\n 496 |         \n 497 |         // 3. 调用 Provider\n 498 |         if (!executeProvider(session)) {\n 499 |             // 记录 UPSTREAM 错误统计（Provider 错误）\n 500 |             int httpStatus = session.responsemessage.get(\"statusCode\", 0).asInt();\n 501 |             std::string errorMsg = safeJsonAsString(session.responsemessage.get(\"error\", \"Provider error\"), \"Provider error\");\n 502 |             recordErrorStat(\n 503 |                 session,\n 504 |                 metrics::Domain::UPSTREAM,\n 505 |                 metrics::EventType::UPSTREAM_HTTP_ERROR,\n 506 |                 errorMsg,\n 507 |                 httpStatus\n 508 |             );\n 509 |             emitError(\n 510 |                 generation::ErrorCode::ProviderError,\n 511 |                 errorMsg,\n 512 |                 sink\n 513 |             );\n 514 |             sink.onClose();\n 515 |             // 记录请求完成（失败）\n 516 |             recordRequestCompletedStat(session, httpStatus);\n 517 |             return std::nullopt;  // Provider 错误已通过 sink 发送\n 518 |         }\n 519 |         \n 520 |         // 4. 检查取消状态\n 521 |         if (guard.isCancelled()) {\n 522 |             LOG_INFO << \"[生成服务] 调用提供者后请求被取消\";\n 523 |             // 记录 SESSION_GATE 取消统计\n 524 |             recordWarnStat(\n 525 |                 session,\n 526 |                 metrics::Domain::SESSION_GATE,\n 527 |                 metrics::EventType::SESSIONGATE_CANCELLED,\n 528 |                 \"Request cancelled after provider call\"\n 529 |             );\n 530 |             emitError(generation::ErrorCode::Cancelled, \"Request cancelled\", sink);\n 531 |             sink.onClose();\n 532 |             return AppError::cancelled(\"Request was cancelled\");\n 533 |         }\n 534 |         \n 535 |         // 5. 预生成下一轮 sessionId（用于嵌入响应）\n 536 |         // 必须在 emitResultEvents 之前调用，这样嵌入的是新 ID\n 537 |         // ZeroWidth 和 Hash 模式都需要每轮生成新的 sessionId\n 538 |         sessionManager.prepareNextSessionId(session);\n 539 |         \n 540 |         // 6. 发送结果事件（会使用 session.nextSessionId 嵌入）\n 541 |         emitResultEvents(session, sink);\n 542 |         \n 543 |         // 7. 更新会话上下文 + 执行会话转移（Late commit）\n 544 |         // coverSessionresponse() 内部会检测 nextSessionId，如果存在则调用 commitSessionTransfer()\n 545 |         // 完成：更新 message_context → 转移会话到新 sessionId → 更新 session_map\n 546 |         if (session.isResponseApi() && !session.response_id.empty()) {\n 547 |             session.lastResponseId = session.response_id;\n 548 |         }\n 549 |         sessionManager.coverSessionresponse(session);\n 550 |         if (session.isResponseApi() && !session.response_id.empty()) {\n 551 |             // 会话转移后 curConversationId 已更新为 nextSessionId，重新绑定 responseId\n 552 |             ResponseIndex::instance().bind(session.response_id, session.curConversationId);\n 553 |         }\n 554 |         \n 555 |         // 8. 调用 Provider 后处理\n 556 |         auto api = ApiManager::getInstance().getApiByApiName(session.selectapi);\n 557 |         if (api) {\n 558 |             api->afterResponseProcess(session);\n 559 |         }\n 560 |         \n 561 |         // 9. 记录请求完成（成功）\n 562 |         recordRequestCompletedStat(session, 200);\n 563 |         \n 564 |     } catch (const std::exception& e) {\n 565 |         LOG_ERROR << \"[生成服务] 执行门控会话异常: \" << e.what();\n 566 |         // 记录 INTERNAL 异常统计\n 567 |         recordErrorStat(\n 568 |             session,\n 569 |             metrics::Domain::INTERNAL,\n 570 |             metrics::EventType::INTERNAL_EXCEPTION,\n 571 |             e.what(),\n 572 |             500\n 573 |         );\n 574 |         emitError(generation::ErrorCode::Internal, e.what(), sink);\n 575 |     } catch (...) {\n 576 |         LOG_ERROR << \"[生成服务] 执行门控会话未知异常\";\n 577 |         // 记录 INTERNAL 未知异常统计\n 578 |         recordErrorStat(\n 579 |             session,\n 580 |             metrics::Domain::INTERNAL,\n 581 |             metrics::EventType::INTERNAL_UNKNOWN,\n 582 |             \"Unknown error occurred\",\n 583 |             500\n 584 |         );\n 585 |         emitError(generation::ErrorCode::Internal, \"Unknown error occurred\", sink);\n 586 |     }\n 587 |     \n 588 |     sink.onClose();\n 589 |     return std::nullopt;  // ExecutionGuard 析构时自动释放\n 590 | }\n 591 | \n 592 | // ========== 新主入口实现 ==========\n 593 | \n 594 | std::optional<AppError> GenerationService::runGuarded(\n 595 |     const GenerationRequest& req,\n 596 |     IResponseSink& sink,\n 597 |     ConcurrencyPolicy policy\n 598 | ) {\n 599 |     LOG_INFO << \"[生成服务] runGuarded 新主入口, 协议: \"\n 600 |              << (req.isResponseApi() ? \"Responses\" : \"ChatCompletions\")\n 601 |              << \", 流式: \" << req.stream;\n 602 |     \n 603 |     // 1. materialize: GenerationRequest → session_st\n 604 |     session_st session = materializeSession(req);\n 605 |     \n 606 |     // 2. resolve sessionId + getOrCreate（必须发生在门控前）\n 607 |     auto& sessionManager = *chatSession::getInstance();\n 608 | \n 609 |     ContinuityResolver resolver;\n 610 |     const ContinuityDecision decision = resolver.resolve(req);\n 611 | \n 612 |     LOG_INFO << \"[生成服务] ContinuityDecision\"\n 613 |              << \" source=\" << static_cast<int>(decision.source)\n 614 |              << \" mode=\" << (decision.mode == SessionTrackingMode::ZeroWidth ? \"ZeroWidth\" : \"Hash\")\n 615 |              << \" sessionId=\" << decision.sessionId\n 616 |              << (decision.debug.empty() ? \"\" : (\" debug=\" + decision.debug));\n 617 | \n 618 |     sessionManager.getOrCreateSession(decision.sessionId, session);\n 619 | \n 620 |     LOG_INFO << \"[生成服务] 会话 \" << (session.is_continuation ? \"续接\" : \"新建\")\n 621 |              << \", sessionId: \" << session.curConversationId\n 622 |              << \", apiType: \" << (session.isResponseApi() ? \"Responses\" : \"ChatCompletions\");\n 623 |     \n 624 |     // 3. 调用共享 helper executeGuardedWithSession()\n 625 |     return executeGuardedWithSession(session, sink, req.stream, policy);\n 626 | }\n 627 | \n 628 | bool GenerationService::executeProvider(session_st& session) {\n 629 |     LOG_INFO << \"[生成服务] 执行提供者: \" << session.selectapi;\n 630 |     \n 631 |     auto api = ApiManager::getInstance().getApiByApiName(session.selectapi);\n 632 |     if (!api) {\n 633 |         LOG_ERROR << \"[生成服务] 未找到提供者: \" << session.selectapi;\n 634 |         session.responsemessage[\"error\"] = \"Provider not found: \" + session.selectapi;\n 635 |         return false;\n 636 |     }\n 637 |     \n 638 |     // 使用新的 generate() 接口获取结构化结果\n 639 |     ProviderResult result = api->generate(session);\n 640 |     \n 641 |     // 将结果写回 session.responsemessage 以保持向后兼容\n 642 |     session.responsemessage[\"message\"] = result.text;\n 643 |     session.responsemessage[\"statusCode\"] = result.statusCode;\n 644 |     \n 645 |     if (!result.isSuccess()) {\n 646 |         LOG_ERROR << \"[生成服务] 提供者返回错误, 状态码: \" << result.statusCode\n 647 |                   << \", 消息: \" << result.error.message;\n 648 |         session.responsemessage[\"error\"] = result.error.message;\n 649 |         return false;\n 650 |     }\n 651 |     \n 652 |     return true;\n 653 | }\n 654 | \n 655 | /**\n 656 |  * @brief 发送生成结果事件到客户端\n 657 |  *\n 658 |  * 这是响应处理的核心函数，负责将上游模型的原始输出转换为客户端可理解的事件流。\n 659 |  *\n 660 |  * 【处理流程概览】\n 661 |  * ┌─────────────────────────────────────────────────────────────────────────┐\n 662 |  * │  1. 文本清洗 (sanitizeOutput)                                           │\n 663 |  * │     ↓                                                                   │\n 664 |  * │  2. Tool Call 解析 (Bridge模式: extractXmlInputForToolCalls + parseXml) │\n 665 |  * │     ↓                                                                   │\n 666 |  * │  3. 参数形状规范化 (normalizeToolCallArguments)                          │\n 667 |  * │     ↓                                                                   │\n 668 |  * │  4. Schema校验 + 过滤无效调用 (ToolCallValidator)  ← 防止 missing nativeArgs │\n 669 |  * │     ↓                                                                   │\n 670 |  * │  5. 自愈逻辑 (selfHealReadFile) - 仅 Roo/Kilo                           │\n 671 |  * │     ↓                                                                   │\n 672 |  * │  6. 严格客户端规则 (applyStrictClientRules) - 仅 Roo/Kilo               │\n 673 |  * │     ↓                                                                   │\n 674 |  * │  7. 零宽字符会话ID嵌入                                                   │\n 675 |  * │     ↓                                                                   │\n 676 |  * │  8. 发送事件: ToolCallDone → OutputTextDone → Completed                 │\n 677 |  * └─────────────────────────────────────────────────────────────────────────┘\n 678 |  *\n 679 |  * @param session 会话状态，包含请求/响应数据、工具定义等\n 680 |  * @param sink 事件接收器，负责将事件序列化并发送给客户端\n 681 |  */\n 682 | void GenerationService::emitResultEvents(const session_st& session, IResponseSink& sink) {\n 683 |     // ==================== 步骤 0: 初始化 ====================\n 684 |     // 从 session.responsemessage 中提取上游模型返回的原始文本\n 685 |     std::string text = safeJsonAsString(session.responsemessage.get(\"message\", \"\"), \"\");\n 686 |     \n 687 |     // 获取客户端类型，用于后续的客户端特定处理\n 688 |     const std::string clientType = safeJsonAsString(session.client_info.get(\"client_type\", \"\"), \"\");\n 689 |     \n 690 |     // 判断是否为\"严格工具客户端\"（Roo/Kilo）\n 691 |     // 这类客户端要求：每次响应必须且只能包含 1 个 tool call\n 692 |     const bool strictToolClient = (clientType == \"Kilo-Code\" || clientType == \"RooCode\");\n 693 | \n 694 |     // ==================== 步骤 1: 文本清洗 ====================\n 695 |     // 调用 sanitizeOutput() 进行基础文本清洗：\n 696 |     // - 修复常见的 XML/HTML 标签错误\n 697 |     // - 移除不可见控制字符\n 698 |     // - 针对特定客户端的输出格式调整\n 699 |     text = sanitizeOutput(session.client_info, text);\n 700 | \n 701 |     // ==================== 步骤 2: Tool Call 解析 ====================\n 702 |     // 检查当前通道是否原生支持 tool calls\n 703 |     // 如果支持，上游会直接返回结构化的 tool_calls，无需从文本中解析\n 704 |     const bool supportsToolCalls = getChannelSupportsToolCalls(session.selectapi);\n 705 |     \n 706 |     // 检查 tool_choice 是否为 \"none\"（禁用工具调用）\n 707 |     const bool toolChoiceNone = (toLowerStr(session.toolChoice) == \"none\");\n 708 | \n 709 |     // 用于存储解析结果\n 710 |     std::string textContent;                              // 普通文本内容\n 711 |     std::vector<generation::ToolCallDone> toolCalls;      // 解析出的工具调用列表\n 712 | \n 713 |     // 【解析策略】\n 714 |     // - 通道原生支持 tool calls → 不从文本解析，直接使用原始文本\n 715 |     // - tool_choice=none → 禁用工具，全部当作普通文本\n 716 |     // - 其他情况（Bridge 模式）→ 从文本中解析 XML 格式的工具调用\n 717 |     if (supportsToolCalls || toolChoiceNone) {\n 718 |         // 通道支持原生 tool calls 或禁用工具：直接使用原始文本\n 719 |         textContent = text;\n 720 |     } else {\n 721 |         // ========== Bridge 模式：从文本中解析 XML 格式的工具调用 ==========\n 722 |         //\n 723 |         // 【为什么需要 Bridge 模式？】\n 724 |         // 某些上游通道（如部分 OpenAI 兼容 API）不支持原生 tool_calls，\n 725 |         // 我们通过在 prompt 中注入工具定义，让模型以 XML 格式输出工具调用，\n 726 |         // 然后在这里解析 XML 并转换为标准的 tool_calls 结构。\n 727 |         \n 728 |         // 步骤 2.1: 提取 XML 输入\n 729 |         // extractXmlInputForToolCalls() 会：\n 730 |         // - 优先查找本次请求的随机触发标记 (session.tool_bridge_trigger)\n 731 |         // - 如果找到触发标记，返回从触发标记开始的子串\n 732 |         // - 如果没找到，尝试查找 <function_calls> 标签作为兜底\n 733 |         std::string xmlInput = extractXmlInputForToolCalls(session, text);\n 734 | \n 735 |         if (xmlInput.empty()) {\n 736 |             // 没有找到工具调用 XML，全部当作普通文本\n 737 |             textContent = text;\n 738 |             // 记录 TOOL_BRIDGE 警告：未找到 XML 工具调用\n 739 |             if (!session.tools.isNull() && session.tools.isArray() && session.tools.size() > 0) {\n 740 |                 // 只有在有工具定义时才记录警告\n 741 |                 recordWarnStat(\n 742 |                     session,\n 743 |                     metrics::Domain::TOOL_BRIDGE,\n 744 |                     metrics::EventType::TOOLBRIDGE_XML_NOT_FOUND,\n 745 |                     \"No XML tool calls found in response\",\n 746 |                     Json::Value(),\n 747 |                     text.substr(0, std::min(text.size(), size_t(1024)))  // 截取前 1KB 作为原始片段\n 748 |                 );\n 749 |             }\n 750 |         } else {\n 751 |             // 步骤 2.2: 规范化 XML（处理特殊空格、换行符等）\n 752 |             xmlInput = normalizeBridgeXml(std::move(xmlInput));\n 753 |             \n 754 |             // 步骤 2.3: 确定是否使用 Sentinel 严格匹配\n 755 |             // 【Sentinel 机制说明】\n 756 |             // 每次请求会生成一个随机的触发标记（如 <Function_Ab1c_Start/>），\n 757 |             // 只有包含该标记的 XML 块才会被解析，避免误解析历史消息或示例中的 XML。\n 758 |             std::string expectedSentinel = \"\";\n 759 |             if (!session.tool_bridge_trigger.empty() &&\n 760 |                 xmlInput.find(session.tool_bridge_trigger) != std::string::npos) {\n 761 |                 // XML 中包含本次请求的触发标记，启用严格匹配\n 762 |                 expectedSentinel = session.tool_bridge_trigger;\n 763 |             }\n 764 |             \n 765 |             // 步骤 2.4: 解析 XML 工具调用\n 766 |             // parseXmlToolCalls() 会：\n 767 |             // - 使用 XmlTagToolCallCodec 解析 <function_calls>/<function_call> 结构\n 768 |             // - 提取 <tool> 和 <args_json> 内容\n 769 |             // - 将解析结果填充到 toolCalls 向量\n 770 |             // - 非工具调用的文本会填充到 textContent\n 771 |             parseXmlToolCalls(xmlInput, textContent, toolCalls, expectedSentinel);\n 772 |         }\n 773 | \n 774 |         // 步骤 2.5: 强制工具调用兜底\n 775 |         // 如果 tool_choice=required 但上游没有返回工具调用，\n 776 |         // 尝试根据用户输入自动生成一个工具调用\n 777 |         if (toolCalls.empty()) {\n 778 |             generateForcedToolCall(session, toolCalls, textContent);\n 779 |         }\n 780 |     }\n 781 | \n 782 |     // ==================== 步骤 3: 参数形状规范化 ====================\n 783 |     // normalizeToolCallArguments() 会：\n 784 |     // - 修复常见的参数格式问题（如 files:[\"path\"] → files:[{path:\"path\"}]）\n 785 |     // - 处理参数别名（如 paths → files）\n 786 |     // - 填充缺失的可选字段默认值\n 787 |     // - 规范化 ask_followup_question 的 mode 字段\n 788 |     normalizeToolCallArguments(session, toolCalls);\n 789 | \n 790 |     // ==================== 步骤 4: Schema 校验 + 过滤无效调用 ====================\n 791 |     // 【这是防止 \"missing nativeArgs\" 错误的关键步骤】\n 792 |     //\n 793 |     // 【问题背景】\n 794 |     // 当上游模型输出不完整的工具调用（如参数 JSON 截断、必填字段缺失）时，\n 795 |     // 客户端执行层会报错 \"Invalid tool call: missing nativeArgs\"。\n 796 |     //\n 797 |     // 【解决方案】\n 798 |     // 在发送给客户端之前，使用 ToolCallValidator 进行多层校验：\n 799 |     // - Stage A: 工具名存在性 + JSON 可解析 + required 字段 + 类型匹配\n 800 |     // - Stage B: 关键字段非空（path/diff/content 等）\n 801 |     // - Stage C: 校验失败后的降级策略（按客户端类型）\n 802 |     {\n 803 |         // 获取工具定义（优先使用 tools_raw，它保存了原始的客户端工具定义）\n 804 |         const Json::Value& toolDefs =\n 805 |             (!session.tools_raw.isNull() && session.tools_raw.isArray() && session.tools_raw.size() > 0)\n 806 |                 ? session.tools_raw\n 807 |                 : session.tools;\n 808 |         \n 809 |         // 只有在有工具调用且有工具定义时才进行校验\n 810 |         if (!toolCalls.empty() && toolDefs.isArray() && toolDefs.size() > 0) {\n 811 |             // 创建校验器，传入工具定义和客户端类型\n 812 |             // 客户端类型用于选择不同的关键字段集合：\n 813 |             // - RooCode/Kilo-Code: 使用完整的关键字段集合\n 814 |             // - 其他客户端: 使用最小关键字段集合\n 815 |             toolcall::ToolCallValidator validator(toolDefs, clientType);\n 816 |             \n 817 |             // 用于收集被丢弃的工具调用信息（供降级策略使用）\n 818 |             std::string discardedText;\n 819 |             \n 820 |             // 【校验模式选择】\n 821 |             // 根据客户端类型自动选择推荐的校验模式：\n 822 |             // - RooCode/Kilo-Code: Relaxed 模式（校验关键字段）\n 823 |             // - 其他客户端: None 模式（不校验，信任 AI 输出）\n 824 |             //\n 825 |             // 原因：\n 826 |             // 1. Roo/Kilo 客户端对工具调用格式要求严格，需要提前过滤明显错误\n 827 |             // 2. 其他客户端使用宽松策略，避免误报（如 mode 字段问题）\n 828 |             // 3. prompt 中已经明确告诉 AI 哪些参数是 required\n 829 |             toolcall::ValidationMode validationMode = toolcall::getRecommendedValidationMode(clientType);\n 830 |             \n 831 |             // 执行校验并过滤无效的工具调用\n 832 |             // filterInvalidToolCalls() 会：\n 833 |             // - 遍历所有工具调用，逐个校验\n 834 |             // - 移除不通过校验的工具调用\n 835 |             // - 返回被移除的数量\n 836 |             size_t removedCount = validator.filterInvalidToolCalls(toolCalls, discardedText, validationMode);\n 837 |             \n 838 |             if (removedCount > 0) {\n 839 |                 LOG_WARN << \"[GenerationService] 通过 Schema 校验过滤了 \" << removedCount\n 840 |                          << \" 个无效的工具调用\";\n 841 |                 \n 842 |                 // 记录 TOOL_BRIDGE 警告：校验过滤了无效的工具调用\n 843 |                 Json::Value filterDetail;\n 844 |                 filterDetail[\"removed_count\"] = static_cast<Json::UInt64>(removedCount);\n 845 |                 filterDetail[\"validation_mode\"] = static_cast<int>(validationMode);\n 846 |                 recordWarnStat(\n 847 |                     session,\n 848 |                     metrics::Domain::TOOL_BRIDGE,\n 849 |                     metrics::EventType::TOOLBRIDGE_VALIDATION_FILTERED,\n 850 |                     \"Filtered \" + std::to_string(removedCount) + \" invalid tool calls\",\n 851 |                     filterDetail,\n 852 |                     discardedText.substr(0, std::min(discardedText.size(), size_t(2048)))\n 853 |                 );\n 854 |                 \n 855 |                 // Stage C: 根据客户端类型应用降级策略\n 856 |                 // 如果所有工具调用都被过滤掉了，需要决定如何处理\n 857 |                 if (toolCalls.empty()) {\n 858 |                     // applyValidationFallback() 会：\n 859 |                     // - 非严格客户端：仅丢弃，保留文本输出\n 860 |                     // - 严格客户端（Roo/Kilo）：将文本包装为 attempt_completion\n 861 |                     toolcall::applyValidationFallback(clientType, toolCalls, textContent, discardedText);\n 862 |                     \n 863 |                     // 记录 TOOL_BRIDGE 警告：应用了降级策略\n 864 |                     recordWarnStat(\n 865 |                         session,\n 866 |                         metrics::Domain::TOOL_BRIDGE,\n 867 |                         metrics::EventType::TOOLBRIDGE_VALIDATION_FALLBACK_APPLIED,\n 868 |                         \"Applied validation fallback for client: \" + clientType\n 869 |                     );\n 870 |                 }\n 871 |             }\n 872 |         }\n 873 |     }\n 874 | \n 875 |     // ==================== 步骤 5: 严格客户端规则（仅 Roo/Kilo）====================\n 876 |     // 【规则说明】\n 877 |     // Roo/Kilo 客户端要求每次响应必须且只能包含 1 个工具调用。\n 878 |     //\n 879 |     // applyStrictClientRules() 会：\n 880 |     // - 如果没有工具调用但有文本 → 包装为 attempt_completion\n 881 |     // - 如果有多个工具调用 → 只保留第一个\n 882 |     // - 如果有工具调用 → 清空文本内容（避免重复输出）\n 883 |     if (strictToolClient) {\n 884 |         // 记录应用严格客户端规则前的状态\n 885 |         size_t toolCallsBeforeStrict = toolCalls.size();\n 886 |         bool hadTextBeforeStrict = !textContent.empty();\n 887 |         \n 888 |         applyStrictClientRules(clientType, textContent, toolCalls);\n 889 |         \n 890 |         // 如果规则导致了变化，记录统计\n 891 |         if (toolCallsBeforeStrict != toolCalls.size() ||\n 892 |             (hadTextBeforeStrict && textContent.empty() && !toolCalls.empty())) {\n 893 |             Json::Value strictDetail;\n 894 |             strictDetail[\"original_tool_calls\"] = static_cast<Json::UInt64>(toolCallsBeforeStrict);\n 895 |             strictDetail[\"final_tool_calls\"] = static_cast<Json::UInt64>(toolCalls.size());\n 896 |             strictDetail[\"text_cleared\"] = hadTextBeforeStrict && textContent.empty();\n 897 |             recordWarnStat(\n 898 |                 session,\n 899 |                 metrics::Domain::TOOL_BRIDGE,\n 900 |                 metrics::EventType::TOOLBRIDGE_STRICT_CLIENT_RULE_APPLIED,\n 901 |                 \"Applied strict client rules for: \" + clientType,\n 902 |                 strictDetail\n 903 |             );\n 904 |         }\n 905 |     }\n 906 | \n 907 |     // ==================== 步骤 7: 零宽字符会话ID嵌入 ====================\n 908 |     // 【功能说明】\n 909 |     // 使用零宽字符将会话ID嵌入到响应文本中，客户端下次请求时可以提取该ID实现续聊。\n 910 |     //\n 911 |     // 【两阶段设计】\n 912 |     // 1. prepareNextSessionId() 在 emitResultEvents 之前预生成 nextSessionId\n 913 |     // 2. 这里嵌入 nextSessionId（而非 curConversationId）\n 914 |     // 3. commitSessionTransfer() 在发送后执行实际的会话转移\n 915 |     //\n 916 |     // 【特殊处理】\n 917 |     // 对于 tool_calls 场景，部分客户端在收到 finish_reason=\"tool_calls\" 后\n 918 |     // 会停止处理后续内容，因此需要在 tool_calls 之前发送会话ID。\n 919 |     auto& sessionManager = *chatSession::getInstance();\n 920 | \n 921 |     // 优先使用预生成的 nextSessionId，如果没有则回退到 curConversationId\n 922 |     const std::string& sessionIdToEmbed =\n 923 |         !session.nextSessionId.empty() ? session.nextSessionId : session.curConversationId;\n 924 | \n 925 |     if (sessionManager.isZeroWidthMode() && !sessionIdToEmbed.empty()) {\n 926 |         const std::string clientType = safeJsonAsString(session.client_info.get(\"client_type\", \"\"), \"\");\n 927 |         if (!toolCalls.empty() && clientType == \"claudecode\") {\n 928 |             // Claude Code 客户端 + 有工具调用：单独发送零宽会话ID\n 929 |             std::string zwOnly = chatSession::embedSessionIdInText(\"\", sessionIdToEmbed);\n 930 |             if (!zwOnly.empty()) {\n 931 |                 generation::OutputTextDone zwDone;\n 932 |                 zwDone.text = zwOnly;\n 933 |                 zwDone.index = 0;\n 934 |                 sink.onEvent(zwDone);\n 935 |                 LOG_INFO << \"[生成服务] 已在 tool_calls 前发送零宽会话ID: \" << sessionIdToEmbed\n 936 |                          << \" (当前会话: \" << session.curConversationId << \")\";\n 937 |             }\n 938 |         } else {\n 939 |             // 其他情况：在文本末尾嵌入会话ID\n 940 |             textContent = chatSession::embedSessionIdInText(textContent, sessionIdToEmbed);\n 941 |             LOG_INFO << \"[生成服务] 已在响应中嵌入会话ID: \" << sessionIdToEmbed\n 942 |                      << \" (当前会话: \" << session.curConversationId << \")\";\n 943 |         }\n 944 |     }\n 945 | \n 946 |     // ==================== 步骤 8: 发送事件 ====================\n 947 |     // 【事件发送顺序】\n 948 |     // 1. ToolCallDone 事件（如果有工具调用）\n 949 |     // 2. OutputTextDone 事件（如果有文本内容）\n 950 |     // 3. Completed 事件（标记响应结束）\n 951 |     \n 952 |     // 发送所有工具调用事件\n 953 |     for (const auto& tc : toolCalls) {\n 954 |         sink.onEvent(tc);\n 955 |     }\n 956 | \n 957 |     // 发送文本内容事件（如果有）\n 958 |     if (!textContent.empty()) {\n 959 |         generation::OutputTextDone textDone;\n 960 |         textDone.text = textContent;\n 961 |         textDone.index = 0;\n 962 |         sink.onEvent(textDone);\n 963 |     }\n 964 | \n 965 |     // 发送完成事件\n 966 |     // finish_reason: \"stop\"（普通文本结束）或 \"tool_calls\"（工具调用结束）\n 967 |     generation::Completed completed;\n 968 |     completed.finishReason = toolCalls.empty() ? \"stop\" : \"tool_calls\";\n 969 |     sink.onEvent(completed);\n 970 | }\n 971 | \n 972 | void GenerationService::emitError(\n 973 |     generation::ErrorCode code,\n 974 |     const std::string& message,\n 975 |     IResponseSink& sink\n 976 | ) {\n 977 |     generation::Error error;\n 978 |     error.code = code;\n 979 |     error.message = message;\n 980 |     sink.onEvent(error);\n 981 | }\n 982 | \n 983 | std::string GenerationService::sanitizeOutput(\n 984 |     const Json::Value& clientInfo,\n 985 |     const std::string& text\n 986 | ) {\n 987 |     return ClientOutputSanitizer::sanitize(clientInfo, text);\n 988 | }\n 989 | \n 990 | bool GenerationService::getChannelSupportsToolCalls(const std::string& channelName) {\n 991 |     // 从数据库获取通道信息\n 992 |     auto channelManager = ChannelDbManager::getInstance();\n 993 |     Channelinfo_st channelInfo;\n 994 |     \n 995 |     if (channelManager->getChannel(channelName, channelInfo)) {\n 996 |         LOG_INFO << \"[GenerationService] 通道 \" << channelName\n 997 |                   << \" supportsToolCalls: \" << channelInfo.supportsToolCalls;\n 998 |         return channelInfo.supportsToolCalls;\n 999 |     }\n1000 |     \n1001 |     // 默认返回 true（保守策略，避免破坏现有行为）\n1002 |     LOG_WARN << \"[GenerationService] 未找到通道 \" << channelName << \"，默认支持 tool calls\";\n1003 |     return true;\n1004 | }\n1005 | \n1006 | // ========== emitResultEvents 辅助函数实现 ==========\n1007 | \n1008 | /**\n1009 |  * @brief 解析 XML 格式的工具调用\n1010 |  *\n1011 |  * 【功能说明】\n1012 |  * 从 XML 文本中解析出工具调用信息。这是 Bridge 模式的核心解析函数。\n1013 |  *\n1014 |  * 【XML 格式示例】\n1015 |  * <Function_Ab1c_Start/>          ← 触发标记（Sentinel）\n1016 |  * <function_calls>\n1017 |  *   <function_call>\n1018 |  *     <tool>read_file</tool>\n1019 |  *     <args_json><![CDATA[{\"path\":\"src/main.cpp\"}]]></args_json>\n1020 |  *   </function_call>\n1021 |  * </function_calls>\n1022 |  *\n1023 |  * 【Sentinel 机制】\n1024 |  * - 每次请求生成唯一的触发标记（如 <Function_Ab1c_Start/>）\n1025 |  * - 只有包含该标记的 XML 块才会被解析\n1026 |  * - 防止误解析历史消息或示例中的 XML\n1027 |  *\n1028 |  * @param xmlInput 待解析的 XML 文本\n1029 |  * @param outTextContent [输出] 非工具调用的普通文本\n1030 |  * @param outToolCalls [输出] 解析出的工具调用列表\n1031 |  * @param sentinel 期望的触发标记，为空则不做严格匹配\n1032 |  */\n1033 | void GenerationService::parseXmlToolCalls(\n1034 |     const std::string& xmlInput,\n1035 |     std::string& outTextContent,\n1036 |     std::vector<generation::ToolCallDone>& outToolCalls,\n1037 |     const std::string& sentinel\n1038 | ) {\n1039 |     LOG_INFO << \"[GenerationService] 解析 XML 格式 tool calls, sentinel: \" << (sentinel.empty() ? \"NONE\" : sentinel);\n1040 |     LOG_INFO << \"[ToolParse] xmlInput.size=\" << xmlInput.size()\n1041 |               << \" has </args_json>=\" << (xmlInput.find(\"</args_json>\") != std::string::npos)\n1042 |               << \" has </function_call>=\" << (xmlInput.find(\"</function_call>\") != std::string::npos)\n1043 |               << \" has </function_calls>=\" << (xmlInput.find(\"</function_calls>\") != std::string::npos);\n1044 | \n1045 |     // 创建 ToolCallBridge 和 XmlTagToolCallCodec\n1046 |     // - ToolCallBridge: 负责协调请求/响应的转换\n1047 |     // - XmlTagToolCallCodec: 负责 XML 格式的编解码\n1048 |     auto bridge = toolcall::createToolCallBridge(false);\n1049 |     auto codec = toolcall::createXmlTagToolCallCodec();\n1050 | \n1051 |     // 设置 Sentinel（触发标记）\n1052 |     // 如果设置了 Sentinel，Codec 只会解析包含该标记的 XML 块\n1053 |     if (!sentinel.empty()) {\n1054 |         codec->setSentinel(sentinel);\n1055 |     }\n1056 |     bridge->setTextCodec(codec);\n1057 | \n1058 |     // 执行解析\n1059 |     std::vector<toolcall::ToolCallEvent> events;\n1060 |     bridge->transformResponseChunk(xmlInput, events);  // 增量解析\n1061 |     bridge->flushResponse(events);                      // 刷新剩余内容\n1062 | \n1063 |     // 处理解析事件\n1064 |     for (const auto& event : events) {\n1065 |         switch (event.type) {\n1066 |             case toolcall::EventType::Text:\n1067 |                 // 普通文本事件：累积到 outTextContent\n1068 |                 outTextContent += event.text;\n1069 |                 break;\n1070 |                 \n1071 |             case toolcall::EventType::ToolCallEnd: {\n1072 |                 // 工具调用结束事件：创建 ToolCallDone 结构\n1073 |                 LOG_INFO << \"[GenerationService] 工具调用结束: \" << event.toolName;\n1074 |                 generation::ToolCallDone tc;\n1075 |                 tc.id = event.toolCallId;           // 工具调用 ID（如 call_xxx）\n1076 |                 tc.name = event.toolName;           // 工具名称（如 read_file）\n1077 |                 tc.arguments = event.argumentsDelta; // 参数 JSON 字符串\n1078 |                 tc.index = outToolCalls.size();     // 在列表中的索引\n1079 |                 outToolCalls.push_back(tc);\n1080 |                 break;\n1081 |             }\n1082 |             \n1083 |             case toolcall::EventType::ToolCallBegin:\n1084 |             case toolcall::EventType::ToolCallArgsDelta:\n1085 |                 // 这些是流式解析的中间状态，非流式场景下忽略\n1086 |                 break;\n1087 |                 \n1088 |             case toolcall::EventType::Error:\n1089 |                 // 解析错误：记录日志但不中断处理\n1090 |                 LOG_WARN << \"[GenerationService] 解析错误: \" << event.errorMessage\n1091 |                          << \" (xmlInput.size=\" << xmlInput.size() << \")\";\n1092 |                 {\n1093 |                     // 输出 XML 尾部用于调试\n1094 |                     const size_t kTail = 320;\n1095 |                     const std::string tail =\n1096 |                         xmlInput.size() > kTail ? xmlInput.substr(xmlInput.size() - kTail) : xmlInput;\n1097 |                     LOG_INFO << \"[GenerationService] xmlInput tail (truncated): \" << tail;\n1098 |                 }\n1099 |                 break;\n1100 |         }\n1101 |     }\n1102 | \n1103 |     // 【重要】如果解析出了工具调用，清空文本内容\n1104 |     // 避免触发标记、空白字符等被当作普通文本输出\n1105 |     if (!outToolCalls.empty()) {\n1106 |         outTextContent.clear();\n1107 |     }\n1108 | }\n1109 | \n1110 | void GenerationService::generateForcedToolCall(\n1111 |     const session_st& session,\n1112 |     std::vector<generation::ToolCallDone>& outToolCalls,\n1113 |     std::string& outTextContent\n1114 | ) {\n1115 |     std::string toolChoice = \"auto\";\n1116 |     std::string forcedToolName;\n1117 | \n1118 |     if (!session.toolChoice.empty()) {\n1119 |         if (session.toolChoice.front() == '{') {\n1120 |             Json::Value tc;\n1121 |             Json::CharReaderBuilder builder;\n1122 |             std::string errors;\n1123 |             std::istringstream iss(session.toolChoice);\n1124 |             if (Json::parseFromStream(builder, iss, &tc, &errors) && tc.isObject()) {\n1125 |                 if (tc.get(\"type\", \"\").asString() == \"function\" && tc.isMember(\"function\") && tc[\"function\"].isObject()) {\n1126 |                     forcedToolName = tc[\"function\"].get(\"name\", \"\").asString();\n1127 |                     if (!forcedToolName.empty()) {\n1128 |                         toolChoice = \"required\";\n1129 |                     }\n1130 |                 }\n1131 |             }\n1132 |         } else {\n1133 |             toolChoice = toLowerStr(session.toolChoice);\n1134 |         }\n1135 |     }\n1136 | \n1137 |     const bool mustCallTool = (toolChoice == \"required\") || !forcedToolName.empty();\n1138 |     const Json::Value& toolDefs =\n1139 |         (!session.tools_raw.isNull() && session.tools_raw.isArray() && session.tools_raw.size() > 0)\n1140 |             ? session.tools_raw\n1141 |             : session.tools;\n1142 | \n1143 |     if (!mustCallTool || !toolDefs.isArray() || toolDefs.size() == 0) {\n1144 |         return;\n1145 |     }\n1146 | \n1147 |     auto startsWith = [](const std::string& s, const std::string& prefix) -> bool {\n1148 |         return s.size() >= prefix.size() && s.compare(0, prefix.size(), prefix) == 0;\n1149 |     };\n1150 |     auto endsWith = [](const std::string& s, const std::string& suffix) -> bool {\n1151 |         return s.size() >= suffix.size() && s.compare(s.size() - suffix.size(), suffix.size(), suffix) == 0;\n1152 |     };\n1153 |     auto stripTrailingPunct = [&](std::string s) -> std::string {\n1154 |         s = trimWhitespace(std::move(s));\n1155 |         static const std::vector<std::string> suffixes = {\n1156 |             \"？\", \"?\", \"！\", \"!\", \"。\", \".\", \"，\", \",\", \"；\", \";\", \":\", \"：\"\n1157 |         };\n1158 |         bool changed = true;\n1159 |         while (changed) {\n1160 |             changed = false;\n1161 |             for (const auto& suf : suffixes) {\n1162 |                 if (endsWith(s, suf)) {\n1163 |                     s.erase(s.size() - suf.size());\n1164 |                     s = trimWhitespace(std::move(s));\n1165 |                     changed = true;\n1166 |                 }\n1167 |             }\n1168 |         }\n1169 |         return s;\n1170 |     };\n1171 |     auto takeLastToken = [&](std::string s) -> std::string {\n1172 |         s = trimWhitespace(std::move(s));\n1173 |         size_t pos = s.find_last_of(\" \\t\\r\\n\");\n1174 |         if (pos == std::string::npos) return s;\n1175 |         return trimWhitespace(s.substr(pos + 1));\n1176 |     };\n1177 | \n1178 |     auto extractLocationLike = [&](std::string input) -> std::string {\n1179 |         std::string s = stripTrailingPunct(trimWhitespace(std::move(input)));\n1180 | \n1181 |         // CN weather-like patterns: \"...的天气...\"\n1182 |         size_t pos = s.find(\"天气\");\n1183 |         if (pos == std::string::npos) pos = s.find(\"气温\");\n1184 |         if (pos != std::string::npos) {\n1185 |             std::string before = stripTrailingPunct(s.substr(0, pos));\n1186 | \n1187 |             // remove common prefixes\n1188 |             static const std::vector<std::string> prefixes = {\n1189 |                 \"请帮我查一下\", \"请帮我查下\", \"请帮我查查\", \"请帮我查\", \"帮我查一下\", \"帮我查下\", \"帮我查查\", \"帮我查\",\n1190 |                 \"麻烦查一下\", \"麻烦查下\", \"麻烦查查\", \"麻烦查\", \"查一下\", \"查下\", \"查查\", \"查询\", \"看看\", \"看一下\", \"请问\", \"问一下\"\n1191 |             };\n1192 |             before = trimWhitespace(std::move(before));\n1193 |             bool removed = true;\n1194 |             while (removed) {\n1195 |                 removed = false;\n1196 |                 for (const auto& p : prefixes) {\n1197 |                     if (startsWith(before, p)) {\n1198 |                         before = trimWhitespace(before.substr(p.size()));\n1199 |                         removed = true;\n1200 |                         break;\n1201 |                     }\n1202 |                 }\n1203 |             }\n1204 | \n1205 |             // remove trailing particles/time words\n1206 |             static const std::vector<std::string> timeSuffixes = {\"今天\", \"明天\", \"后天\", \"现在\", \"当前\", \"目前\"};\n1207 |             before = stripTrailingPunct(trimWhitespace(std::move(before)));\n1208 |             for (const auto& t : timeSuffixes) {\n1209 |                 if (endsWith(before, t)) {\n1210 |                     before.erase(before.size() - t.size());\n1211 |                     before = trimWhitespace(std::move(before));\n1212 |                 }\n1213 |             }\n1214 | \n1215 |             if (endsWith(before, \"的\")) {\n1216 |                 before.erase(before.size() - std::string(\"的\").size());\n1217 |                 before = trimWhitespace(std::move(before));\n1218 |             }\n1219 | \n1220 |             before = takeLastToken(std::move(before));\n1221 |             if (!before.empty()) return before;\n1222 |         }\n1223 | \n1224 |         // EN: \"weather in X\"\n1225 |         std::string lower = toLowerStr(s);\n1226 |         const std::string needle = \"weather in \";\n1227 |         size_t p = lower.find(needle);\n1228 |         if (p != std::string::npos) {\n1229 |             std::string loc = stripTrailingPunct(trimWhitespace(s.substr(p + needle.size())));\n1230 |             if (!loc.empty()) return loc;\n1231 |         }\n1232 | \n1233 |         return stripTrailingPunct(trimWhitespace(std::move(s)));\n1234 |     };\n1235 | \n1236 |     // pick tool\n1237 |     std::string toolName = forcedToolName;\n1238 |     Json::Value toolObj;\n1239 |     if (toolName.empty() && toolDefs.size() == 1) {\n1240 |         toolObj = toolDefs[0];\n1241 |         if (toolObj.isObject() && toolObj.get(\"type\", \"\").asString() == \"function\") {\n1242 |             toolName = toolObj[\"function\"].get(\"name\", \"\").asString();\n1243 |         }\n1244 |     }\n1245 |     if (toolName.empty()) {\n1246 |         // Fallback: pick the first function tool\n1247 |         for (const auto& t : toolDefs) {\n1248 |             if (!t.isObject()) continue;\n1249 |             if (t.get(\"type\", \"\").asString() != \"function\") continue;\n1250 |             toolName = t[\"function\"].get(\"name\", \"\").asString();\n1251 |             toolObj = t;\n1252 |             if (!toolName.empty()) break;\n1253 |         }\n1254 |     } else {\n1255 |         // locate the forced tool object\n1256 |         for (const auto& t : toolDefs) {\n1257 |             if (!t.isObject()) continue;\n1258 |             if (t.get(\"type\", \"\").asString() != \"function\") continue;\n1259 |             if (t[\"function\"].get(\"name\", \"\").asString() == toolName) {\n1260 |                 toolObj = t;\n1261 |                 break;\n1262 |             }\n1263 |         }\n1264 |     }\n1265 | \n1266 |     if (toolName.empty()) {\n1267 |         return;\n1268 |     }\n1269 | \n1270 |     Json::Value args(Json::objectValue);\n1271 |     const std::string srcText = session.requestmessage_raw.empty() ? session.requestmessage : session.requestmessage_raw;\n1272 | \n1273 |     std::vector<std::string> requiredParams;\n1274 |     if (toolObj.isObject() && toolObj.isMember(\"function\") && toolObj[\"function\"].isObject()) {\n1275 |         const auto& schema = toolObj[\"function\"][\"parameters\"];\n1276 |         if (schema.isObject()) {\n1277 |             const auto& required = schema[\"required\"];\n1278 |             if (required.isArray()) {\n1279 |                 for (const auto& r : required) {\n1280 |                     if (r.isString()) requiredParams.push_back(r.asString());\n1281 |                 }\n1282 |             }\n1283 |             if (requiredParams.empty() && schema.isMember(\"properties\") && schema[\"properties\"].isObject()) {\n1284 |                 for (const auto& p : schema[\"properties\"].getMemberNames()) {\n1285 |                     requiredParams.push_back(p);\n1286 |                 }\n1287 |             }\n1288 |         }\n1289 |     }\n1290 | \n1291 |     auto isLocationParam = [&](const std::string& name) -> bool {\n1292 |         const std::string n = toLowerStr(name);\n1293 |         return n.find(\"location\") != std::string::npos ||\n1294 |                n.find(\"city\") != std::string::npos ||\n1295 |                n.find(\"place\") != std::string::npos ||\n1296 |                n.find(\"address\") != std::string::npos ||\n1297 |                n.find(\"region\") != std::string::npos;\n1298 |     };\n1299 | \n1300 |     for (const auto& p : requiredParams) {\n1301 |         if (p.empty()) continue;\n1302 |         std::string v;\n1303 |         if (isLocationParam(p)) {\n1304 |             v = extractLocationLike(srcText);\n1305 |         } else {\n1306 |             v = trimWhitespace(srcText);\n1307 |         }\n1308 |         args[p] = v;\n1309 |     }\n1310 | \n1311 |     generation::ToolCallDone tc;\n1312 |     tc.id = generateFallbackToolCallId();\n1313 |     tc.name = toolName;\n1314 |     tc.index = 0;\n1315 | \n1316 |     Json::StreamWriterBuilder writer;\n1317 |     writer[\"indentation\"] = \"\";\n1318 |     tc.arguments = Json::writeString(writer, args);\n1319 | \n1320 |     outToolCalls.push_back(tc);\n1321 |     outTextContent.clear();\n1322 | \n1323 |     LOG_WARN << \"[GenerationService] 上游未返回 tool call，已根据 tool_choice=required 生成兜底 tool call: \" << toolName;\n1324 |     \n1325 |     // 记录 TOOL_BRIDGE 警告：生成了强制工具调用\n1326 |     Json::Value forcedDetail;\n1327 |     forcedDetail[\"tool_name\"] = toolName;\n1328 |     forcedDetail[\"tool_choice\"] = session.toolChoice;\n1329 |     forcedDetail[\"generated_args\"] = args;\n1330 |     recordWarnStat(\n1331 |         session,\n1332 |         metrics::Domain::TOOL_BRIDGE,\n1333 |         metrics::EventType::TOOLBRIDGE_FORCED_TOOLCALL_GENERATED,\n1334 |         \"Generated forced tool call: \" + toolName,\n1335 |         forcedDetail,\n1336 |         srcText.substr(0, std::min(srcText.size(), size_t(512))),\n1337 |         toolName\n1338 |     );\n1339 | }\n1340 | \n1341 | /**\n1342 |  * @brief 规范化工具调用参数的形状\n1343 |  *\n1344 |  * 【功能说明】\n1345 |  * 上游模型输出的参数格式可能与客户端期望的 JSONSchema 不完全匹配。\n1346 |  * 此函数负责将参数转换为正确的形状，避免客户端解析失败。\n1347 |  *\n1348 |  * 【常见问题示例】\n1349 |  * 1. 数组元素类型错误：\n1350 |  *    - 上游输出: files: [\"src/main.cpp\", \"src/util.cpp\"]\n1351 |  *    - 期望格式: files: [{path: \"src/main.cpp\"}, {path: \"src/util.cpp\"}]\n1352 |  *\n1353 |  * 2. 参数别名：\n1354 |  *    - 上游输出: paths: [\"src/main.cpp\"]\n1355 |  *    - 期望格式: files: [{path: \"src/main.cpp\"}]\n1356 |  *\n1357 |  * 3. 缺失可选字段：\n1358 |  *    - 上游输出: follow_up: [{text: \"Yes\"}]\n1359 |  *    - 期望格式: follow_up: [{text: \"Yes\", mode: \"\"}]\n1360 |  *\n1361 |  * @param session 会话状态，包含工具定义\n1362 |  * @param toolCalls [输入/输出] 待规范化的工具调用列表\n1363 |  */\n1364 | void GenerationService::normalizeToolCallArguments(\n1365 |     const session_st& session,\n1366 |     std::vector<generation::ToolCallDone>& toolCalls\n1367 | ) {\n1368 |     if (toolCalls.empty()) {\n1369 |         return;\n1370 |     }\n1371 | \n1372 |     // 安全提取 JSON Schema 的 type 字段（可能是 string 或 array，如 [\"string\", \"null\"]）\n1373 |     auto safeGetType = [](const Json::Value& schema) -> std::string {\n1374 |         if (!schema.isObject() || !schema.isMember(\"type\")) return \"\";\n1375 |         const auto& typeVal = schema[\"type\"];\n1376 |         if (typeVal.isString()) return typeVal.asString();\n1377 |         if (typeVal.isArray()) {\n1378 |             for (const auto& t : typeVal) {\n1379 |                 if (t.isString() && t.asString() != \"null\") return t.asString();\n1380 |             }\n1381 |             if (typeVal.size() > 0 && typeVal[0].isString()) return typeVal[0].asString();\n1382 |         }\n1383 |         return \"\";\n1384 |     };\n1385 | \n1386 |     const Json::Value& toolDefs =\n1387 |         (!session.tools_raw.isNull() && session.tools_raw.isArray() && session.tools_raw.size() > 0)\n1388 |             ? session.tools_raw\n1389 |             : session.tools;\n1390 | \n1391 |     auto findToolObj = [&](const std::string& toolName) -> const Json::Value* {\n1392 |         if (!toolDefs.isArray()) return nullptr;\n1393 |         for (const auto& t : toolDefs) {\n1394 |             if (!t.isObject()) continue;\n1395 |             if (t.get(\"type\", \"\").asString() != \"function\") continue;\n1396 |             const auto& func = t[\"function\"];\n1397 |             if (!func.isObject()) continue;\n1398 |             if (func.get(\"name\", \"\").asString() == toolName) {\n1399 |                 return &t;\n1400 |             }\n1401 |         }\n1402 |         return nullptr;\n1403 |     };\n1404 | \n1405 |     auto normalizeArrayOfObjectParam = [&](Json::Value& args, const std::string& paramName, const Json::Value& paramSchema) {\n1406 |         if (!args.isObject() || !args.isMember(paramName) || !args[paramName].isArray()) {\n1407 |             return;\n1408 |         }\n1409 |         if (!paramSchema.isObject() || safeGetType(paramSchema) != \"array\") {\n1410 |             return;\n1411 |         }\n1412 |         const auto& items = paramSchema[\"items\"];\n1413 |         if (!items.isObject() || safeGetType(items) != \"object\") {\n1414 |             return;\n1415 |         }\n1416 | \n1417 |         std::vector<std::string> requiredKeys;\n1418 |         const auto& req = items[\"required\"];\n1419 |         if (req.isArray()) {\n1420 |             for (const auto& r : req) {\n1421 |                 if (r.isString()) requiredKeys.push_back(r.asString());\n1422 |             }\n1423 |         }\n1424 |         if (requiredKeys.empty() && items.isMember(\"properties\") && items[\"properties\"].isObject()) {\n1425 |             for (const auto& p : items[\"properties\"].getMemberNames()) {\n1426 |                 requiredKeys.push_back(p);\n1427 |             }\n1428 |         }\n1429 |         if (requiredKeys.empty()) {\n1430 |             return;\n1431 |         }\n1432 | \n1433 |         const Json::Value* itemProps = nullptr;\n1434 |         if (items.isMember(\"properties\") && items[\"properties\"].isObject()) {\n1435 |             itemProps = &items[\"properties\"];\n1436 |         }\n1437 |         auto getPropType = [&](const std::string& key) -> std::string {\n1438 |             if (!itemProps || !itemProps->isObject()) return \"\";\n1439 |             if (!itemProps->isMember(key) || !(*itemProps)[key].isObject()) return \"\";\n1440 |             return safeGetType((*itemProps)[key]);\n1441 |         };\n1442 |         auto hasKey = [&](const std::string& key) -> bool {\n1443 |             for (const auto& k : requiredKeys) {\n1444 |                 if (k == key) return true;\n1445 |             }\n1446 |             return false;\n1447 |         };\n1448 |         auto pickStringKey = [&]() -> std::string {\n1449 |             // Common nested-array patterns emitted by upstreams:\n1450 |             // - read_file.files: [\"path1\",\"path2\"]  -> [{\"path\":\"path1\"},...]\n1451 |             // - ask_followup_question.follow_up: [\"...\"] -> [{\"text\":\"...\"}]\n1452 |             if (paramName == \"files\") return \"path\";\n1453 |             if (hasKey(\"text\")) return \"text\";\n1454 |             if (hasKey(\"path\")) return \"path\";\n1455 |             if (hasKey(\"name\")) return \"name\";\n1456 |             if (hasKey(\"id\")) return \"id\";\n1457 |             return requiredKeys[0];\n1458 |         };\n1459 | \n1460 |         Json::Value out(Json::arrayValue);\n1461 |         for (const auto& el : args[paramName]) {\n1462 |             Json::Value obj;\n1463 |             if (el.isString()) {\n1464 |                 obj = Json::Value(Json::objectValue);\n1465 |                 obj[pickStringKey()] = el.asString();\n1466 |             } else if (el.isObject()) {\n1467 |                 obj = el;\n1468 |             } else {\n1469 |                 continue;\n1470 |             }\n1471 | \n1472 |             // Fill common required keys with safe defaults when missing\n1473 |             for (const auto& k : requiredKeys) {\n1474 |                 if (!obj.isMember(k)) {\n1475 |                     if (k == \"mode\") {\n1476 |                         obj[k] = \"\";\n1477 |                     }\n1478 |                 }\n1479 |             }\n1480 | \n1481 |             // Special-case: read_file file object expects {path:string}\n1482 |             if (paramName == \"files\") {\n1483 |                 if (!obj.isMember(\"path\")) {\n1484 |                     if (obj.isMember(\"file\") && obj[\"file\"].isString()) obj[\"path\"] = obj[\"file\"].asString();\n1485 |                     else if (obj.isMember(\"name\") && obj[\"name\"].isString()) obj[\"path\"] = obj[\"name\"].asString();\n1486 |                 }\n1487 |             }\n1488 | \n1489 |             // Drop invalid/incomplete entries to avoid clients crashing on `undefined` paths, etc.\n1490 |             bool valid = true;\n1491 |             for (const auto& k : requiredKeys) {\n1492 |                 if (k == \"mode\") {\n1493 |                     if (!obj.isMember(k) || !obj[k].isString()) obj[k] = \"\";\n1494 |                     continue;\n1495 |                 }\n1496 |                 if (!obj.isMember(k) || obj[k].isNull()) {\n1497 |                     valid = false;\n1498 |                     break;\n1499 |                 }\n1500 |                 const std::string t = getPropType(k);\n1501 |                 if (t == \"string\" && !obj[k].isString()) {\n1502 |                     Json::StreamWriterBuilder writer;\n1503 |                     writer[\"indentation\"] = \"\";\n1504 |                     obj[k] = Json::writeString(writer, obj[k]);\n1505 |                 }\n1506 |             }\n1507 | \n1508 |             if (valid && paramName == \"files\") {\n1509 |                 if (!obj.isMember(\"path\") || !obj[\"path\"].isString() || obj[\"path\"].asString().empty()) {\n1510 |                     valid = false;\n1511 |                 }\n1512 |             }\n1513 | \n1514 |             if (valid) {\n1515 |                 out.append(obj);\n1516 |             }\n1517 |         }\n1518 | \n1519 |         // Always replace with a normalized array (even if empty) to avoid downstream crashes.\n1520 |         args[paramName] = out;\n1521 |     };\n1522 | \n1523 |     for (auto& tc : toolCalls) {\n1524 |         if (tc.arguments.empty()) continue;\n1525 | \n1526 |         Json::Value args;\n1527 |         Json::CharReaderBuilder builder;\n1528 |         std::string errors;\n1529 |         std::istringstream iss(tc.arguments);\n1530 |         if (!Json::parseFromStream(builder, iss, &args, &errors) || !args.isObject()) {\n1531 |             continue;\n1532 |         }\n1533 | \n1534 |         const Json::Value* toolObj = findToolObj(tc.name);\n1535 |         if (!toolObj) {\n1536 |             continue;\n1537 |         }\n1538 | \n1539 |         const auto& paramsSchema = (*toolObj)[\"function\"][\"parameters\"];\n1540 |         if (!paramsSchema.isObject() || !paramsSchema.isMember(\"properties\") || !paramsSchema[\"properties\"].isObject()) {\n1541 |             continue;\n1542 |         }\n1543 | \n1544 |         // Common alias: some models use `paths` while schema expects `files` (read_file).\n1545 |         if (tc.name == \"read_file\" && !args.isMember(\"files\") && args.isMember(\"paths\") && args[\"paths\"].isArray()) {\n1546 |             Json::Value files(Json::arrayValue);\n1547 |             for (const auto& p : args[\"paths\"]) {\n1548 |                 if (!p.isString()) continue;\n1549 |                 Json::Value obj(Json::objectValue);\n1550 |                 obj[\"path\"] = p.asString();\n1551 |                 files.append(obj);\n1552 |             }\n1553 |             if (files.size() > 0) {\n1554 |                 args[\"files\"] = files;\n1555 |             }\n1556 |         }\n1557 | \n1558 |         const auto& props = paramsSchema[\"properties\"];\n1559 |         for (const auto& paramName : props.getMemberNames()) {\n1560 |             const auto& paramSchema = props[paramName];\n1561 |             const std::string type = safeGetType(paramSchema);\n1562 |             if (type == \"array\" && paramSchema.isMember(\"items\") &&\n1563 |                 paramSchema[\"items\"].isObject() &&\n1564 |                 safeGetType(paramSchema[\"items\"]) == \"object\") {\n1565 |                 normalizeArrayOfObjectParam(args, paramName, paramSchema);\n1566 |             }\n1567 |         }\n1568 | \n1569 |         // RooCode sometimes emits non-existent mode slugs (e.g. \"single\") for ask_followup_question.\n1570 |         // Normalize unknown values to empty string (meaning \"no mode switch\") to keep clients stable.\n1571 |         if (tc.name == \"ask_followup_question\" && args.isMember(\"follow_up\") && args[\"follow_up\"].isArray()) {\n1572 |             for (Json::ArrayIndex i = 0; i < args[\"follow_up\"].size(); ++i) {\n1573 |                 auto& item = args[\"follow_up\"][i];\n1574 |                 if (!item.isObject()) continue;\n1575 | \n1576 |                 if (!item.isMember(\"mode\") || !item[\"mode\"].isString()) {\n1577 |                     item[\"mode\"] = \"\";\n1578 |                     continue;\n1579 |                 }\n1580 | \n1581 |                 const std::string mode = toLowerStr(item[\"mode\"].asString());\n1582 |                 if (!(mode.empty() || mode == \"code\" || mode == \"ask\" || mode == \"architect\")) {\n1583 |                     item[\"mode\"] = \"\";\n1584 |                 }\n1585 |             }\n1586 |         }\n1587 | \n1588 |         Json::StreamWriterBuilder writer;\n1589 |         writer[\"indentation\"] = \"\";\n1590 |         tc.arguments = Json::writeString(writer, args);\n1591 |     }\n1592 | }\n1593 | \n1594 | /**\n1595 |  * @brief 应用严格客户端规则（仅 Roo/Kilo）\n1596 |  *\n1597 |  * 【规则说明】\n1598 |  * Roo/Kilo 客户端对响应格式有严格要求：\n1599 |  * - 每次响应必须且只能包含 1 个工具调用\n1600 |  * - 不允许纯文本响应（必须包装为 attempt_completion）\n1601 |  * - 不允许多个工具调用（只保留第一个）\n1602 |  *\n1603 |  * 【处理逻辑】\n1604 |  * 1. 如果没有工具调用但有文本 → 包装为 attempt_completion\n1605 |  * 2. 如果有工具调用 → 清空文本内容（避免重复输出）\n1606 |  * 3. 如果有多个工具调用 → 只保留第一个\n1607 |  *\n1608 |  * 【为什么需要这个规则？】\n1609 |  * Roo/Kilo 客户端的工作流设计为：\n1610 |  * - 每轮对话，AI 必须执行一个动作（工具调用）\n1611 |  * - 客户端根据工具调用类型决定下一步操作\n1612 |  * - 如果没有工具调用，客户端无法继续工作流\n1613 |  *\n1614 |  * @param clientType 客户端类型（用于日志）\n1615 |  * @param textContent [输入/输出] 文本内容，处理后可能被清空\n1616 |  * @param toolCalls [输入/输出] 工具调用列表，可能被修改\n1617 |  */\n1618 | void GenerationService::applyStrictClientRules(\n1619 |     const std::string& clientType,\n1620 |     std::string& textContent,\n1621 |     std::vector<generation::ToolCallDone>& toolCalls\n1622 | ) {\n1623 |     // 规则 1: 如果没有工具调用但有文本，包装为 attempt_completion\n1624 |     // attempt_completion 是 Roo/Kilo 的\"完成任务\"工具，用于输出最终结果\n1625 |     if (toolCalls.empty() && !textContent.empty()) {\n1626 |         generation::ToolCallDone tc;\n1627 |         tc.id = generateFallbackToolCallId();\n1628 |         tc.name = \"attempt_completion\";\n1629 |         tc.index = 0;\n1630 | \n1631 |         Json::Value args(Json::objectValue);\n1632 |         args[\"result\"] = textContent;\n1633 |         Json::StreamWriterBuilder writer;\n1634 |         writer[\"indentation\"] = \"\";\n1635 |         tc.arguments = Json::writeString(writer, args);\n1636 | \n1637 |         toolCalls.push_back(tc);\n1638 |         LOG_WARN << \"[GenerationService][\" << clientType << \"] 未检测到 tool call，已自动包装为 attempt_completion\";\n1639 | \n1640 |         // 清空文本内容（已包装到 attempt_completion 中）\n1641 |         // 注意：零宽会话ID会在后续步骤单独嵌入\n1642 |         textContent.clear();\n1643 |     } else if (!toolCalls.empty()) {\n1644 |         // // 规则 2: 如果有工具调用，清空文本内容\n1645 |         // // 避免工具调用和文本同时输出导致客户端混淆\n1646 |         // textContent.clear();\n1647 |     }\n1648 | \n1649 |     // 规则 3: 如果有多个工具调用，只保留第一个\n1650 |     // Roo/Kilo 客户端每次只能处理一个工具调用\n1651 |     if (toolCalls.size() > 1) {\n1652 |         LOG_WARN << \"[GenerationService][\" << clientType << \"] 检测到多个 tool call，已仅保留第一个以满足客户端约束\";\n1653 |         toolCalls.erase(toolCalls.begin() + 1, toolCalls.end());\n1654 |     }\n1655 | }\n1656 | \n1657 | void GenerationService::transformRequestForToolBridge(session_st& session) {\n1658 |     const std::string clientType = safeJsonAsString(session.client_info.get(\"client_type\", \"\"), \"\");\n1659 |     const bool strictToolClient = (clientType == \"Kilo-Code\" || clientType == \"RooCode\");\n1660 | \n1661 |     // Tool definition verbosity switch (configurable)\n1662 |     // Default: compact = simplified types; full = detailed types\n1663 |     bool useFullToolDefinitions = false;\n1664 |     bool includeToolDescriptions = false; // compact: include function description; full: include function+param descriptions\n1665 |     int maxDescriptionChars = 160;        // truncate descriptions to avoid prompt bloat\n1666 | \n1667 |     {\n1668 |         const auto& customConfig = drogon::app().getCustomConfig();\n1669 |         if (customConfig.isObject() && customConfig.isMember(\"tool_bridge\") && customConfig[\"tool_bridge\"].isObject()) {\n1670 |             const auto& tb = customConfig[\"tool_bridge\"];\n1671 | \n1672 |             bool hasDefinitionMode = false;\n1673 |             std::string definitionMode;\n1674 |             bool hasLegacyUseFull = false;\n1675 |             bool legacyUseFull = false;\n1676 | \n1677 |             if (tb.isMember(\"definition_mode\") && tb[\"definition_mode\"].isString()) {\n1678 |                 hasDefinitionMode = true;\n1679 |                 definitionMode = toLowerStr(tb[\"definition_mode\"].asString());\n1680 |             }\n1681 | \n1682 |             if (tb.isMember(\"use_full_definitions\") && tb[\"use_full_definitions\"].isBool()) {\n1683 |                 hasLegacyUseFull = true;\n1684 |                 legacyUseFull = tb[\"use_full_definitions\"].asBool();\n1685 |             }\n1686 | \n1687 |             if (tb.isMember(\"include_descriptions\") && tb[\"include_descriptions\"].isBool()) {\n1688 |                 includeToolDescriptions = tb[\"include_descriptions\"].asBool();\n1689 |             }\n1690 | \n1691 |             if (tb.isMember(\"max_description_chars\") && tb[\"max_description_chars\"].isInt()) {\n1692 |                 maxDescriptionChars = tb[\"max_description_chars\"].asInt();\n1693 |             }\n1694 | \n1695 |             // Priority:\n1696 |             // 1) definition_mode (compact/full)\n1697 |             // 2) legacy use_full_definitions (bool)\n1698 |             // 3) default compact\n1699 |             if (hasDefinitionMode) {\n1700 |                 if (definitionMode == \"full\") {\n1701 |                     useFullToolDefinitions = true;\n1702 |                 } else if (definitionMode == \"compact\") {\n1703 |                     useFullToolDefinitions = false;\n1704 |                 } else {\n1705 |                     LOG_WARN << \"[GenerationService] tool_bridge.definition_mode invalid: \" << definitionMode\n1706 |                              << \", fallback to default(compact)\";\n1707 |                     useFullToolDefinitions = false;\n1708 |                 }\n1709 | \n1710 |                 if (hasLegacyUseFull) {\n1711 |                     const bool modeIsFull = (definitionMode == \"full\");\n1712 |                     const bool modeIsCompact = (definitionMode == \"compact\");\n1713 |                     if ((modeIsFull || modeIsCompact) && legacyUseFull != modeIsFull) {\n1714 |                         LOG_WARN << \"[GenerationService] tool_bridge config conflict: definition_mode=\" << definitionMode\n1715 |                                  << \" overrides legacy use_full_definitions=\" << (legacyUseFull ? \"true\" : \"false\");\n1716 |                     }\n1717 |                 }\n1718 |             } else if (hasLegacyUseFull) {\n1719 |                 useFullToolDefinitions = legacyUseFull;\n1720 |             }\n1721 | \n1722 |             if (maxDescriptionChars < 0) maxDescriptionChars = 0;\n1723 |             if (maxDescriptionChars > 2000) maxDescriptionChars = 2000;\n1724 |         }\n1725 |     }\n1726 | \n1727 |     // Kilo-Code / RooCode clients send a very long system prompt blob containing tool\n1728 |     // instructions that are incompatible with our XML-tag bridge. Keep only the first\n1729 |     // \"intro\" section so the upstream sees language/role guidance but not the full\n1730 |     // client prompt blob.\n1731 |     // if (strictToolClient && !session.systemprompt.empty()) {\n1732 |     //     const std::string marker = \"\\n\\n====\";\n1733 |     //     size_t pos = session.systemprompt.find(marker);\n1734 |     //     if (pos != std::string::npos) {\n1735 |     //         session.systemprompt = session.systemprompt.substr(0, pos);\n1736 |     //     }\n1737 |     // }\n1738 | \n1739 |     auto encodeToolList = [&](const Json::Value& tools) -> std::string {\n1740 |         if (!tools.isArray() || tools.empty()) {\n1741 |             return \"\";\n1742 |         }\n1743 | \n1744 |         auto join = [](const std::vector<std::string>& items, const std::string& sep) -> std::string {\n1745 |             std::ostringstream oss;\n1746 |             for (size_t i = 0; i < items.size(); ++i) {\n1747 |                 if (i) oss << sep;\n1748 |                 oss << items[i];\n1749 |             }\n1750 |             return oss.str();\n1751 |         };\n1752 | \n1753 |         auto truncate = [&](std::string s) -> std::string {\n1754 |             s = trimWhitespace(std::move(s));\n1755 |             if (maxDescriptionChars <= 0) return \"\";\n1756 |             if (static_cast<int>(s.size()) <= maxDescriptionChars) return s;\n1757 |             return s.substr(0, static_cast<size_t>(maxDescriptionChars)) + \"...\";\n1758 |         };\n1759 | \n1760 |         // Collect required field names from schema\n1761 |         auto getRequiredSet = [](const Json::Value& schema) -> std::unordered_set<std::string> {\n1762 |             std::unordered_set<std::string> requiredSet;\n1763 |             if (!schema.isObject()) return requiredSet;\n1764 | \n1765 |             const auto& required = schema[\"required\"];\n1766 |             if (required.isArray()) {\n1767 |                 for (const auto& r : required) {\n1768 |                     if (r.isString()) requiredSet.insert(r.asString());\n1769 |                 }\n1770 |             }\n1771 |             return requiredSet;\n1772 |         };\n1773 | \n1774 |         // Collect all property names from schema (for nested objects)\n1775 |         auto collectSchemaKeys = [](const Json::Value& schema) -> std::vector<std::string> {\n1776 |             std::vector<std::string> keys;\n1777 |             if (!schema.isObject()) return keys;\n1778 | \n1779 |             const auto& required = schema[\"required\"];\n1780 |             if (required.isArray()) {\n1781 |                 for (const auto& r : required) {\n1782 |                     if (r.isString()) keys.push_back(r.asString());\n1783 |                 }\n1784 |             }\n1785 | \n1786 |             if (keys.empty() && schema.isMember(\"properties\") && schema[\"properties\"].isObject()) {\n1787 |                 for (const auto& p : schema[\"properties\"].getMemberNames()) {\n1788 |                     keys.push_back(p);\n1789 |                 }\n1790 |             }\n1791 | \n1792 |             return keys;\n1793 |         };\n1794 | \n1795 |         // JSON Schema: \"type\" may be string or array (e.g. [\"string\",\"null\"]).\n1796 |         // Never call asString() blindly to avoid Json::LogicError: \"Type is not convertible to string\".\n1797 |         auto schemaTypeToString = [&](const Json::Value& typeVal) -> std::string {\n1798 |             if (typeVal.isString()) return typeVal.asString();\n1799 |             if (typeVal.isArray()) {\n1800 |                 std::vector<std::string> parts;\n1801 |                 parts.reserve(static_cast<size_t>(typeVal.size()));\n1802 |                 for (const auto& t : typeVal) {\n1803 |                     if (t.isString()) parts.push_back(t.asString());\n1804 |                 }\n1805 |                 if (!parts.empty()) return join(parts, \"|\");\n1806 |             }\n1807 |             return \"\";\n1808 |         };\n1809 | \n1810 |         auto schemaHasType = [&](const Json::Value& schema, const std::string& expected) -> bool {\n1811 |             if (!schema.isObject() || !schema.isMember(\"type\")) return false;\n1812 |             const auto& t = schema[\"type\"];\n1813 |             if (t.isString()) return t.asString() == expected;\n1814 |             if (t.isArray()) {\n1815 |                 for (const auto& it : t) {\n1816 |                     if (it.isString() && it.asString() == expected) return true;\n1817 |                 }\n1818 |             }\n1819 |             return false;\n1820 |         };\n1821 | \n1822 |         // compact: simplified types (string/number/boolean/object/array/string|null)\n1823 |         auto describeSchemaCompact = [&](const Json::Value& schema) -> std::string {\n1824 |             if (!schema.isObject()) return \"any\";\n1825 |             if (schemaHasType(schema, \"array\")) return \"array\";\n1826 |             if (schemaHasType(schema, \"object\")) return \"object\";\n1827 |             const std::string typeStr = schema.isMember(\"type\") ? schemaTypeToString(schema[\"type\"]) : \"\";\n1828 |             return typeStr.empty() ? \"any\" : typeStr;\n1829 |         };\n1830 | \n1831 |         // full: detailed types (array item/object keys when available)\n1832 |         auto describeSchemaFull = [&](const Json::Value& schema) -> std::string {\n1833 |             if (!schema.isObject()) return \"any\";\n1834 | \n1835 |             const bool isArrayType = schemaHasType(schema, \"array\");\n1836 |             const bool isObjectType = schemaHasType(schema, \"object\");\n1837 |             const std::string typeStr = schema.isMember(\"type\") ? schemaTypeToString(schema[\"type\"]) : \"\";\n1838 | \n1839 |             if (isArrayType) {\n1840 |                 const auto& items = schema[\"items\"];\n1841 |                 if (items.isObject()) {\n1842 |                     const bool itemsIsObject = schemaHasType(items, \"object\");\n1843 |                     const std::string itemTypeStr = items.isMember(\"type\") ? schemaTypeToString(items[\"type\"]) : \"\";\n1844 | \n1845 |                     if (itemsIsObject) {\n1846 |                         const auto keys = collectSchemaKeys(items);\n1847 |                         return \"[{\" + join(keys, \",\") + \"}]\";\n1848 |                     }\n1849 |                     if (!itemTypeStr.empty()) {\n1850 |                         return itemTypeStr + \"[]\";\n1851 |                     }\n1852 |                 }\n1853 |                 return \"array\";\n1854 |             }\n1855 | \n1856 |             if (isObjectType) {\n1857 |                 const auto keys = collectSchemaKeys(schema);\n1858 |                 return \"{\" + join(keys, \",\") + \"}\";\n1859 |             }\n1860 | \n1861 |             return typeStr.empty() ? \"any\" : typeStr;\n1862 |         };\n1863 | \n1864 |         std::ostringstream oss;\n1865 |         for (const auto& tool : tools) {\n1866 |             if (!tool.isObject()) continue;\n1867 |             if (tool.get(\"type\", \"\").asString() != \"function\") continue;\n1868 | \n1869 |             const auto& func = tool[\"function\"];\n1870 |             if (!func.isObject()) continue;\n1871 | \n1872 |             const std::string name = func.get(\"name\", \"\").asString();\n1873 |             if (name.empty()) continue;\n1874 | \n1875 |             const std::string funcDesc = func.isMember(\"description\") ? safeJsonAsString(func[\"description\"], \"\") : \"\";\n1876 | \n1877 |             const auto& schema = func[\"parameters\"];\n1878 |             const auto requiredSet = schema.isObject() ? getRequiredSet(schema) : std::unordered_set<std::string>{};\n1879 |             const auto& props = schema.isObject() ? schema[\"properties\"] : Json::Value(Json::nullValue);\n1880 | \n1881 |             if (!useFullToolDefinitions) {\n1882 |                 // Compact = simplified types, clearer format (no '-' or '—' separators)\n1883 |                 oss << \"Tool: \" << name << \"\\n\";\n1884 | \n1885 |                 if (includeToolDescriptions) {\n1886 |                     const std::string t = truncate(funcDesc);\n1887 |                     if (!t.empty()) {\n1888 |                         oss << \"What: \" << t << \"\\n\";\n1889 |                     }\n1890 |                 }\n1891 | \n1892 |                 oss << \"Args:\\n\";\n1893 |                 if (props.isObject() && !props.getMemberNames().empty()) {\n1894 |                     for (const auto& key : props.getMemberNames()) {\n1895 |                         const bool isRequired = requiredSet.find(key) != requiredSet.end();\n1896 |                         const std::string req = isRequired ? \"required\" : \"optional\";\n1897 | \n1898 |                         std::string typePart = \"any\";\n1899 |                         if (props[key].isObject()) {\n1900 |                             typePart = describeSchemaCompact(props[key]);\n1901 |                         }\n1902 | \n1903 |                         oss << \"  \" << key << \" : \" << typePart << \" [\" << req << \"]\\n\";\n1904 |                     }\n1905 |                 } else {\n1906 |                     oss << \"  (none)\\n\";\n1907 |                 }\n1908 | \n1909 |                 oss << \"\\n\";\n1910 |                 continue;\n1911 |             }\n1912 | \n1913 |             // Full = detailed types, clearer format (no '-' or '—' separators)\n1914 |             oss << \"Tool: \" << name << \"\\n\";\n1915 | \n1916 |             if (includeToolDescriptions) {\n1917 |                 const std::string t = truncate(funcDesc);\n1918 |                 if (!t.empty()) {\n1919 |                     oss << \"What: \" << t << \"\\n\";\n1920 |                 }\n1921 |             }\n1922 | \n1923 |             oss << \"Args:\\n\";\n1924 |             if (props.isObject() && !props.getMemberNames().empty()) {\n1925 |                 for (const auto& key : props.getMemberNames()) {\n1926 |                     const bool isRequired = requiredSet.find(key) != requiredSet.end();\n1927 |                     const std::string req = isRequired ? \"required\" : \"optional\";\n1928 | \n1929 |                     std::string typePart = \"any\";\n1930 |                     std::string pDesc;\n1931 | \n1932 |                     if (props[key].isObject()) {\n1933 |                         typePart = describeSchemaFull(props[key]);\n1934 |                         if (includeToolDescriptions && props[key].isMember(\"description\")) {\n1935 |                             pDesc = truncate(safeJsonAsString(props[key][\"description\"], \"\"));\n1936 |                         }\n1937 |                     }\n1938 | \n1939 |                     oss << \"  \" << key << \" : \" << typePart << \" [\" << req << \"]\";\n1940 |                     if (includeToolDescriptions && !pDesc.empty()) {\n1941 |                         oss << \" ; \" << pDesc;\n1942 |                     }\n1943 |                     oss << \"\\n\";\n1944 |                 }\n1945 |             } else {\n1946 |                 oss << \"  (none)\\n\";\n1947 |             }\n1948 | \n1949 |             oss << \"\\n\";\n1950 |         }\n1951 | \n1952 |         return oss.str();\n1953 |     };\n1954 | \n1955 |     // Encode tool definitions for upstream.\n1956 |     // Default: compact list to avoid huge descriptions (which can trigger upstream refusals\n1957 |     // and also push the user request out of the context window).\n1958 |     std::string toolDefinitions;\n1959 |     try {\n1960 |         toolDefinitions = encodeToolList(session.tools);\n1961 |     } catch (const std::exception& e) {\n1962 |         // Never fail the request due to tool schema encoding. Fallback to names only.\n1963 |         LOG_WARN << \"[GenerationService] 工具定义编码异常，回退为仅工具名列表: \" << e.what();\n1964 |         std::ostringstream oss;\n1965 |         for (const auto& tool : session.tools) {\n1966 |             if (!tool.isObject()) continue;\n1967 |             if (tool.get(\"type\", \"\").asString() != \"function\") continue;\n1968 |             const auto& func = tool[\"function\"];\n1969 |             if (!func.isObject()) continue;\n1970 |             const std::string name = func.get(\"name\", \"\").asString();\n1971 |             if (!name.empty()) {\n1972 |                 oss << \"Tool: \" << name << \"\\n\";\n1973 |             }\n1974 |         }\n1975 |         toolDefinitions = oss.str();\n1976 |     }\n1977 | \n1978 |     if (toolDefinitions.empty()) {\n1979 |         LOG_WARN << \"[GenerationService] 工具定义编码结果为空\";\n1980 |         return;\n1981 |     }\n1982 | \n1983 |     // Preserve originals for downstream parsing / fallbacks.\n1984 |     if (session.requestmessage_raw.empty()) {\n1985 |         session.requestmessage_raw = session.requestmessage;\n1986 |     }\n1987 |     if (session.tools_raw.isNull() || !session.tools_raw.isArray() || session.tools_raw.size() == 0) {\n1988 |         session.tools_raw = session.tools;\n1989 |     }\n1990 | \n1991 |     // Tool choice parsing (supports both string and object encodings).\n1992 |     auto normalizeLower = [](std::string s) {\n1993 |         for (auto& c : s) c = static_cast<char>(std::tolower(static_cast<unsigned char>(c)));\n1994 |         return s;\n1995 |     };\n1996 | \n1997 |     std::string toolChoice = \"auto\";\n1998 |     std::string forcedToolName;\n1999 |     if (!session.toolChoice.empty()) {\n2000 |         // JSON object form (e.g. {\"type\":\"function\",\"function\":{\"name\":\"xxx\"}})\n2001 |         if (!session.toolChoice.empty() && session.toolChoice.front() == '{') {\n2002 |             Json::Value tc;\n2003 |             Json::CharReaderBuilder builder;\n2004 |             std::string errors;\n2005 |             std::istringstream iss(session.toolChoice);\n2006 |             if (Json::parseFromStream(builder, iss, &tc, &errors) && tc.isObject()) {\n2007 |                 if (tc.get(\"type\", \"\").asString() == \"function\" && tc.isMember(\"function\") && tc[\"function\"].isObject()) {\n2008 |                     forcedToolName = tc[\"function\"].get(\"name\", \"\").asString();\n2009 |                     if (!forcedToolName.empty()) {\n2010 |                         toolChoice = \"required\";\n2011 |                     }\n2012 |                 }\n2013 |             }\n2014 |         } else {\n2015 |             toolChoice = normalizeLower(session.toolChoice);\n2016 |         }\n2017 |     }\n2018 | \n2019 |     // Generate a per-request random trigger so we only parse tool calls that belong to\n2020 |     // this request (avoids accidentally parsing example XML inside normal prose).\n2021 |     session.tool_bridge_trigger = generateRandomTriggerSignal();\n2022 |     const std::string& triggerSignal = session.tool_bridge_trigger;\n2023 | \n2024 |     // Low-friction \"task\" prompt (English for better model compatibility):\n2025 |     // Modern RLHF-aligned models may reject \"system override\" style tool instructions.\n2026 |     // We present this as a formatting/extraction task and ask the model to output\n2027 |     // a strictly delimited XML block (Toolify-style) when an action/tool call is needed.\n2028 |     //\n2029 |     // IMPORTANT: The wrapper tag <tool_instructions> is intentionally different from\n2030 |     // XmlTagToolCallCodec's recognized tags (function_calls, function_call, tool, args_json)\n2031 |     // to prevent the prompt itself from being misinterpreted as a tool call.\n2032 |     {\n2033 |         std::ostringstream policy;\n2034 |         \n2035 |         // Use English for better model stability with format constraints\n2036 |         policy << \"<tool_instructions>\\n\";\n2037 |         \n2038 |         if (strictToolClient) {\n2039 |             policy << \"Context: Software engineering collaboration\\n\";\n2040 |             policy << \"Task: Generate the next tool call instruction (tools are executed by an external system)\\n\";\n2041 |             policy << \"Goal: Based on the user request, select and output exactly 1 tool to call.\\n\";\n2042 |             policy << \"Note: Do NOT explain whether you have access/permissions. Do NOT ask the user to paste file contents. Use the listed tools directly (e.g., call read_file/list_files when you need files).\\n\";\n2043 |         } else {\n2044 |             policy << \"Context: Software engineering collaboration\\n\";\n2045 |             policy << \"Task: Generate tool call instructions (tools are executed by an external system)\\n\";\n2046 |             policy << \"Goal: Based on the user request, select and output one or more tools to call.\\n\";\n2047 |             policy << \"Note: Do NOT explain whether you have access/permissions. Do NOT ask the user to paste file contents. Use the listed tools directly (e.g., call read_file/list_files when you need files).\\n\";\n2048 |         }\n2049 | \n2050 |         if (!forcedToolName.empty()) {\n2051 |             policy << \"Required tool for this task: \" << forcedToolName << \"\\n\";\n2052 |         } else if (toolChoice == \"required\") {\n2053 |             policy << \"This task MUST output exactly 1 tool call (choose the most appropriate API).\\n\";\n2054 |         } else if (strictToolClient) {\n2055 |             policy << \"Each response MUST output exactly 1 tool call.\\n\";\n2056 |             policy << \"If no other tool is needed, use attempt_completion to output the final result.\\n\";\n2057 |         } else {\n2058 |             policy << \"Output tool calls in XML format ONLY when an API call is needed to complete the task; otherwise respond normally.\\n\";\n2059 |         }\n2060 | \n2061 |         policy << \"\\nRequirements:\\n\";\n2062 |         policy << \"- When outputting a tool call, output ONLY the XML (no explanations, no prefixes/suffixes, no markdown code blocks).\\n\";\n2063 |         policy << \"- You MUST follow this exact XML format (line 1 is the trigger marker, line 2 starts <function_calls>):\\n\";\n2064 |         policy << triggerSignal << \"\\n\";\n2065 |         policy << \"<function_calls>\\n\";\n2066 |         policy << \"  <function_call>\\n\";\n2067 |         policy << \"    <tool>TOOL_NAME</tool>\\n\";\n2068 |         policy << \"    <args_json><![CDATA[{\\\"PARAM_NAME\\\":\\\"VALUE\\\"}]]></args_json>\\n\";\n2069 |         policy << \"  </function_call>\\n\";\n2070 |         policy << \"</function_calls>\\n\";\n2071 |         policy << \"- <tool> MUST be a name that exists in the API definitions below.\\n\";\n2072 |         policy << \"- <args_json> MUST be a valid JSON object containing all required arguments for that tool.\\n\";\n2073 |         policy << \"- Parameter keys MUST exactly match the API definition (case-sensitive).\\n\";\n2074 |         //policy << \"- Parameters marked with * are required and MUST be provided.\\n\";\n2075 |         //policy << \"- Parameters marked with ? are optional.\\n\";\n2076 | \n2077 |         //policy << \"\\nAPI Definitions (* = required, ? = optional):\\n\";\n2078 |         policy << \"\\nAPI Definitions{\\n\";\n2079 | \n2080 |         toolDefinitions = policy.str() + toolDefinitions;\n2081 |         toolDefinitions += \"}</tool_instructions>\\n\\n\";\n2082 |     }\n2083 | \n2084 |     LOG_INFO << \"[GenerationService] 注入工具定义到 requestmessage, 长度: \" << toolDefinitions.length();\n2085 | \n2086 |     std::string originalInput = session.requestmessage;\n2087 |     LOG_INFO << \"工具定义:\" << toolDefinitions;\n2088 |     session.requestmessage = originalInput+ \"\\n\\n\"+\"【注意：回复时必须要满足下面<tool_instructions></tool_instructions>定义中的要求！！！】\" + toolDefinitions+\"；\" ;\n2089 | \n2090 |     // 清除 tools，避免后续流程再次处理\n2091 |     session.tools = Json::Value(Json::nullValue);\n2092 |     \n2093 |     // 记录 TOOL_BRIDGE 警告：注入了工具定义\n2094 |     /*\n2095 |     Json::Value injectDetail;\n2096 |     injectDetail[\"tool_count\"] = session.tools_raw.isArray() ? static_cast<Json::UInt64>(session.tools_raw.size()) : 0;\n2097 |     injectDetail[\"trigger_signal\"] = triggerSignal;\n2098 |     injectDetail[\"tool_choice\"] = toolChoice;\n2099 |     injectDetail[\"forced_tool_name\"] = forcedToolName;\n2100 |     injectDetail[\"strict_client\"] = strictToolClient;\n2101 |     recordWarnStat(\n2102 |         session,\n2103 |         metrics::Domain::TOOL_BRIDGE,\n2104 |         metrics::EventType::TOOLBRIDGE_TRANSFORM_INJECTED,\n2105 |         \"Injected tool definitions for bridge mode\",\n2106 |         injectDetail\n2107 |     );\n2108 |     */\n2109 | }\n\n\n---\n\nFile: aiapi/src/controllers/AiApi.cc\nLines 1-1693:\n   1 | #include \"AiApi.h\"\n   2 | #include <drogon/HttpResponse.h>\n   3 | #include <json/json.h>\n   4 | #include <drogon/drogon.h>\n   5 | #include <unistd.h>\n   6 | #include <random>\n   7 | #include <unordered_map>\n   8 | #include <apiManager/ApiManager.h>\n   9 | #include <accountManager/accountManager.h>\n  10 | #include <dbManager/account/accountDbManager.h>\n  11 | #include <dbManager/metrics/ErrorStatsDbManager.h>\n  12 | #include <dbManager/metrics/StatusDbManager.h>\n  13 | #include <channelManager/channelManager.h>\n  14 | #include <sessionManager/Session.h>\n  15 | #include <sessionManager/ClientOutputSanitizer.h>\n  16 | #include <sessionManager/GenerationService.h>\n  17 | #include <sessionManager/GenerationRequest.h>\n  18 | #include <sessionManager/IResponseSink.h>\n  19 | #include <sessionManager/SessionExecutionGate.h>\n  20 | #include <sessionManager/Errors.h>\n  21 | #include <sessionManager/RequestAdapters.h>\n  22 | #include <sessionManager/ResponseIndex.h>\n  23 | #include <controllers/sinks/ChatSseSink.h>\n  24 | #include <controllers/sinks/ChatJsonSink.h>\n  25 | #include <controllers/sinks/ResponsesSseSink.h>\n  26 | #include <controllers/sinks/ResponsesJsonSink.h>\n  27 | #include <drogon/orm/Exception.h>\n  28 | #include <drogon/orm/DbClient.h>\n  29 | #include <vector> // 添加 vector 头文件\n  30 | #include <ctime>\n  31 | #include <optional>\n  32 | #include <iomanip>\n  33 | #include <sstream>\n  34 | #include <cstring>\n  35 | #include \"AiApi.h\"\n  36 | #include <fstream>      // 处理文件流\n  37 | #include <filesystem>   // 处理目录和文件信息\n  38 | #include <vector>       // 处理容器\n  39 | #include <string>       // 处理字符串\n  40 | #include <chrono>       // 处理系统时间\n  41 | #include <iomanip>      // 如果用到了格式化输出\n  42 | #include <algorithm>    // 处理 std::min\n  43 | using namespace drogon;\n  44 | using namespace drogon::orm;\n  45 | \n  46 | // Add definition of your processing function here\n  47 | // 响应存储已迁移到 Session 层统一管理\n  48 | void AiApi::chaynsapichat(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n  49 | {\n  50 |     //打印所有的请求头\n  51 |     LOG_INFO<<\"**************接收到chaynsapichat请求******************\";\n  52 |     LOG_DEBUG<<\"请求头:\";\n  53 |     for(auto &header : req->getHeaders())\n  54 |     {\n  55 |         LOG_DEBUG<<header.first<<\":\"<<header.second;\n  56 |     }\n  57 |     //打印请求信息\n  58 |     LOG_DEBUG<<\"请求信息:\"<<req->getBody();\n  59 | \n  60 |     auto jsonPtr = req->getJsonObject();\n  61 |        if (!jsonPtr) {\n  62 |         Json::Value error;\n  63 |         error[\"error\"][\"message\"] = \"Invalid JSON in request body\";\n  64 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n  65 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n  66 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n  67 |         callback(resp);\n  68 |         return;\n  69 |     }\n  70 |     auto& reqbody = *jsonPtr;\n  71 | \n  72 |     auto& reqmessages = reqbody[\"messages\"];\n  73 |     if (reqmessages.empty()) {\n  74 |         Json::Value error;\n  75 |         error[\"error\"][\"message\"] = \"Messages array cannot be empty\";\n  76 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n  77 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n  78 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n  79 |         callback(resp);\n  80 |         return;\n  81 |     }\n  82 |     \n  83 |     const bool stream = reqbody[\"stream\"].asBool();\n  84 |     LOG_INFO << \"[API接口] 流式模式: \" << stream;\n  85 |     \n  86 |     // ========== PR4: 使用 RequestAdapters 构建 GenerationRequest ==========\n  87 |     LOG_INFO << \"[API接口] 使用 RequestAdapters 构建 GenerationRequest\";\n  88 |     GenerationRequest genReq = RequestAdapters::buildGenerationRequestFromChat(req);\n  89 |     \n  90 |     // 设置默认 API（如果为空）\n  91 |     if (genReq.provider.empty()) {\n  92 |         genReq.provider = \"chaynsapi\";\n  93 |     }\n  94 |     \n  95 |     // ========== 非流式请求：使用 GenerationService::runGuarded() ==========\n  96 |     if (!stream) {\n  97 |         LOG_INFO << \"非流式响应 - 使用 GenerationService::runGuarded()\";\n  98 |         \n  99 |         HttpResponsePtr jsonResp;\n 100 |         int httpStatus = 200;\n 101 |         \n 102 |         // 创建 ChatJsonSink\n 103 |         ChatJsonSink jsonSink(\n 104 |             [&jsonResp, &httpStatus](const Json::Value& response, int status) {\n 105 |                 jsonResp = HttpResponse::newHttpJsonResponse(response);\n 106 |                 httpStatus = status;\n 107 |             },\n 108 |             genReq.model\n 109 |         );\n 110 |         \n 111 |         // 使用 GenerationService::runGuarded() 执行生成\n 112 |         GenerationService genService;\n 113 |         auto err = genService.runGuarded(\n 114 |             genReq, jsonSink,\n 115 |             session::ConcurrencyPolicy::RejectConcurrent\n 116 |         );\n 117 |         \n 118 |         // 检查是否有并发冲突错误\n 119 |         if (err.has_value()) {\n 120 |             Json::Value errorJson;\n 121 |             errorJson[\"error\"][\"message\"] = err->message;\n 122 |             errorJson[\"error\"][\"type\"] = err->type();\n 123 |             auto errorResp = HttpResponse::newHttpJsonResponse(errorJson);\n 124 |             errorResp->setStatusCode(static_cast<HttpStatusCode>(err->httpStatus()));\n 125 |             callback(errorResp);\n 126 |             return;\n 127 |         }\n 128 |         \n 129 |         // 设置状态码并返回响应\n 130 |         if (jsonResp) {\n 131 |             jsonResp->setStatusCode(static_cast<HttpStatusCode>(httpStatus));\n 132 |             jsonResp->setContentTypeString(\"application/json; charset=utf-8\");\n 133 |             callback(jsonResp);\n 134 |         } else {\n 135 |             // 备用响应\n 136 |             Json::Value error;\n 137 |             error[\"error\"][\"message\"] = \"Failed to generate response\";\n 138 |             error[\"error\"][\"type\"] = \"internal_error\";\n 139 |             auto errorResp = HttpResponse::newHttpJsonResponse(error);\n 140 |             errorResp->setStatusCode(k500InternalServerError);\n 141 |             callback(errorResp);\n 142 |         }\n 143 |         return;\n 144 |     }\n 145 |     \n 146 |     // ========== 流式请求：使用 GenerationService::runGuarded() ==========\n 147 |     LOG_INFO << \"[API接口] 流式响应 - 使用 GenerationService::runGuarded()\";\n 148 |     LOG_INFO << \"[API接口] previousResponseId: \"\n 149 |              << (genReq.previousResponseId.has_value() ? *genReq.previousResponseId : \"\");\n 150 |     \n 151 |     // 使用 CollectorSink 收集完整响应\n 152 |     CollectorSink collector;\n 153 |     GenerationService genService;\n 154 |     auto gateErr = genService.runGuarded(\n 155 |         genReq, collector,\n 156 |         session::ConcurrencyPolicy::RejectConcurrent\n 157 |     );\n 158 |     \n 159 |     // 检查是否有并发冲突错误\n 160 |     if (gateErr.has_value()) {\n 161 |         Json::Value errorJson;\n 162 |         errorJson[\"error\"][\"message\"] = gateErr->message;\n 163 |         errorJson[\"error\"][\"type\"] = gateErr->type();\n 164 |         auto errorResp = HttpResponse::newHttpJsonResponse(errorJson);\n 165 |         errorResp->setStatusCode(static_cast<HttpStatusCode>(gateErr->httpStatus()));\n 166 |         callback(errorResp);\n 167 |         return;\n 168 |     }\n 169 |     \n 170 |     // Stream via ChatSseSink so tool_calls can be forwarded correctly.\n 171 |     if (collector.hasError()) {\n 172 |         auto error = collector.getError();\n 173 |         Json::Value errorJson;\n 174 |         errorJson[\"error\"][\"message\"] = error ? error->message : \"Provider error\";\n 175 |         errorJson[\"error\"][\"type\"] = error ? generation::errorCodeToString(error->code) : \"provider_error\";\n 176 |         errorJson[\"error\"][\"code\"] = errorJson[\"error\"][\"type\"];\n 177 |         auto errorResp = HttpResponse::newHttpJsonResponse(errorJson);\n 178 |         errorResp->setStatusCode(static_cast<HttpStatusCode>(\n 179 |             error ? generation::errorCodeToHttpStatus(error->code) : 500\n 180 |         ));\n 181 |         errorResp->setContentTypeString(\"application/json; charset=utf-8\");\n 182 |         callback(errorResp);\n 183 |         return;\n 184 |     }\n 185 | \n 186 |     std::string ssePayload;\n 187 |     ChatSseSink sseSink(\n 188 |         [&ssePayload](const std::string& chunk) {\n 189 |             ssePayload += chunk;\n 190 |             return true;\n 191 |         },\n 192 |         []() {},\n 193 |         genReq.model\n 194 |     );\n 195 | \n 196 |     for (const auto& ev : collector.getEvents()) {\n 197 |         sseSink.onEvent(ev);\n 198 |     }\n 199 |     sseSink.onClose();\n 200 | \n 201 |     struct StreamContext {\n 202 |         size_t pos = 0;\n 203 |         time_t start_time = time(nullptr);\n 204 |         explicit StreamContext() = default;\n 205 |     };\n 206 | \n 207 |     auto shared_payload = std::make_shared<std::string>(std::move(ssePayload));\n 208 |     auto shared_context = std::make_shared<StreamContext>();\n 209 | \n 210 |     auto resp = HttpResponse::newStreamResponse(\n 211 |         [shared_payload, shared_context](char *buffer, size_t maxBytes) -> size_t {\n 212 |             try {\n 213 |                 if (time(nullptr) - shared_context->start_time > 60) {\n 214 |                     LOG_WARN << \"[API接口] 流式传输超时\";\n 215 |                     return 0;\n 216 |                 }\n 217 | \n 218 |                 if (shared_context->pos >= shared_payload->size()) {\n 219 |                     return 0;\n 220 |                 }\n 221 | \n 222 |                 size_t remaining = shared_payload->size() - shared_context->pos;\n 223 |                 size_t to_send = std::min(remaining, maxBytes);\n 224 |                 memcpy(buffer, shared_payload->data() + shared_context->pos, to_send);\n 225 |                 shared_context->pos += to_send;\n 226 |                 return to_send;\n 227 |             } catch (const std::exception& e) {\n 228 |                 LOG_ERROR << \"[API接口] 流式响应错误: \" << e.what();\n 229 |                 return 0;\n 230 |             }\n 231 |         }\n 232 |     );\n 233 | \n 234 |     resp->setContentTypeString(\"text/event-stream; charset=utf-8\");\n 235 |     resp->addHeader(\"Cache-Control\", \"no-cache\");\n 236 |     resp->addHeader(\"Connection\", \"keep-alive\");\n 237 |     resp->addHeader(\"X-Accel-Buffering\", \"no\");\n 238 |     resp->addHeader(\"Keep-Alive\", \"timeout=60\");\n 239 |     callback(resp);\n 240 |     LOG_INFO << \"流式响应发送完成\";\n 241 | }\n 242 | void AiApi::chaynsapimodels(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 243 | {\n 244 |     LOG_INFO << \"[API接口] 获取模型列表\";\n 245 |     Json::Value response= ApiManager::getInstance().getApiByApiName(\"chaynsapi\")->getModels();\n 246 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n 247 |     callback(resp);\n 248 | }\n 249 | void AiApi::accountAdd(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 250 | {\n 251 |     LOG_INFO << \"[API接口] 添加账号\";\n 252 |     auto jsonPtr = req->getJsonObject();\n 253 |     if (!jsonPtr) {\n 254 |         Json::Value error;\n 255 |         error[\"error\"][\"message\"] = \"Invalid JSON in request body\";\n 256 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n 257 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 258 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n 259 |         callback(resp);\n 260 |         return;\n 261 |     }\n 262 | \n 263 |     Json::Value reqItems(Json::arrayValue);\n 264 |     if (jsonPtr->isObject()) {\n 265 |         reqItems.append(*jsonPtr);\n 266 |     } else if (jsonPtr->isArray()) {\n 267 |         reqItems = *jsonPtr;\n 268 |     } else {\n 269 |         Json::Value error;\n 270 |         error[\"error\"][\"message\"] = \"Request body must be a JSON object or an array of objects.\";\n 271 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n 272 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 273 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n 274 |         callback(resp);\n 275 |         return;\n 276 |     }\n 277 | \n 278 |     LOG_INFO << \"[API接口] 开始添加账号\";\n 279 |     Json::Value response;\n 280 |     list<Accountinfo_st> accountList;\n 281 |     \n 282 |     // 生成当前时间字符串\n 283 |     auto now = std::chrono::system_clock::now();\n 284 |     auto now_time_t = std::chrono::system_clock::to_time_t(now);\n 285 |     std::stringstream ss;\n 286 |     ss << std::put_time(std::localtime(&now_time_t), \"%Y-%m-%d %H:%M:%S\");\n 287 |     std::string currentTime = ss.str();\n 288 |     \n 289 |     for(auto &item:reqItems)\n 290 |     {   Accountinfo_st accountinfo;\n 291 |         accountinfo.apiName=item[\"apiname\"].asString();\n 292 |         accountinfo.userName=item[\"username\"].asString();\n 293 |         accountinfo.passwd=item[\"password\"].asString();\n 294 |         accountinfo.authToken=item[\"authtoken\"].empty()?\"\":item[\"authtoken\"].asString();\n 295 |         accountinfo.userTobitId=item[\"usertobitid\"].empty()?0:item[\"usertobitid\"].asInt();\n 296 |         accountinfo.personId=item[\"personid\"].empty()?\"\":item[\"personid\"].asString();\n 297 |         accountinfo.useCount=item[\"usecount\"].empty()?0:item[\"usecount\"].asInt();\n 298 |         accountinfo.tokenStatus=item[\"tokenstatus\"].empty()?false:item[\"tokenstatus\"].asBool();\n 299 |         accountinfo.accountStatus=item[\"accountstatus\"].empty()?false:item[\"accountstatus\"].asBool();\n 300 |         accountinfo.accountType=item[\"accounttype\"].empty()?\"free\":item[\"accounttype\"].asString();\n 301 |         accountinfo.createTime=currentTime;\n 302 |         Json::Value responseitem;\n 303 |         responseitem[\"apiname\"]=accountinfo.apiName;\n 304 |         responseitem[\"username\"]=accountinfo.userName;\n 305 |         //先添加到accountManager\n 306 |         if(AccountManager::getInstance().addAccountbyPost(accountinfo))\n 307 |         {\n 308 |             responseitem[\"status\"]=\"success\";\n 309 |             accountList.push_back(accountinfo);\n 310 |         }\n 311 |         else\n 312 |         {\n 313 |             responseitem[\"status\"]=\"failed\";\n 314 |         }\n 315 |         response.append(responseitem);\n 316 |     }\n 317 |     thread addAccountThread([accountList](){\n 318 |         for(auto &account:accountList)\n 319 |         {\n 320 |             AccountDbManager::getInstance()->addAccount(account);\n 321 |         }\n 322 |         AccountManager::getInstance().checkUpdateAccountToken();\n 323 |         // 账号添加后，只对新添加的账号更新 accountType\n 324 |         for(const auto &account : accountList)\n 325 |         {\n 326 |             auto accountMap = AccountManager::getInstance().getAccountList();\n 327 |             if (accountMap.find(account.apiName) != accountMap.end() &&\n 328 |                 accountMap[account.apiName].find(account.userName) != accountMap[account.apiName].end()) {\n 329 |                 AccountManager::getInstance().updateAccountType(accountMap[account.apiName][account.userName]);\n 330 |             }\n 331 |         }\n 332 |     });\n 333 |     addAccountThread.detach();\n 334 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n 335 |     callback(resp);\n 336 |     LOG_INFO << \"[API接口] 添加账号完成\";\n 337 | }\n 338 | void AiApi::accountInfo(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 339 | {\n 340 |     LOG_INFO << \"[API接口] 获取账号信息\";\n 341 |     auto accountList=AccountManager::getInstance().getAccountList();\n 342 |     Json::Value response(Json::arrayValue);\n 343 |     for(auto &account:accountList)\n 344 |     {\n 345 |         for(auto &userName:account.second)\n 346 |         {\n 347 |             Json::Value accountitem;\n 348 |             accountitem[\"apiname\"]=userName.second->apiName;\n 349 |             accountitem[\"username\"]=userName.second->userName;\n 350 |             accountitem[\"password\"]=userName.second->passwd;\n 351 |             accountitem[\"authtoken\"]=userName.second->authToken;\n 352 |             accountitem[\"usecount\"]=userName.second->useCount;\n 353 |             accountitem[\"tokenstatus\"]=userName.second->tokenStatus;\n 354 |             accountitem[\"accountstatus\"]=userName.second->accountStatus;\n 355 |             accountitem[\"usertobitid\"]=userName.second->userTobitId;\n 356 |             accountitem[\"personid\"]=userName.second->personId;\n 357 |             accountitem[\"createtime\"]=userName.second->createTime;\n 358 |             accountitem[\"accounttype\"]=userName.second->accountType;\n 359 |             response.append(accountitem);\n 360 |         }\n 361 |     }\n 362 |     if (response.empty()) {\n 363 |         auto resp = HttpResponse::newHttpResponse();\n 364 |         resp->setStatusCode(k200OK);\n 365 |         resp->setContentTypeCode(CT_APPLICATION_JSON);\n 366 |         resp->setBody(\"[]\");\n 367 |         callback(resp);\n 368 |     } else {\n 369 |         auto resp = HttpResponse::newHttpJsonResponse(response);\n 370 |         callback(resp);\n 371 |     }\n 372 | }\n 373 | void AiApi::accountDelete(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 374 | {\n 375 |     LOG_INFO << \"[API接口] 删除账号\";\n 376 |     auto jsonPtr = req->getJsonObject();\n 377 |     if (!jsonPtr) {\n 378 |         Json::Value error;\n 379 |         error[\"error\"][\"message\"] = \"Invalid JSON in request body\";\n 380 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n 381 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 382 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n 383 |         callback(resp);\n 384 |         return;\n 385 |     }\n 386 | \n 387 |     Json::Value reqItems(Json::arrayValue);\n 388 |     if (jsonPtr->isObject()) {\n 389 |         reqItems.append(*jsonPtr);\n 390 |     } else if (jsonPtr->isArray()) {\n 391 |         reqItems = *jsonPtr;\n 392 |     } else {\n 393 |         Json::Value error;\n 394 |         error[\"error\"][\"message\"] = \"Request body must be a JSON object or an array of objects.\";\n 395 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n 396 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 397 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n 398 |         callback(resp);\n 399 |         return;\n 400 |     }\n 401 |  \n 402 |     Json::Value response;\n 403 |     list<Accountinfo_st> accountList;\n 404 |     \n 405 |     // 在删除前获取完整账号信息（包含 authToken、passwd 等），用于上游删除\n 406 |     auto currentAccountMap = AccountManager::getInstance().getAccountList();\n 407 |     \n 408 |     for(auto &item:reqItems)\n 409 |     {\n 410 |         Accountinfo_st accountinfo;\n 411 |         Json::Value responseitem;\n 412 |         accountinfo.apiName=item[\"apiname\"].asString();\n 413 |         accountinfo.userName=item[\"username\"].asString();\n 414 |         responseitem[\"apiname\"]=accountinfo.apiName;\n 415 |         responseitem[\"username\"]=accountinfo.userName;\n 416 | \n 417 |         // 检查账号是否正在注册中，如果是则拒绝删除\n 418 |         if (AccountManager::getInstance().isAccountRegisteringByUsername(accountinfo.userName)) {\n 419 |             responseitem[\"status\"] = \"failed\";\n 420 |             responseitem[\"error\"] = \"Account is currently being registered, cannot delete\";\n 421 |             LOG_WARN << \"[API接口] 账号 \" << accountinfo.userName << \" 正在注册中，无法删除\";\n 422 |             response.append(responseitem);\n 423 |             continue;\n 424 |         }\n 425 | \n 426 |         // 在从内存删除前，获取完整的账号信息用于上游删除\n 427 |         if (currentAccountMap.find(accountinfo.apiName) != currentAccountMap.end() &&\n 428 |             currentAccountMap[accountinfo.apiName].find(accountinfo.userName) != currentAccountMap[accountinfo.apiName].end()) {\n 429 |             auto fullAccount = currentAccountMap[accountinfo.apiName][accountinfo.userName];\n 430 |             accountinfo.passwd = fullAccount->passwd;\n 431 |             accountinfo.authToken = fullAccount->authToken;\n 432 |             accountinfo.userTobitId = fullAccount->userTobitId;\n 433 |             accountinfo.personId = fullAccount->personId;\n 434 |         }\n 435 | \n 436 |         if(AccountManager::getInstance().deleteAccountbyPost(accountinfo.apiName,accountinfo.userName))\n 437 |         {\n 438 |             responseitem[\"status\"]=\"success\";\n 439 |             accountList.push_back(accountinfo);\n 440 |         }\n 441 |         else\n 442 |         {\n 443 |             responseitem[\"status\"]=\"failed\";\n 444 |         }\n 445 |         response.append(responseitem);\n 446 |     }\n 447 |     thread deleteAccountThread([accountList](){\n 448 |         for(auto &account:accountList)\n 449 |         {\n 450 |             // 先从上游删除账号\n 451 |             bool upstreamDeleted = AccountManager::getInstance().deleteUpstreamAccount(account);\n 452 |             if (upstreamDeleted) {\n 453 |                 LOG_INFO << \"[API接口] 上游账号删除成功: \" << account.userName;\n 454 |             } else {\n 455 |                 LOG_WARN << \"[API接口] 上游账号删除失败（继续删除本地数据库）: \" << account.userName;\n 456 |             }\n 457 |             // 再从本地数据库删除\n 458 |             AccountDbManager::getInstance()->deleteAccount(account.apiName,account.userName);\n 459 |         }\n 460 |         AccountManager::getInstance().loadAccount();\n 461 |         // 账号删除后，检查渠道账号数量（可能需要补充账号）\n 462 |         AccountManager::getInstance().checkChannelAccountCounts();\n 463 |     });\n 464 |     deleteAccountThread.detach();\n 465 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n 466 |     callback(resp);\n 467 |     //删除accountdbManager中的账号\n 468 | }\n 469 | void AiApi::accountDbInfo(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 470 | {\n 471 |     LOG_INFO << \"[API接口] 获取账号数据库信息\";\n 472 |     Json::Value response;\n 473 |     response[\"dbName\"]=\"aichat\";\n 474 |     response[\"tableName\"]=\"account\";\n 475 |     for(auto &account:AccountDbManager::getInstance()->getAccountDBList())\n 476 |     {\n 477 |         Json::Value accountitem;\n 478 |         accountitem[\"apiname\"]=account.apiName;\n 479 |         accountitem[\"username\"]=account.userName;\n 480 |         accountitem[\"password\"]=account.passwd;\n 481 |         accountitem[\"authtoken\"]=account.authToken;\n 482 |         accountitem[\"usecount\"]=account.useCount;\n 483 |         accountitem[\"tokenstatus\"]=account.tokenStatus;\n 484 |         accountitem[\"accountstatus\"]=account.accountStatus;\n 485 |         accountitem[\"usertobitid\"]=account.userTobitId;\n 486 |         accountitem[\"personid\"]=account.personId;\n 487 |         accountitem[\"createtime\"]=account.createTime;\n 488 |         accountitem[\"accounttype\"]=account.accountType;\n 489 |         response.append(accountitem);\n 490 |     }\n 491 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n 492 |     callback(resp);\n 493 | }\n 494 | \n 495 | // 渠道管理接口实现\n 496 | void AiApi::channelAdd(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 497 | {\n 498 |     LOG_INFO << \"[API接口] 添加渠道\";\n 499 |     auto jsonPtr = req->getJsonObject();\n 500 |     if (!jsonPtr) {\n 501 |         Json::Value error;\n 502 |         error[\"error\"][\"message\"] = \"Invalid JSON in request body\";\n 503 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n 504 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 505 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n 506 |         callback(resp);\n 507 |         return;\n 508 |     }\n 509 | \n 510 |     try {\n 511 |         Json::Value response;\n 512 |         \n 513 |         for (auto &reqBody : *jsonPtr)\n 514 |         {\n 515 |             Channelinfo_st channelInfo;\n 516 |             channelInfo.channelName = reqBody[\"channelname\"].asString();\n 517 |             channelInfo.channelType = reqBody[\"channeltype\"].asString();\n 518 |             channelInfo.channelUrl = reqBody[\"channelurl\"].asString();\n 519 |             channelInfo.channelKey = reqBody[\"channelkey\"].asString();\n 520 |             channelInfo.channelStatus = reqBody[\"channelstatus\"].empty() ? true : reqBody[\"channelstatus\"].asBool();\n 521 |             channelInfo.maxConcurrent = reqBody[\"maxconcurrent\"].empty() ? 10 : reqBody[\"maxconcurrent\"].asInt();\n 522 |             channelInfo.timeout = reqBody[\"timeout\"].empty() ? 30 : reqBody[\"timeout\"].asInt();\n 523 |             channelInfo.priority = reqBody[\"priority\"].empty() ? 0 : reqBody[\"priority\"].asInt();\n 524 |             channelInfo.description = reqBody[\"description\"].empty() ? \"\" : reqBody[\"description\"].asString();\n 525 |             channelInfo.accountCount = reqBody[\"accountcount\"].empty() ? 0 : reqBody[\"accountcount\"].asInt();\n 526 |             channelInfo.supportsToolCalls = reqBody[\"supports_tool_calls\"].empty() ? false : reqBody[\"supports_tool_calls\"].asBool();\n 527 |             \n 528 |             Json::Value responseItem;\n 529 |             responseItem[\"channelname\"] = channelInfo.channelName;\n 530 | \n 531 |             if (ChannelManager::getInstance().addChannel(channelInfo)) {\n 532 |                 responseItem[\"status\"] = \"success\";\n 533 |                 responseItem[\"message\"] = \"Channel added successfully\";\n 534 |             } else {\n 535 |                 responseItem[\"status\"] = \"failed\";\n 536 |                 responseItem[\"message\"] = \"Failed to add channel\";\n 537 |             }\n 538 |             response.append(responseItem);\n 539 |         }\n 540 |         \n 541 |         // 渠道添加后，异步检查渠道账号数量\n 542 |         std::thread([](){\n 543 |             AccountManager::getInstance().checkChannelAccountCounts();\n 544 |         }).detach();\n 545 |         \n 546 |         auto resp = HttpResponse::newHttpJsonResponse(response);\n 547 |         callback(resp);\n 548 |         LOG_INFO << \"[API接口] 添加渠道完成\";\n 549 |     } catch (const std::exception& e) {\n 550 |         LOG_ERROR << \"[API接口] 添加渠道错误: \" << e.what();\n 551 |         Json::Value error;\n 552 |         error[\"error\"][\"message\"] = std::string(\"Database error: \") + e.what();\n 553 |         error[\"error\"][\"type\"] = \"database_error\";\n 554 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 555 |         resp->setStatusCode(HttpStatusCode::k500InternalServerError);\n 556 |         callback(resp);\n 557 |     }\n 558 | }\n 559 | \n 560 | void AiApi::channelInfo(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 561 | {\n 562 |     LOG_INFO << \"[API接口] 获取渠道信息\";\n 563 |     \n 564 |     try {\n 565 |         auto channelList = ChannelManager::getInstance().getChannelList();\n 566 |         Json::Value response(Json::arrayValue);\n 567 |         \n 568 |         for (auto &channel : channelList) {\n 569 |             Json::Value channelItem;\n 570 |             channelItem[\"id\"] = channel.id;\n 571 |             channelItem[\"channelname\"] = channel.channelName;\n 572 |             channelItem[\"channeltype\"] = channel.channelType;\n 573 |             channelItem[\"channelurl\"] = channel.channelUrl;\n 574 |             channelItem[\"channelkey\"] = channel.channelKey;\n 575 |             channelItem[\"channelstatus\"] = channel.channelStatus;\n 576 |             channelItem[\"maxconcurrent\"] = channel.maxConcurrent;\n 577 |             channelItem[\"timeout\"] = channel.timeout;\n 578 |             channelItem[\"priority\"] = channel.priority;\n 579 |             channelItem[\"description\"] = channel.description;\n 580 |             channelItem[\"createtime\"] = channel.createTime;\n 581 |             channelItem[\"updatetime\"] = channel.updateTime;\n 582 |             channelItem[\"accountcount\"] = channel.accountCount;\n 583 |             channelItem[\"supports_tool_calls\"] = channel.supportsToolCalls;\n 584 |             response.append(channelItem);\n 585 |         }\n 586 |         \n 587 |         auto resp = HttpResponse::newHttpJsonResponse(response);\n 588 |         callback(resp);\n 589 |     } catch (const std::exception& e) {\n 590 |         LOG_ERROR << \"[API接口] 获取渠道信息错误: \" << e.what();\n 591 |         Json::Value error;\n 592 |         error[\"error\"][\"message\"] = std::string(\"Database error: \") + e.what();\n 593 |         error[\"error\"][\"type\"] = \"database_error\";\n 594 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 595 |         resp->setStatusCode(HttpStatusCode::k500InternalServerError);\n 596 |         callback(resp);\n 597 |     }\n 598 | }\n 599 | \n 600 | void AiApi::channelDelete(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 601 | {\n 602 |     LOG_INFO << \"[API接口] 删除渠道\";\n 603 |     auto jsonPtr = req->getJsonObject();\n 604 |     if (!jsonPtr) {\n 605 |         Json::Value error;\n 606 |         error[\"error\"][\"message\"] = \"Invalid JSON in request body\";\n 607 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n 608 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 609 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n 610 |         callback(resp);\n 611 |         return;\n 612 |     }\n 613 |     \n 614 |     try {\n 615 |         Json::Value response;\n 616 |         \n 617 |         for (auto &reqBody : *jsonPtr)\n 618 |         {\n 619 |             int channelId = reqBody[\"id\"].asInt();\n 620 |             \n 621 |             Json::Value responseItem;\n 622 |             responseItem[\"id\"] = channelId;\n 623 | \n 624 |             if (ChannelManager::getInstance().deleteChannel(channelId)) {\n 625 |                 responseItem[\"status\"] = \"success\";\n 626 |                 responseItem[\"message\"] = \"Channel deleted successfully\";\n 627 |             } else {\n 628 |                 responseItem[\"status\"] = \"failed\";\n 629 |                 responseItem[\"message\"] = \"Failed to delete channel\";\n 630 |             }\n 631 |             response.append(responseItem);\n 632 |         }\n 633 |         \n 634 |         // 渠道删除后不需要更新 accountType\n 635 |         \n 636 |         auto resp = HttpResponse::newHttpJsonResponse(response);\n 637 |         callback(resp);\n 638 |     } catch (const std::exception& e) {\n 639 |         LOG_ERROR << \"[API接口] 删除渠道错误: \" << e.what();\n 640 |         Json::Value error;\n 641 |         error[\"error\"][\"message\"] = std::string(\"Database error: \") + e.what();\n 642 |         error[\"error\"][\"type\"] = \"database_error\";\n 643 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 644 |         resp->setStatusCode(HttpStatusCode::k500InternalServerError);\n 645 |         callback(resp);\n 646 |     }\n 647 | }\n 648 | \n 649 | void AiApi::channelUpdate(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 650 | {\n 651 |     LOG_INFO << \"[API接口] 更新渠道\";\n 652 |     auto jsonPtr = req->getJsonObject();\n 653 |     if (!jsonPtr) {\n 654 |         Json::Value error;\n 655 |         error[\"error\"][\"message\"] = \"Invalid JSON in request body\";\n 656 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n 657 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 658 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n 659 |         callback(resp);\n 660 |         return;\n 661 |     }\n 662 | \n 663 | try {\n 664 |         auto& reqBody = *jsonPtr;\n 665 |         Json::Value response;\n 666 | \n 667 | // 解析渠道信息\n 668 |         Channelinfo_st channelInfo;\n 669 |         channelInfo.id = reqBody[\"id\"].asInt();\n 670 |         channelInfo.channelName = reqBody[\"channelname\"].asString();\n 671 |         channelInfo.channelType = reqBody[\"channeltype\"].asString();\n 672 |         channelInfo.channelUrl = reqBody[\"channelurl\"].asString();\n 673 |         channelInfo.channelKey = reqBody[\"channelkey\"].asString();\n 674 |         channelInfo.channelStatus = reqBody[\"channelstatus\"].asBool();\n 675 |         channelInfo.maxConcurrent = reqBody[\"maxconcurrent\"].asInt();\n 676 |         channelInfo.timeout = reqBody[\"timeout\"].asInt();\n 677 |         channelInfo.priority = reqBody[\"priority\"].asInt();\n 678 |         channelInfo.description = reqBody[\"description\"].empty() ? \"\" : reqBody[\"description\"].asString();\n 679 |         channelInfo.accountCount = reqBody[\"accountcount\"].asInt();\n 680 |         channelInfo.supportsToolCalls = reqBody[\"supports_tool_calls\"].empty() ? false : reqBody[\"supports_tool_calls\"].asBool();\n 681 | \n 682 | // 更新数据库\n 683 |         if (ChannelManager::getInstance().updateChannel(channelInfo)) {\n 684 |             response[\"status\"] = \"success\";\n 685 |             response[\"message\"] = \"Channel updated successfully\";\n 686 |             response[\"id\"] = channelInfo.id;\n 687 |             \n 688 |             // 渠道更新后，异步检查渠道账号数量\n 689 |             std::thread([](){\n 690 |                 AccountManager::getInstance().checkChannelAccountCounts();\n 691 |             }).detach();\n 692 |         } else {\n 693 |             response[\"status\"] = \"failed\";\n 694 |             response[\"message\"] = \"Failed to update channel\";\n 695 |         }\n 696 | \n 697 | auto resp = HttpResponse::newHttpJsonResponse(response);\n 698 |         callback(resp);\n 699 |         LOG_INFO << \"[API接口] 更新渠道完成\";\n 700 |     } catch (const std::exception& e) {\n 701 |         LOG_ERROR << \"[API接口] 更新渠道错误: \" << e.what();\n 702 |         Json::Value error;\n 703 |         error[\"error\"][\"message\"] = std::string(\"Database error: \") + e.what();\n 704 |         error[\"error\"][\"type\"] = \"database_error\";\n 705 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 706 |         resp->setStatusCode(HttpStatusCode::k500InternalServerError);\n 707 |         callback(resp);\n 708 |     }\n 709 | }\n 710 | \n 711 | void AiApi::accountUpdate(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 712 | {\n 713 |     LOG_INFO << \"[API接口] 更新账号\";\n 714 |     auto jsonPtr = req->getJsonObject();\n 715 |     if (!jsonPtr) {\n 716 |         Json::Value error;\n 717 |         error[\"error\"][\"message\"] = \"Invalid JSON in request body\";\n 718 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n 719 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 720 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n 721 |         callback(resp);\n 722 |         return;\n 723 |     }\n 724 | \n 725 |     Json::Value reqItems(Json::arrayValue);\n 726 |     if (jsonPtr->isObject()) {\n 727 |         reqItems.append(*jsonPtr);\n 728 |     } else if (jsonPtr->isArray()) {\n 729 |         reqItems = *jsonPtr;\n 730 |     } else {\n 731 |         Json::Value error;\n 732 |         error[\"error\"][\"message\"] = \"Request body must be a JSON object or an array of objects.\";\n 733 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n 734 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 735 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n 736 |         callback(resp);\n 737 |         return;\n 738 |     }\n 739 | \n 740 |     Json::Value response;\n 741 |     list<Accountinfo_st> accountList;\n 742 |     \n 743 |     for(auto &item:reqItems)\n 744 |     {   \n 745 |         Accountinfo_st accountinfo;\n 746 |         accountinfo.apiName=item[\"apiname\"].asString();\n 747 |         accountinfo.userName=item[\"username\"].asString();\n 748 |         accountinfo.passwd=item[\"password\"].asString();\n 749 |         accountinfo.authToken=item[\"authtoken\"].empty()?\"\":item[\"authtoken\"].asString();\n 750 |         accountinfo.userTobitId=item[\"usertobitid\"].empty()?0:item[\"usertobitid\"].asInt();\n 751 |         accountinfo.personId=item[\"personid\"].empty()?\"\":item[\"personid\"].asString();\n 752 |         accountinfo.useCount=item[\"usecount\"].empty()?0:item[\"usecount\"].asInt();\n 753 |         accountinfo.tokenStatus=item[\"tokenstatus\"].empty()?false:item[\"tokenstatus\"].asBool();\n 754 |         accountinfo.accountStatus=item[\"accountstatus\"].empty()?false:item[\"accountstatus\"].asBool();\n 755 |         accountinfo.accountType=item[\"accounttype\"].empty()?\"free\":item[\"accounttype\"].asString();\n 756 | \n 757 |         Json::Value responseitem;\n 758 |         responseitem[\"apiname\"]=accountinfo.apiName;\n 759 |         responseitem[\"username\"]=accountinfo.userName;\n 760 |         \n 761 |         if(AccountManager::getInstance().updateAccount(accountinfo))\n 762 |         {\n 763 |             responseitem[\"status\"]=\"success\";\n 764 |             accountList.push_back(accountinfo);\n 765 |         }\n 766 |         else\n 767 |         {\n 768 |             responseitem[\"status\"]=\"failed\";\n 769 |             responseitem[\"message\"]=\"Account not found\";\n 770 |         }\n 771 |         response.append(responseitem);\n 772 |     }\n 773 | \n 774 |     thread updateAccountThread([accountList](){\n 775 |         for(auto &account:accountList)\n 776 |         {\n 777 |             AccountDbManager::getInstance()->updateAccount(account);\n 778 |         }\n 779 |         // 账号更新后，只对操作的账号更新 accountType\n 780 |         for(const auto &account : accountList)\n 781 |         {\n 782 |             auto accountMap = AccountManager::getInstance().getAccountList();\n 783 |             if (accountMap.find(account.apiName) != accountMap.end() &&\n 784 |                 accountMap[account.apiName].find(account.userName) != accountMap[account.apiName].end()) {\n 785 |                 AccountManager::getInstance().updateAccountType(accountMap[account.apiName][account.userName]);\n 786 |             }\n 787 |         }\n 788 |     });\n 789 |     updateAccountThread.detach();\n 790 | \n 791 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n 792 |     callback(resp);\n 793 |     LOG_INFO << \"[API接口] 更新账号完成\";\n 794 | }\n 795 | \n 796 | void AiApi::accountRefresh(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 797 | {\n 798 |     LOG_INFO << \"[API接口] 刷新账号状态（token有效性+账号类型）\";\n 799 | \n 800 |     Json::Value response;\n 801 |     response[\"status\"] = \"started\";\n 802 |     response[\"message\"] = \"Account status refresh started in background\";\n 803 | \n 804 |     // 异步执行刷新操作\n 805 |     std::thread([](){\n 806 |         LOG_INFO << \"[API接口] 后台刷新：开始检查 token 有效性\";\n 807 |         AccountManager::getInstance().checkToken();\n 808 |         LOG_INFO << \"[API接口] 后台刷新：开始更新账号类型\";\n 809 |         AccountManager::getInstance().updateAllAccountTypes();\n 810 |         LOG_INFO << \"[API接口] 后台刷新：刷新完成\";\n 811 |     }).detach();\n 812 | \n 813 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n 814 |     resp->setStatusCode(k200OK);\n 815 |     callback(resp);\n 816 | }\n 817 | \n 818 | void AiApi::accountAutoRegister(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 819 | {\n 820 |     LOG_INFO << \"[API接口] 自动注册账号\";\n 821 |     auto jsonPtr = req->getJsonObject();\n 822 |     if (!jsonPtr) {\n 823 |         Json::Value error;\n 824 |         error[\"error\"][\"message\"] = \"Invalid JSON in request body\";\n 825 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n 826 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 827 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n 828 |         callback(resp);\n 829 |         return;\n 830 |     }\n 831 | \n 832 |     auto& reqBody = *jsonPtr;\n 833 |     std::string apiName = reqBody.get(\"apiname\", \"chaynsapi\").asString();\n 834 |     int count = reqBody.get(\"count\", 1).asInt();\n 835 | \n 836 |     // 限制一次最多注册 20 个\n 837 |     if (count < 1) count = 1;\n 838 |     if (count > 20) count = 20;\n 839 | \n 840 |     LOG_INFO << \"[API接口] 自动注册: apiName=\" << apiName << \", count=\" << count;\n 841 | \n 842 |     Json::Value response;\n 843 |     response[\"status\"] = \"started\";\n 844 |     response[\"message\"] = \"Auto registration started in background\";\n 845 |     response[\"apiname\"] = apiName;\n 846 |     response[\"count\"] = count;\n 847 | \n 848 |     // 异步执行注册操作\n 849 |     std::thread([apiName, count](){\n 850 |         LOG_INFO << \"[API接口] 后台注册：开始为 \" << apiName << \" 注册 \" << count << \" 个账号\";\n 851 |         for (int i = 0; i < count; ++i) {\n 852 |             LOG_INFO << \"[API接口] 后台注册：正在注册第 \" << (i + 1) << \"/\" << count << \" 个账号\";\n 853 |             AccountManager::getInstance().autoRegisterAccount(apiName);\n 854 |             // 注册间隔 5 秒，避免过快\n 855 |             if (i < count - 1) {\n 856 |                 std::this_thread::sleep_for(std::chrono::seconds(5));\n 857 |             }\n 858 |         }\n 859 |         LOG_INFO << \"[API接口] 后台注册：注册完成\";\n 860 |     }).detach();\n 861 | \n 862 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n 863 |     resp->setStatusCode(k200OK);\n 864 |     callback(resp);\n 865 | }\n 866 | \n 867 | void AiApi::channelUpdateStatus(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 868 | {\n 869 |     LOG_INFO << \"[API接口] 更新渠道状态\";\n 870 |     auto jsonPtr = req->getJsonObject();\n 871 |     if (!jsonPtr) {\n 872 |         Json::Value error;\n 873 |         error[\"error\"][\"message\"] = \"Invalid JSON in request body\";\n 874 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n 875 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 876 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n 877 |         callback(resp);\n 878 |         return;\n 879 |     }\n 880 | \n 881 |     try {\n 882 |         std::string channelName = (*jsonPtr)[\"channelname\"].asString();\n 883 |         bool status = (*jsonPtr)[\"status\"].asBool();\n 884 |         \n 885 |         Json::Value response;\n 886 |         if (ChannelManager::getInstance().updateChannelStatus(channelName, status)) {\n 887 |             response[\"status\"] = \"success\";\n 888 |             response[\"message\"] = \"Channel status updated successfully\";\n 889 |         } else {\n 890 |             response[\"status\"] = \"failed\";\n 891 |             response[\"message\"] = \"Failed to update channel status\";\n 892 |         }\n 893 |         \n 894 |         auto resp = HttpResponse::newHttpJsonResponse(response);\n 895 |         callback(resp);\n 896 |     } catch (const std::exception& e) {\n 897 |         LOG_ERROR << \"[API接口] 更新渠道状态错误: \" << e.what();\n 898 |         Json::Value error;\n 899 |         error[\"error\"][\"message\"] = std::string(\"Error: \") + e.what();\n 900 |         error[\"error\"][\"type\"] = \"internal_error\";\n 901 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 902 |         resp->setStatusCode(HttpStatusCode::k500InternalServerError);\n 903 |         callback(resp);\n 904 |     }\n 905 | }\n 906 | \n 907 | // ===========================================================\n 908 | // OpenAI Responses API 兼容实现\n 909 | // ===========================================================\n 910 | // 响应存储已迁移到 Session 层统一管理\n 911 | \n 912 | void AiApi::responsesCreate(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n 913 | {\n 914 |     LOG_INFO << \"[API接口] 创建响应 - OpenAI Responses API\";\n 915 |     \n 916 |     // 打印请求头\n 917 |     LOG_DEBUG << \"请求头:\";\n 918 |     for(auto &header : req->getHeaders()) {\n 919 |         LOG_DEBUG << header.first << \":\" << header.second;\n 920 |     }\n 921 |     LOG_DEBUG << \"请求体:\" << req->getBody();\n 922 | \n 923 |     auto jsonPtr = req->getJsonObject();\n 924 |     if (!jsonPtr) {\n 925 |         Json::Value error;\n 926 |         error[\"error\"][\"message\"] = \"Invalid JSON in request body\";\n 927 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n 928 |         error[\"error\"][\"code\"] = \"invalid_json\";\n 929 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 930 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n 931 |         callback(resp);\n 932 |         return;\n 933 |     }\n 934 |     \n 935 |     auto& reqBody = *jsonPtr;\n 936 |     const bool stream = reqBody.get(\"stream\", false).asBool();\n 937 | \n 938 |     // 使用 RequestAdapters 构建 GenerationRequest\n 939 |     LOG_INFO << \"[API接口] 使用 RequestAdapters 构建 GenerationRequest\";\n 940 |     GenerationRequest genReq = RequestAdapters::buildGenerationRequestFromResponses(req);\n 941 | \n 942 |     // 验证输入不为空\n 943 |     if (genReq.currentInput.empty() && genReq.messages.empty()) {\n 944 |         Json::Value error;\n 945 |         error[\"error\"][\"message\"] = \"Input cannot be empty\";\n 946 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n 947 |         error[\"error\"][\"code\"] = \"missing_input\";\n 948 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n 949 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n 950 |         callback(resp);\n 951 |         return;\n 952 |     }\n 953 | \n 954 |     // ========== 非流式：ResponsesJsonSink ==========\n 955 |     if (!stream) {\n 956 |         LOG_INFO << \"Responses API 非流式请求 - 使用 GenerationService::runGuarded() + ResponsesJsonSink\";\n 957 | \n 958 |         HttpResponsePtr jsonResp;\n 959 |         int httpStatus = 200;\n 960 | \n 961 |         ResponsesJsonSink jsonSink(\n 962 |             [&jsonResp, &httpStatus](const Json::Value& builtResponse, int status) {\n 963 |                 // 成功时存储 response JSON（用于 GET /responses/{id}）\n 964 |                 if (status == 200 && !builtResponse.isMember(\"error\") &&\n 965 |                     builtResponse.isMember(\"id\") && builtResponse[\"id\"].isString()) {\n 966 |                     ResponseIndex::instance().storeResponse(builtResponse[\"id\"].asString(), builtResponse);\n 967 |                 }\n 968 | \n 969 |                 jsonResp = HttpResponse::newHttpJsonResponse(builtResponse);\n 970 |                 httpStatus = status;\n 971 |             },\n 972 |             genReq.model,\n 973 |             static_cast<int>(genReq.currentInput.length() / 4)\n 974 |         );\n 975 | \n 976 |         GenerationService genService;\n 977 |         auto gateErr = genService.runGuarded(\n 978 |             genReq, jsonSink,\n 979 |             session::ConcurrencyPolicy::RejectConcurrent\n 980 |         );\n 981 | \n 982 |         if (gateErr.has_value()) {\n 983 |             Json::Value errorJson;\n 984 |             errorJson[\"error\"][\"message\"] = gateErr->message;\n 985 |             errorJson[\"error\"][\"type\"] = gateErr->type();\n 986 |             errorJson[\"error\"][\"code\"] = \"concurrent_request\";\n 987 |             auto errorResp = HttpResponse::newHttpJsonResponse(errorJson);\n 988 |             errorResp->setStatusCode(static_cast<HttpStatusCode>(gateErr->httpStatus()));\n 989 |             callback(errorResp);\n 990 |             return;\n 991 |         }\n 992 | \n 993 |         if (jsonResp) {\n 994 |             jsonResp->setStatusCode(static_cast<HttpStatusCode>(httpStatus));\n 995 |             jsonResp->setContentTypeString(\"application/json; charset=utf-8\");\n 996 |             callback(jsonResp);\n 997 |         } else {\n 998 |             Json::Value error;\n 999 |             error[\"error\"][\"message\"] = \"Failed to generate response\";\n1000 |             error[\"error\"][\"type\"] = \"internal_error\";\n1001 |             auto errorResp = HttpResponse::newHttpJsonResponse(error);\n1002 |             errorResp->setStatusCode(k500InternalServerError);\n1003 |             callback(errorResp);\n1004 |         }\n1005 | \n1006 |         return;\n1007 |     }\n1008 | \n1009 |     // ========== 流式：CollectorSink + ResponsesSseSink ==========\n1010 |     LOG_INFO << \"Responses API 流式请求 - 使用 GenerationService::runGuarded() + ResponsesSseSink\";\n1011 | \n1012 |     CollectorSink collector;\n1013 |     GenerationService genService;\n1014 |     auto gateErr = genService.runGuarded(\n1015 |         genReq, collector,\n1016 |         session::ConcurrencyPolicy::RejectConcurrent\n1017 |     );\n1018 | \n1019 |     if (gateErr.has_value()) {\n1020 |         Json::Value errorJson;\n1021 |         errorJson[\"error\"][\"message\"] = gateErr->message;\n1022 |         errorJson[\"error\"][\"type\"] = gateErr->type();\n1023 |         errorJson[\"error\"][\"code\"] = \"concurrent_request\";\n1024 |         auto errorResp = HttpResponse::newHttpJsonResponse(errorJson);\n1025 |         errorResp->setStatusCode(static_cast<HttpStatusCode>(gateErr->httpStatus()));\n1026 |         callback(errorResp);\n1027 |         return;\n1028 |     }\n1029 | \n1030 |     if (collector.hasError()) {\n1031 |         auto error = collector.getError();\n1032 |         Json::Value errorResp;\n1033 |         errorResp[\"error\"][\"message\"] = error ? error->message : \"Internal error\";\n1034 |         errorResp[\"error\"][\"type\"] = \"api_error\";\n1035 |         auto resp = HttpResponse::newHttpJsonResponse(errorResp);\n1036 |         resp->setStatusCode(HttpStatusCode::k500InternalServerError);\n1037 |         callback(resp);\n1038 |         return;\n1039 |     }\n1040 | \n1041 |     // 将 Collector 事件复放到 ResponsesJsonSink 构建一份 JSON（用于 GET /responses/{id} 存储）\n1042 |     Json::Value builtResponse;\n1043 |     int builtStatus = 200;\n1044 |     {\n1045 |         ResponsesJsonSink jsonBuilder(\n1046 |             [&builtResponse, &builtStatus](const Json::Value& resp, int status) {\n1047 |                 builtResponse = resp;\n1048 |                 builtStatus = status;\n1049 |             },\n1050 |             genReq.model,\n1051 |             static_cast<int>(genReq.currentInput.length() / 4)\n1052 |         );\n1053 |         for (const auto& ev : collector.getEvents()) {\n1054 |             jsonBuilder.onEvent(ev);\n1055 |         }\n1056 |         jsonBuilder.onClose();\n1057 |     }\n1058 | \n1059 |     if (builtStatus == 200 && !builtResponse.isMember(\"error\") &&\n1060 |         builtResponse.isMember(\"id\") && builtResponse[\"id\"].isString()) {\n1061 |         ResponseIndex::instance().storeResponse(builtResponse[\"id\"].asString(), builtResponse);\n1062 |     }\n1063 | \n1064 |     // SSE 输出（复放事件给 ResponsesSseSink）\n1065 |     std::string ssePayload;\n1066 | \n1067 |     ResponsesSseSink sseSink(\n1068 |         [&ssePayload](const std::string& chunk) {\n1069 |             ssePayload += chunk;\n1070 |             return true;\n1071 |         },\n1072 |         []() {},\n1073 |         genReq.model\n1074 |     );\n1075 | \n1076 |     for (const auto& ev : collector.getEvents()) {\n1077 |         sseSink.onEvent(ev);\n1078 |     }\n1079 |     sseSink.onClose();\n1080 | \n1081 |     struct StreamContext {\n1082 |         size_t pos = 0;\n1083 |         time_t start_time = time(nullptr);\n1084 |         explicit StreamContext() = default;\n1085 |     };\n1086 | \n1087 |     auto shared_payload = std::make_shared<std::string>(std::move(ssePayload));\n1088 |     auto shared_context = std::make_shared<StreamContext>();\n1089 | \n1090 |     auto resp = HttpResponse::newStreamResponse(\n1091 |         [shared_payload, shared_context](char *buffer, size_t maxBytes) -> size_t {\n1092 |             try {\n1093 |                 if (time(nullptr) - shared_context->start_time > 60) {\n1094 |                     LOG_WARN << \"[API接口] Responses SSE 流式传输超时\";\n1095 |                     return 0;\n1096 |                 }\n1097 | \n1098 |                 if (shared_context->pos >= shared_payload->size()) {\n1099 |                     return 0;\n1100 |                 }\n1101 | \n1102 |                 size_t remaining = shared_payload->size() - shared_context->pos;\n1103 |                 size_t to_send = std::min(remaining, maxBytes);\n1104 |                 memcpy(buffer, shared_payload->data() + shared_context->pos, to_send);\n1105 |                 shared_context->pos += to_send;\n1106 |                 return to_send;\n1107 |             } catch (const std::exception& e) {\n1108 |                 LOG_ERROR << \"[API接口] Responses SSE 流式响应错误: \" << e.what();\n1109 |                 return 0;\n1110 |             }\n1111 |         }\n1112 |     );\n1113 | \n1114 |     resp->setContentTypeString(\"text/event-stream; charset=utf-8\");\n1115 |     resp->addHeader(\"Cache-Control\", \"no-cache\");\n1116 |     resp->addHeader(\"Connection\", \"keep-alive\");\n1117 |     resp->addHeader(\"X-Accel-Buffering\", \"no\");\n1118 |     resp->addHeader(\"Keep-Alive\", \"timeout=60\");\n1119 |     callback(resp);\n1120 | }\n1121 | \n1122 | void AiApi::responsesGet(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback, std::string response_id)\n1123 | {\n1124 |     LOG_INFO << \"[API接口] 获取响应 - 响应ID: \" << response_id;\n1125 | \n1126 |     Json::Value stored;\n1127 |     if (!ResponseIndex::instance().tryGetResponse(response_id, stored)) {\n1128 |         Json::Value error;\n1129 |         error[\"error\"][\"message\"] = \"Response not found\";\n1130 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n1131 |         error[\"error\"][\"code\"] = \"response_not_found\";\n1132 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n1133 |         resp->setStatusCode(HttpStatusCode::k404NotFound);\n1134 |         callback(resp);\n1135 |         return;\n1136 |     }\n1137 | \n1138 |     auto resp = HttpResponse::newHttpJsonResponse(stored);\n1139 |     resp->setStatusCode(k200OK);\n1140 |     callback(resp);\n1141 | }\n1142 | \n1143 | void AiApi::responsesDelete(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback, std::string response_id)\n1144 | {\n1145 |     LOG_INFO << \"[API接口] 删除响应 - 响应ID: \" << response_id;\n1146 | \n1147 |     if (!ResponseIndex::instance().erase(response_id)) {\n1148 |         Json::Value error;\n1149 |         error[\"error\"][\"message\"] = \"Response not found\";\n1150 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n1151 |         error[\"error\"][\"code\"] = \"response_not_found\";\n1152 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n1153 |         resp->setStatusCode(HttpStatusCode::k404NotFound);\n1154 |         callback(resp);\n1155 |         return;\n1156 |     }\n1157 |     \n1158 |     Json::Value response;\n1159 |     response[\"id\"] = response_id;\n1160 |     response[\"object\"] = \"response\";\n1161 |     response[\"deleted\"] = true;\n1162 |     \n1163 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n1164 |     resp->setStatusCode(k200OK);\n1165 |     callback(resp);\n1166 |     \n1167 |     LOG_INFO << \"[API接口] 删除响应完成, 响应ID: \" << response_id;\n1168 | }\n1169 | \n1170 | // ========== 错误统计 API ==========\n1171 | \n1172 | void AiApi::getRequestsSeries(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n1173 | {\n1174 |     LOG_INFO << \"[API接口] 获取请求时序统计\";\n1175 |     \n1176 |     // 解析查询参数\n1177 |     std::string from = req->getParameter(\"from\");\n1178 |     std::string to = req->getParameter(\"to\");\n1179 |     \n1180 |     // 默认时间范围：最近 24 小时\n1181 |     if (from.empty() || to.empty()) {\n1182 |         auto now = std::chrono::system_clock::now();\n1183 |         auto yesterday = now - std::chrono::hours(24);\n1184 |         \n1185 |         auto formatTime = [](std::chrono::system_clock::time_point tp) -> std::string {\n1186 |             auto tt = std::chrono::system_clock::to_time_t(tp);\n1187 |             char buf[32];\n1188 |             std::strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", std::gmtime(&tt));\n1189 |             return std::string(buf);\n1190 |         };\n1191 |         \n1192 |         if (from.empty()) from = formatTime(yesterday);\n1193 |         if (to.empty()) to = formatTime(now);\n1194 |     }\n1195 |     \n1196 |     metrics::QueryParams params;\n1197 |     params.from = from;\n1198 |     params.to = to;\n1199 |     \n1200 |     auto dbManager = metrics::ErrorStatsDbManager::getInstance();\n1201 |     auto series = dbManager->queryRequestSeries(params);\n1202 |     \n1203 |     Json::Value response(Json::objectValue);\n1204 |     response[\"from\"] = from;\n1205 |     response[\"to\"] = to;\n1206 |     \n1207 |     Json::Value data(Json::arrayValue);\n1208 |     for (const auto& bucket : series) {\n1209 |         Json::Value item;\n1210 |         item[\"bucket_start\"] = bucket.bucketStart;\n1211 |         item[\"count\"] = static_cast<Json::Int64>(bucket.count);\n1212 |         data.append(item);\n1213 |     }\n1214 |     response[\"data\"] = data;\n1215 |     \n1216 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n1217 |     resp->setStatusCode(k200OK);\n1218 |     callback(resp);\n1219 | }\n1220 | \n1221 | void AiApi::getErrorsSeries(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n1222 | {\n1223 |     LOG_INFO << \"[API接口] 获取错误时序统计\";\n1224 |     \n1225 |     // 解析查询参数\n1226 |     std::string from = req->getParameter(\"from\");\n1227 |     std::string to = req->getParameter(\"to\");\n1228 |     std::string severity = req->getParameter(\"severity\");\n1229 |     std::string domain = req->getParameter(\"domain\");\n1230 |     std::string type = req->getParameter(\"type\");\n1231 |     std::string provider = req->getParameter(\"provider\");\n1232 |     std::string model = req->getParameter(\"model\");\n1233 |     std::string clientType = req->getParameter(\"client_type\");\n1234 |     \n1235 |     // 默认时间范围：最近 24 小时\n1236 |     if (from.empty() || to.empty()) {\n1237 |         auto now = std::chrono::system_clock::now();\n1238 |         auto yesterday = now - std::chrono::hours(24);\n1239 |         \n1240 |         auto formatTime = [](std::chrono::system_clock::time_point tp) -> std::string {\n1241 |             auto tt = std::chrono::system_clock::to_time_t(tp);\n1242 |             char buf[32];\n1243 |             std::strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", std::gmtime(&tt));\n1244 |             return std::string(buf);\n1245 |         };\n1246 |         \n1247 |         if (from.empty()) from = formatTime(yesterday);\n1248 |         if (to.empty()) to = formatTime(now);\n1249 |     }\n1250 |     \n1251 |     metrics::QueryParams params;\n1252 |     params.from = from;\n1253 |     params.to = to;\n1254 |     params.severity = severity;\n1255 |     params.domain = domain;\n1256 |     params.type = type;\n1257 |     params.provider = provider;\n1258 |     params.model = model;\n1259 |     params.clientType = clientType;\n1260 |     \n1261 |     auto dbManager = metrics::ErrorStatsDbManager::getInstance();\n1262 |     auto series = dbManager->queryErrorSeries(params);\n1263 |     \n1264 |     Json::Value response(Json::objectValue);\n1265 |     response[\"from\"] = from;\n1266 |     response[\"to\"] = to;\n1267 |     if (!severity.empty()) response[\"severity\"] = severity;\n1268 |     if (!domain.empty()) response[\"domain\"] = domain;\n1269 |     if (!type.empty()) response[\"type\"] = type;\n1270 |     if (!provider.empty()) response[\"provider\"] = provider;\n1271 |     if (!model.empty()) response[\"model\"] = model;\n1272 |     if (!clientType.empty()) response[\"client_type\"] = clientType;\n1273 |     \n1274 |     Json::Value data(Json::arrayValue);\n1275 |     for (const auto& bucket : series) {\n1276 |         Json::Value item;\n1277 |         item[\"bucket_start\"] = bucket.bucketStart;\n1278 |         item[\"count\"] = static_cast<Json::Int64>(bucket.count);\n1279 |         data.append(item);\n1280 |     }\n1281 |     response[\"data\"] = data;\n1282 |     \n1283 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n1284 |     resp->setStatusCode(k200OK);\n1285 |     callback(resp);\n1286 | }\n1287 | \n1288 | void AiApi::getErrorsEvents(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n1289 | {\n1290 |     LOG_INFO << \"[API接口] 获取错误事件列表\";\n1291 |     \n1292 |     // 解析查询参数\n1293 |     std::string from = req->getParameter(\"from\");\n1294 |     std::string to = req->getParameter(\"to\");\n1295 |     int limit = 100;\n1296 |     int offset = 0;\n1297 |     \n1298 |     std::string limitStr = req->getParameter(\"limit\");\n1299 |     std::string offsetStr = req->getParameter(\"offset\");\n1300 |     if (!limitStr.empty()) {\n1301 |         try { limit = std::stoi(limitStr); } catch (...) {}\n1302 |     }\n1303 |     if (!offsetStr.empty()) {\n1304 |         try { offset = std::stoi(offsetStr); } catch (...) {}\n1305 |     }\n1306 |     \n1307 |     // 限制最大返回数量\n1308 |     if (limit > 1000) limit = 1000;\n1309 |     if (limit < 1) limit = 1;\n1310 |     if (offset < 0) offset = 0;\n1311 |     \n1312 |     // 默认时间范围：最近 24 小时\n1313 |     if (from.empty() || to.empty()) {\n1314 |         auto now = std::chrono::system_clock::now();\n1315 |         auto yesterday = now - std::chrono::hours(24);\n1316 |         \n1317 |         auto formatTime = [](std::chrono::system_clock::time_point tp) -> std::string {\n1318 |             auto tt = std::chrono::system_clock::to_time_t(tp);\n1319 |             char buf[32];\n1320 |             std::strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", std::gmtime(&tt));\n1321 |             return std::string(buf);\n1322 |         };\n1323 |         \n1324 |         if (from.empty()) from = formatTime(yesterday);\n1325 |         if (to.empty()) to = formatTime(now);\n1326 |     }\n1327 |     \n1328 |     metrics::QueryParams params;\n1329 |     params.from = from;\n1330 |     params.to = to;\n1331 |     \n1332 |     auto dbManager = metrics::ErrorStatsDbManager::getInstance();\n1333 |     auto events = dbManager->queryEvents(params, limit, offset);\n1334 |     \n1335 |     Json::Value response(Json::objectValue);\n1336 |     response[\"from\"] = from;\n1337 |     response[\"to\"] = to;\n1338 |     response[\"limit\"] = limit;\n1339 |     response[\"offset\"] = offset;\n1340 |     \n1341 |     Json::Value data(Json::arrayValue);\n1342 |     for (const auto& ev : events) {\n1343 |         Json::Value item;\n1344 |         item[\"id\"] = static_cast<Json::Int64>(ev.id);\n1345 |         item[\"ts\"] = ev.ts;\n1346 |         item[\"severity\"] = ev.severity;\n1347 |         item[\"domain\"] = ev.domain;\n1348 |         item[\"type\"] = ev.type;\n1349 |         item[\"provider\"] = ev.provider;\n1350 |         item[\"model\"] = ev.model;\n1351 |         item[\"client_type\"] = ev.clientType;\n1352 |         item[\"api_kind\"] = ev.apiKind;\n1353 |         item[\"stream\"] = ev.stream;\n1354 |         item[\"http_status\"] = ev.httpStatus;\n1355 |         item[\"request_id\"] = ev.requestId;\n1356 |         item[\"message\"] = ev.message;\n1357 |         data.append(item);\n1358 |     }\n1359 |     response[\"data\"] = data;\n1360 |     response[\"count\"] = static_cast<Json::UInt64>(events.size());\n1361 |     \n1362 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n1363 |     resp->setStatusCode(k200OK);\n1364 |     callback(resp);\n1365 | }\n1366 | \n1367 | void AiApi::getErrorsEventById(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback, int64_t id)\n1368 | {\n1369 |     LOG_INFO << \"[API接口] 获取错误事件详情 - ID: \" << id;\n1370 |     \n1371 |     auto dbManager = metrics::ErrorStatsDbManager::getInstance();\n1372 |     auto eventOpt = dbManager->queryEventById(id);\n1373 |     \n1374 |     if (!eventOpt.has_value()) {\n1375 |         Json::Value error;\n1376 |         error[\"error\"][\"message\"] = \"Event not found\";\n1377 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n1378 |         error[\"error\"][\"code\"] = \"event_not_found\";\n1379 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n1380 |         resp->setStatusCode(HttpStatusCode::k404NotFound);\n1381 |         callback(resp);\n1382 |         return;\n1383 |     }\n1384 |     \n1385 |     const auto& ev = eventOpt.value();\n1386 |     \n1387 |     Json::Value response;\n1388 |     response[\"id\"] = static_cast<Json::Int64>(ev.id);\n1389 |     response[\"ts\"] = ev.ts;\n1390 |     response[\"severity\"] = ev.severity;\n1391 |     response[\"domain\"] = ev.domain;\n1392 |     response[\"type\"] = ev.type;\n1393 |     response[\"provider\"] = ev.provider;\n1394 |     response[\"model\"] = ev.model;\n1395 |     response[\"client_type\"] = ev.clientType;\n1396 |     response[\"api_kind\"] = ev.apiKind;\n1397 |     response[\"stream\"] = ev.stream;\n1398 |     response[\"http_status\"] = ev.httpStatus;\n1399 |     response[\"request_id\"] = ev.requestId;\n1400 |     response[\"message\"] = ev.message;\n1401 |     response[\"detail_json\"] = ev.detailJson;\n1402 |     response[\"raw_snippet\"] = ev.rawSnippet;\n1403 |     \n1404 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n1405 |     resp->setStatusCode(k200OK);\n1406 |     callback(resp);\n1407 | }\n1408 | \n1409 | // ========== 服务状态监控 API ==========\n1410 | \n1411 | void AiApi::getStatusSummary(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n1412 | {\n1413 |     LOG_INFO << \"[API接口] 获取服务状态概览\";\n1414 |     \n1415 |     // 解析查询参数\n1416 |     std::string from = req->getParameter(\"from\");\n1417 |     std::string to = req->getParameter(\"to\");\n1418 |     \n1419 |     metrics::StatusQueryParams params;\n1420 |     params.from = from;\n1421 |     params.to = to;\n1422 |     \n1423 |     auto statusManager = metrics::StatusDbManager::getInstance();\n1424 |     auto summary = statusManager->getStatusSummary(params);\n1425 |     \n1426 |     Json::Value response(Json::objectValue);\n1427 |     response[\"total_requests\"] = static_cast<Json::Int64>(summary.totalRequests);\n1428 |     response[\"total_errors\"] = static_cast<Json::Int64>(summary.totalErrors);\n1429 |     response[\"error_rate\"] = summary.errorRate;\n1430 |     response[\"channel_count\"] = summary.channelCount;\n1431 |     response[\"model_count\"] = summary.modelCount;\n1432 |     response[\"healthy_channels\"] = summary.healthyChannels;\n1433 |     response[\"degraded_channels\"] = summary.degradedChannels;\n1434 |     response[\"down_channels\"] = summary.downChannels;\n1435 |     response[\"overall_status\"] = metrics::StatusDbManager::statusToString(summary.overallStatus);\n1436 |     \n1437 |     // 时间序列数据\n1438 |     Json::Value buckets(Json::arrayValue);\n1439 |     for (const auto& bucket : summary.buckets) {\n1440 |         Json::Value item;\n1441 |         item[\"bucket_start\"] = bucket.bucketStart;\n1442 |         item[\"request_count\"] = static_cast<Json::Int64>(bucket.requestCount);\n1443 |         item[\"error_count\"] = static_cast<Json::Int64>(bucket.errorCount);\n1444 |         item[\"error_rate\"] = bucket.errorRate;\n1445 |         buckets.append(item);\n1446 |     }\n1447 |     response[\"buckets\"] = buckets;\n1448 |     \n1449 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n1450 |     resp->setStatusCode(k200OK);\n1451 |     callback(resp);\n1452 | }\n1453 | \n1454 | void AiApi::getStatusChannels(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n1455 | {\n1456 |     LOG_INFO << \"[API接口] 获取渠道状态列表\";\n1457 |     \n1458 |     // 解析查询参数\n1459 |     std::string from = req->getParameter(\"from\");\n1460 |     std::string to = req->getParameter(\"to\");\n1461 |     std::string provider = req->getParameter(\"provider\");\n1462 |     \n1463 |     metrics::StatusQueryParams params;\n1464 |     params.from = from;\n1465 |     params.to = to;\n1466 |     params.provider = provider;\n1467 |     \n1468 |     auto statusManager = metrics::StatusDbManager::getInstance();\n1469 |     auto channels = statusManager->getChannelStatusList(params);\n1470 |     \n1471 |     Json::Value response(Json::objectValue);\n1472 |     Json::Value data(Json::arrayValue);\n1473 |     \n1474 |     for (const auto& ch : channels) {\n1475 |         Json::Value item;\n1476 |         item[\"channel_id\"] = ch.channelId;\n1477 |         item[\"channel_name\"] = ch.channelName;\n1478 |         item[\"total_requests\"] = static_cast<Json::Int64>(ch.totalRequests);\n1479 |         item[\"total_errors\"] = static_cast<Json::Int64>(ch.totalErrors);\n1480 |         item[\"error_rate\"] = ch.errorRate;\n1481 |         item[\"status\"] = metrics::StatusDbManager::statusToString(ch.status);\n1482 |         item[\"last_request_time\"] = ch.lastRequestTime;\n1483 |         \n1484 |         // 时间序列数据\n1485 |         Json::Value buckets(Json::arrayValue);\n1486 |         for (const auto& bucket : ch.buckets) {\n1487 |             Json::Value b;\n1488 |             b[\"bucket_start\"] = bucket.bucketStart;\n1489 |             b[\"request_count\"] = static_cast<Json::Int64>(bucket.requestCount);\n1490 |             b[\"error_count\"] = static_cast<Json::Int64>(bucket.errorCount);\n1491 |             b[\"error_rate\"] = bucket.errorRate;\n1492 |             buckets.append(b);\n1493 |         }\n1494 |         item[\"buckets\"] = buckets;\n1495 |         \n1496 |         data.append(item);\n1497 |     }\n1498 |     \n1499 |     response[\"data\"] = data;\n1500 |     response[\"count\"] = static_cast<Json::UInt64>(channels.size());\n1501 |     \n1502 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n1503 |     resp->setStatusCode(k200OK);\n1504 |     callback(resp);\n1505 | }\n1506 | \n1507 | void AiApi::getStatusModels(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n1508 | {\n1509 |     LOG_INFO << \"[API接口] 获取模型状态列表\";\n1510 |     \n1511 |     // 解析查询参数\n1512 |     std::string from = req->getParameter(\"from\");\n1513 |     std::string to = req->getParameter(\"to\");\n1514 |     std::string provider = req->getParameter(\"provider\");\n1515 |     std::string model = req->getParameter(\"model\");\n1516 |     \n1517 |     metrics::StatusQueryParams params;\n1518 |     params.from = from;\n1519 |     params.to = to;\n1520 |     params.provider = provider;\n1521 |     params.model = model;\n1522 |     \n1523 |     auto statusManager = metrics::StatusDbManager::getInstance();\n1524 |     auto models = statusManager->getModelStatusList(params);\n1525 |     \n1526 |     Json::Value response(Json::objectValue);\n1527 |     Json::Value data(Json::arrayValue);\n1528 |     \n1529 |     for (const auto& m : models) {\n1530 |         Json::Value item;\n1531 |         item[\"model\"] = m.model;\n1532 |         item[\"provider\"] = m.provider;\n1533 |         item[\"total_requests\"] = static_cast<Json::Int64>(m.totalRequests);\n1534 |         item[\"total_errors\"] = static_cast<Json::Int64>(m.totalErrors);\n1535 |         item[\"error_rate\"] = m.errorRate;\n1536 |         item[\"status\"] = metrics::StatusDbManager::statusToString(m.status);\n1537 |         item[\"last_request_time\"] = m.lastRequestTime;\n1538 |         \n1539 |         // 时间序列数据\n1540 |         Json::Value buckets(Json::arrayValue);\n1541 |         for (const auto& bucket : m.buckets) {\n1542 |             Json::Value b;\n1543 |             b[\"bucket_start\"] = bucket.bucketStart;\n1544 |             b[\"request_count\"] = static_cast<Json::Int64>(bucket.requestCount);\n1545 |             b[\"error_count\"] = static_cast<Json::Int64>(bucket.errorCount);\n1546 |             b[\"error_rate\"] = bucket.errorRate;\n1547 |             buckets.append(b);\n1548 |         }\n1549 |         item[\"buckets\"] = buckets;\n1550 |         \n1551 |         data.append(item);\n1552 |     }\n1553 |     \n1554 |     response[\"data\"] = data;\n1555 |     response[\"count\"] = static_cast<Json::UInt64>(models.size());\n1556 |     \n1557 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n1558 |     resp->setStatusCode(k200OK);\n1559 |     callback(resp);\n1560 | }\n1561 | // ========== 日志查看 API ==========\n1562 | \n1563 | void AiApi::logsList(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n1564 | {\n1565 |     LOG_INFO << \"[API接口] 获取日志文件列表\";\n1566 | \n1567 |     Json::Value response(Json::arrayValue);\n1568 |     std::string logDir = \"logs\";\n1569 | \n1570 |     try {\n1571 |         for (const auto& entry : std::filesystem::directory_iterator(logDir)) {\n1572 |             if (entry.is_regular_file()) {\n1573 |                 Json::Value fileInfo;\n1574 |                 fileInfo[\"name\"] = entry.path().filename().string();\n1575 |                 fileInfo[\"size\"] = static_cast<Json::Int64>(entry.file_size());\n1576 | \n1577 |                 auto ftime = entry.last_write_time();\n1578 |                 auto sctp = std::chrono::time_point_cast<std::chrono::system_clock::duration>(\n1579 |                     ftime - std::filesystem::file_time_type::clock::now() + std::chrono::system_clock::now()\n1580 |                 );\n1581 |                 auto tt = std::chrono::system_clock::to_time_t(sctp);\n1582 |                 char buf[32];\n1583 |                 std::strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", std::localtime(&tt));\n1584 |                 fileInfo[\"modified\"] = std::string(buf);\n1585 | \n1586 |                 response.append(fileInfo);\n1587 |             }\n1588 |         }\n1589 |     } catch (const std::exception& e) {\n1590 |         LOG_ERROR << \"[API接口] 列出日志文件失败: \" << e.what();\n1591 |     }\n1592 | \n1593 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n1594 |     resp->setStatusCode(k200OK);\n1595 |     callback(resp);\n1596 | }\n1597 | \n1598 | void AiApi::logsTail(const HttpRequestPtr &req, std::function<void(const HttpResponsePtr &)> &&callback)\n1599 | {\n1600 |     LOG_INFO << \"[API接口] 读取日志尾部内容\";\n1601 | \n1602 |     std::string fileName = req->getParameter(\"file\");\n1603 |     if (fileName.empty()) fileName = \"aiapi.log\";\n1604 | \n1605 |     // 安全检查：防止路径遍历\n1606 |     if (fileName.find(\"..\") != std::string::npos || fileName.find('/') != std::string::npos || fileName.find('\\\\') != std::string::npos) {\n1607 |         Json::Value error;\n1608 |         error[\"error\"][\"message\"] = \"Invalid file name\";\n1609 |         error[\"error\"][\"type\"] = \"invalid_request_error\";\n1610 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n1611 |         resp->setStatusCode(HttpStatusCode::k400BadRequest);\n1612 |         callback(resp);\n1613 |         return;\n1614 |     }\n1615 | \n1616 |     int lines = 200;\n1617 |     std::string linesStr = req->getParameter(\"lines\");\n1618 |     if (!linesStr.empty()) {\n1619 |         try { lines = std::stoi(linesStr); } catch (...) {}\n1620 |     }\n1621 |     if (lines < 1) lines = 1;\n1622 |     if (lines > 5000) lines = 5000;\n1623 | \n1624 |     std::string keyword = req->getParameter(\"keyword\");\n1625 |     std::string level = req->getParameter(\"level\");\n1626 | \n1627 |     std::string filePath = \"logs/\" + fileName;\n1628 | \n1629 |     std::ifstream file(filePath, std::ios::ate);\n1630 |     if (!file.is_open()) {\n1631 |         Json::Value error;\n1632 |         error[\"error\"][\"message\"] = \"Log file not found: \" + fileName;\n1633 |         error[\"error\"][\"type\"] = \"not_found\";\n1634 |         auto resp = HttpResponse::newHttpJsonResponse(error);\n1635 |         resp->setStatusCode(HttpStatusCode::k404NotFound);\n1636 |         callback(resp);\n1637 |         return;\n1638 |     }\n1639 | \n1640 |     // 从文件尾部读取\n1641 |     std::streampos fileSize = file.tellg();\n1642 |     std::vector<std::string> allLines;\n1643 | \n1644 |     // 读取文件尾部足够多的内容\n1645 |     size_t bufSize = std::min(static_cast<size_t>(fileSize), static_cast<size_t>(lines * 500));\n1646 |     file.seekg(-static_cast<std::streamoff>(bufSize), std::ios::end);\n1647 | \n1648 |     std::string line;\n1649 |     // 跳过可能不完整的第一行\n1650 |     if (file.tellg() != std::streampos(0)) {\n1651 |         std::getline(file, line);\n1652 |     }\n1653 | \n1654 |     while (std::getline(file, line)) {\n1655 |         // 日志级别过滤\n1656 |         if (!level.empty() && level != \"ALL\") {\n1657 |             if (line.find(level) == std::string::npos) continue;\n1658 |         }\n1659 |         // 关键词过滤\n1660 |         if (!keyword.empty()) {\n1661 |             if (line.find(keyword) == std::string::npos) continue;\n1662 |         }\n1663 |         allLines.push_back(line);\n1664 |     }\n1665 |     file.close();\n1666 | \n1667 |     // 只保留最后 N 行\n1668 |     int startIdx = 0;\n1669 |     if (static_cast<int>(allLines.size()) > lines) {\n1670 |         startIdx = static_cast<int>(allLines.size()) - lines;\n1671 |     }\n1672 | \n1673 |     Json::Value response;\n1674 |     response[\"file\"] = fileName;\n1675 |     response[\"total_lines\"] = static_cast<Json::Int64>(allLines.size());\n1676 |     response[\"returned_lines\"] = static_cast<Json::Int64>(allLines.size() - startIdx);\n1677 | \n1678 |     Json::Value linesArray(Json::arrayValue);\n1679 |     for (int i = startIdx; i < static_cast<int>(allLines.size()); ++i) {\n1680 |         linesArray.append(allLines[i]);\n1681 |     }\n1682 |     response[\"lines\"] = linesArray;\n1683 | \n1684 |     auto now = std::chrono::system_clock::now();\n1685 |     auto tt = std::chrono::system_clock::to_time_t(now);\n1686 |     char buf[32];\n1687 |     std::strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", std::localtime(&tt));\n1688 |     response[\"timestamp\"] = std::string(buf);\n1689 | \n1690 |     auto resp = HttpResponse::newHttpJsonResponse(response);\n1691 |     resp->setStatusCode(k200OK);\n1692 |     callback(resp);\n1693 | }\n\n\n---\n\nFile: aiapi/src/apipoint/chaynsapi/chaynsapi.h\nLines 1-64:\n 1 | #ifndef CHAYNSAPI_H\n 2 | #define CHAYNSAPI_H\n 3 | #include <accountManager/accountManager.h>\n 4 | #include \"../../sessionManager/Session.h\"\n 5 | #include \"../../apiManager/ApiFactory.h\"\n 6 | #include <list>\n 7 | #include <map>\n 8 | #include <random>\n 9 | #include <sstream>\n10 | #include <iomanip>\n11 | #include <vector>\n12 | \n13 | const int MAX_RETRIES = 6000;  // 轮询最大重试次数\n14 | const int BASE_DELAY = 100;  // 轮询重试间隔（毫秒）\n15 | const int CONSECUTIVE_FAILS_BEFORE_SWITCH = 3;  // 连续失败n次后换账号\n16 | const int MAX_UPSTREAM_RETRIES = 4;  // 上游最大总重试次数（外层循环，每次创建新线程或换账号）\n17 | const int SAME_THREAD_RETRIES = 2;  // 同一线程上的最大重试次数（内层循环，在同一线程上重新发送消息）\n18 | // 上游错误文本列表从 config.json 的 custom_config.upstream_error_texts 加载\n19 | \n20 | std::string generateGuid();\n21 | \n22 | using namespace std;\n23 | \n24 | class chaynsapi:public APIinterface\n25 | {\n26 |     public:\n27 |         static void* createApi();\n28 |         void postChatMessage(session_st& session);\n29 |         void checkAlivableTokens();\n30 |         void checkModels();\n31 |         Json::Value getModels();\n32 |         void init();\n33 |         ~chaynsapi();\n34 |         void afterResponseProcess(session_st& session);\n35 |         void eraseChatinfoMap(string ConversationId);\n36 |         void transferThreadContext(const std::string& oldId, const std::string& newId) override;\n37 | \n38 |     private:\n39 |         DEClARE_RUNTIME(chaynsapi);\n40 |         map<string,Json::Value> modelInfoMap; //modelname:modelinfo\n41 |         Json::Value model_info_openai_format;//v1/models openai接口格式\n42 | \n43 |         void loadModels();\n44 |         bool checkAlivableToken(string token);\n45 |         // 上传图片到 image-service，返回上传后的URL\n46 |         std::string uploadImageToService(const ImageInfo& image, const std::string& personId, const std::string& authToken);\n47 | \n48 |         chaynsapi();\n49 |     \n50 |     // 定义一个结构体保存线程上下文信息\n51 |     struct ThreadContext {\n52 |         std::string threadId;\n53 |         std::string userAuthorId; // Bot在该线程中的AuthorID，用于轮询时过滤\n54 |         std::string accountUserName; // 创建该thread时使用的账户userName，用于后续请求使用相同账户\n55 |     };\n56 | \n57 |     // 映射表: ConversationId -> ThreadContext\n58 |     std::map<std::string, ThreadContext> m_threadMap;\n59 |     std::mutex m_threadMapMutex;\n60 | \n61 |     // 上游错误文本列表，从 config.json 的 custom_config.upstream_error_texts 加载\n62 |     std::vector<std::string> m_upstreamErrorTexts;\n63 | };\n64 | #endif\n\n<environment_details>\n# VSCode Visible Files\naiapi/src/build/logs/aiapi.log\n\n# VSCode Open Tabs\naiapi/src/build/logs/aiapi.log,aiapi/src/sessionManager/GenerationService.cpp,aiapi/src/build/logs/1.txt,aiapi/src/sessionManager/XmlTagToolCallCodec.cpp,aiapi/src/sessionManager/XmlTagToolCallCodec.h,aiapi/src/apipoint/chaynsapi/chaynsapi.cpp,aiapi/src/apipoint/chaynsapi/chaynsapi.h,aiapi/doc/aiapi_callflow_and_api_examples.md,aiapi/README.md,aiapi/src/controllers/AiApi.cc,aiapi/src/accountManager/accountManager.h,aiapi/src/accountManager/accountManager.cpp,aiapi_web/src/components/LogViewer.tsx,aiapi_web/src/components/LogViewer.css,aiapi_web/src/App.tsx,aiapi_web/src/components/AccountManager.tsx,aiapi_web/src/components/AccountManager.css,aiapi/src/controllers/AiApi.h,aiapi/src/main.cc,aiapi/src/config.json\n\n# Current Time\nCurrent time in ISO 8601 UTC format: 2026-02-07T15:07:52.835Z\nUser time zone: America/Los_Angeles, UTC-8:00\n\n# Current Cost\n$0.00\n\n# Current Mode\n<slug>architect</slug>\n<name>Architect</name>\n<model>Claude Opus 4.6</model>\n<tool_format>native</tool_format>\nYou have not created a todo list yet. Create one with `update_todo_list` if your task is complicated or involves multiple steps.\n</environment_details>"}],"stream":true,"stream_options":{"include_usage":true},"tools":[{"type":"function","function":{"name":"delete_file","description":"Delete a file or directory from the workspace. This action is irreversible and requires user approval. For directories, all contained files are validated against protection rules and .kilocodeignore before deletion. Cannot delete write-protected files or paths outside the workspace.","strict":true,"parameters":{"type":"object","properties":{"path":{"type":"string","description":"Path to the file or directory to delete, relative to the workspace"}},"required":["path"],"additionalProperties":false}}},{"type":"function","function":{"name":"apply_diff","description":"Apply precise, targeted modifications to an existing file using one or more search/replace blocks. This tool is for surgical edits only; the 'SEARCH' block must exactly match the existing content, including whitespace and indentation. To make multiple targeted changes, provide multiple SEARCH/REPLACE blocks in the 'diff' parameter. Use the 'read_file' tool first if you are not confident in the exact content to search for.","parameters":{"type":"object","properties":{"path":{"type":"string","description":"The path of the file to modify, relative to the current workspace directory."},"diff":{"type":"string","description":"A string containing one or more search/replace blocks defining the changes. The ':start_line:' is required and indicates the starting line number of the original content. You must not add a start line for the replacement content. Each block must follow this format:\n<<<<<<< SEARCH\n:start_line:[line_number]\n-------\n[exact content to find]\n=======\n[new content to replace with]\n>>>>>>> REPLACE"}},"required":["path","diff"],"additionalProperties":false},"strict":true}},{"type":"function","function":{"name":"ask_followup_question","description":"Ask the user a question to gather additional information needed to complete the task. Use when you need clarification or more details to proceed effectively.\n\nParameters:\n- question: (required) A clear, specific question addressing the information needed\n- follow_up: (required) A list of 2-4 suggested answers. Suggestions must be complete, actionable answers without placeholders. Optionally include mode to switch modes (code/architect/etc.)\n\nExample: Asking for file path\n{ \"question\": \"What is the path to the frontend-config.json file?\", \"follow_up\": [{ \"text\": \"./src/frontend-config.json\", \"mode\": null }, { \"text\": \"./config/frontend-config.json\", \"mode\": null }, { \"text\": \"./frontend-config.json\", \"mode\": null }] }\n\nExample: Asking with mode switch\n{ \"question\": \"Would you like me to implement this feature?\", \"follow_up\": [{ \"text\": \"Yes, implement it now\", \"mode\": \"code\" }, { \"text\": \"No, just plan it out\", \"mode\": \"architect\" }] }","strict":true,"parameters":{"type":"object","properties":{"question":{"type":"string","description":"Clear, specific question that captures the missing information you need"},"follow_up":{"type":"array","description":"Required list of 2-4 suggested responses; each suggestion must be a complete, actionable answer and may include a mode switch","items":{"type":"object","properties":{"text":{"type":"string","description":"Suggested answer the user can pick"},"mode":{"type":["string","null"],"description":"Optional mode slug to switch to if this suggestion is chosen (e.g., code, architect)"}},"required":["text","mode"],"additionalProperties":false},"minItems":1,"maxItems":4}},"required":["question","follow_up"],"additionalProperties":false}}},{"type":"function","function":{"name":"attempt_completion","description":"After each tool use, the user will respond with the result of that tool use, i.e. if it succeeded or failed, along with any reasons for failure. Once you've received the results of tool uses and can confirm that the task is complete, use this tool to present the result of your work to the user. The user may respond with feedback if they are not satisfied with the result, which you can use to make improvements and try again.\n\nIMPORTANT NOTE: This tool CANNOT be used until you've confirmed from the user that any previous tool uses were successful. Failure to do so will result in code corruption and system failure. Before using this tool, you must confirm that you've received successful results from the user for any previous tool uses. If not, then DO NOT use this tool.\n\nParameters:\n- result: (required) The result of the task. Formulate this result in a way that is final and does not require further input from the user. Don't end your result with questions or offers for further assistance.\n\nExample: Completing after updating CSS\n{ \"result\": \"I've updated the CSS to use flexbox layout for better responsiveness\" }","strict":true,"parameters":{"type":"object","properties":{"result":{"type":"string","description":"Final result message to deliver to the user once the task is complete"}},"required":["result"],"additionalProperties":false}}},{"type":"function","function":{"name":"browser_action","description":"Request to interact with a Puppeteer-controlled browser. Every action, except close, will be responded to with a screenshot of the browser's current state, along with any new console logs. You may only perform one browser action per message, and wait for the user's response including a screenshot and logs to determine the next action.\n\nThis tool is particularly useful for web development tasks as it allows you to launch a browser, navigate to pages, interact with elements through clicks and keyboard input, and capture the results through screenshots and console logs. Use it at key stages of web development tasks - such as after implementing new features, making substantial changes, when troubleshooting issues, or to verify the result of your work. Analyze the provided screenshots to ensure correct rendering or identify errors, and review console logs for runtime issues.\n\nThe user may ask generic non-development tasks (such as \"what's the latest news\" or \"look up the weather\"), in which case you might use this tool to complete the task if it makes sense to do so, rather than trying to create a website or using curl to answer the question. However, if an available MCP server tool or resource can be used instead, you should prefer to use it over browser_action.\n\nBrowser Session Lifecycle:\n- Browser sessions start with launch and end with close\n- The session remains active across multiple messages and tool uses\n- You can use other tools while the browser session is active - it will stay open in the background","strict":true,"parameters":{"type":"object","properties":{"action":{"type":"string","description":"Browser action to perform","enum":["launch","click","hover","type","press","scroll_down","scroll_up","resize","close","screenshot"]},"url":{"type":["string","null"],"description":"URL to open when performing the launch action; must include protocol"},"coordinate":{"type":["string","null"],"description":"Screen coordinate for hover or click actions in format 'x,y@WIDTHxHEIGHT' where x,y is the target position on the screenshot image and WIDTHxHEIGHT is the exact pixel dimensions of the screenshot image (not the browser viewport). Example: '450,203@900x600' means click at (450,203) on a 900x600 screenshot. The coordinates will be automatically scaled to match the actual viewport dimensions."},"size":{"type":["string","null"],"description":"Viewport dimensions for the resize action in format 'WIDTHxHEIGHT' or 'WIDTH,HEIGHT'. Example: '1280x800' or '1280,800'"},"text":{"type":["string","null"],"description":"Text to type when performing the type action, or key name to press when performing the press action (e.g., 'Enter', 'Tab', 'Escape')"},"path":{"type":["string","null"],"description":"File path where the screenshot should be saved (relative to workspace). Required for screenshot action. Supports .png, .jpeg, and .webp extensions. Example: 'screenshots/result.png'"}},"required":["action","url","coordinate","size","text","path"],"additionalProperties":false}}},{"type":"function","function":{"name":"fetch_instructions","description":"Retrieve detailed instructions for performing a predefined task, such as creating an MCP server or creating a mode.","strict":true,"parameters":{"type":"object","properties":{"task":{"type":"string","description":"Task identifier to fetch instructions for","enum":["create_mcp_server","create_mode"]}},"required":["task"],"additionalProperties":false}}},{"type":"function","function":{"name":"list_files","description":"Request to list files and directories within the specified directory. If recursive is true, it will list all files and directories recursively. If recursive is false or not provided, it will only list the top-level contents. Do not use this tool to confirm the existence of files you may have created, as the user will let you know if the files were created successfully or not.\n\nParameters:\n- path: (required) The path of the directory to list contents for (relative to the current workspace directory)\n- recursive: (required) Whether to list files recursively. Use true for recursive listing, false for top-level only.\n\nExample: Listing all files in the current directory (top-level only)\n{ \"path\": \".\", \"recursive\": false }\n\nExample: Listing all files recursively in src directory\n{ \"path\": \"src\", \"recursive\": true }","strict":true,"parameters":{"type":"object","properties":{"path":{"type":"string","description":"Directory path to inspect, relative to the workspace"},"recursive":{"type":"boolean","description":"Set true to list contents recursively; false to show only the top level"}},"required":["path","recursive"],"additionalProperties":false}}},{"type":"function","function":{"name":"new_task","description":"This will let you create a new task instance in the chosen mode using your provided message and initial todo list (if required).","strict":true,"parameters":{"type":"object","properties":{"mode":{"type":"string","description":"Slug of the mode to begin the new task in (e.g., code, debug, architect)"},"message":{"type":"string","description":"Initial user instructions or context for the new task"},"todos":{"type":["string","null"],"description":"Optional initial todo list written as a markdown checklist; required when the workspace mandates todos"}},"required":["mode","message","todos"],"additionalProperties":false}}},{"type":"function","function":{"name":"read_file","description":"Read one or more files and return their contents with line numbers for diffing or discussion. IMPORTANT: You can read a maximum of 5 files in a single request. If you need to read more files, use multiple sequential read_file requests. Structure: { files: [{ path: 'relative/path.ts' }] }. The 'path' is required and relative to workspace. Supports text extraction from PDF and DOCX files. Automatically processes and returns image files (PNG, JPG, JPEG, GIF, BMP, SVG, WEBP, ICO, AVIF) for visual analysis. May not handle other binary files properly. Example single file: { files: [{ path: 'src/app.ts' }] }. Example multiple files (within 5-file limit): { files: [{ path: 'file1.ts' }, { path: 'file2.ts' }] }","strict":true,"parameters":{"type":"object","properties":{"files":{"type":"array","description":"List of files to read; request related files together when allowed","items":{"type":"object","properties":{"path":{"type":"string","description":"Path to the file to read, relative to the workspace"}},"required":["path"],"additionalProperties":false},"minItems":1}},"required":["files"],"additionalProperties":false}}},{"type":"function","function":{"name":"edit_file","description":"Use this tool to replace text in an existing file, or create a new file.\n\nThis tool performs literal string replacement with support for multiple occurrences.\n\nTo be resilient to minor formatting drift, the tool normalizes line endings (CRLF/LF) for matching and may fall back to deterministic matching strategies when an exact literal match fails (exact → whitespace-tolerant match → token-based match). The original file's line endings are preserved when writing.\n\nUSAGE PATTERNS:\n\n1. MODIFY EXISTING FILE (default):\n   - Provide file_path, old_string (text to find), and new_string (replacement)\n   - By default, expects exactly 1 occurrence of old_string\n   - Use expected_replacements to replace multiple occurrences\n\n2. CREATE NEW FILE:\n   - Set old_string to empty string \"\"\n   - new_string becomes the entire file content\n   - File must not already exist\n\nCRITICAL REQUIREMENTS:\n\n1. EXACT MATCHING (BEST): The old_string should match the file contents EXACTLY, including:\n    - All whitespace (spaces, tabs, newlines)\n    - All indentation\n    - All punctuation and special characters\n\n2. CONTEXT FOR UNIQUENESS: For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text to ensure uniqueness.\n\n3. MULTIPLE REPLACEMENTS: If you need to replace multiple identical occurrences:\n   - Set expected_replacements to the exact count you expect to replace\n   - ALL occurrences will be replaced\n\n4. NO ESCAPING: Provide the literal text - do not escape special characters.","parameters":{"type":"object","properties":{"file_path":{"type":"string","description":"The path to the file to modify or create. You can use either a relative path in the workspace or an absolute path. If an absolute path is provided, it will be preserved as is."},"old_string":{"type":"string","description":"The exact literal text to replace (must match the file contents exactly, including all whitespace and indentation). For single replacements (default), include at least 3 lines of context BEFORE and AFTER the target text. Use empty string to create a new file."},"new_string":{"type":"string","description":"The exact literal text to replace old_string with. When creating a new file (old_string is empty), this becomes the file content."},"expected_replacements":{"type":"number","description":"Number of replacements expected. Defaults to 1 if not specified. Use when you want to replace multiple occurrences of the same text.","minimum":1}},"required":["file_path","old_string","new_string","expected_replacements"],"additionalProperties":false},"strict":true}},{"type":"function","function":{"name":"search_files","description":"Request to perform a regex search across files in a specified directory, providing context-rich results. This tool searches for patterns or specific content across multiple files, displaying each match with encapsulating context.\n\nCraft your regex patterns carefully to balance specificity and flexibility. Use this tool to find code patterns, TODO comments, function definitions, or any text-based information across the project. The results include surrounding context, so analyze the surrounding code to better understand the matches. Leverage this tool in combination with other tools for more comprehensive analysis.\n\nParameters:\n- path: (required) The path of the directory to search in (relative to the current workspace directory). This directory will be recursively searched.\n- regex: (required) The regular expression pattern to search for. Uses Rust regex syntax.\n- file_pattern: (optional) Glob pattern to filter files (e.g., '*.ts' for TypeScript files). If not provided, it will search all files (*).\n\nExample: Searching for all .ts files in the current directory\n{ \"path\": \".\", \"regex\": \".*\", \"file_pattern\": \"*.ts\" }\n\nExample: Searching for function definitions in JavaScript files\n{ \"path\": \"src\", \"regex\": \"function\\s+\\w+\", \"file_pattern\": \"*.js\" }","strict":true,"parameters":{"type":"object","properties":{"path":{"type":"string","description":"Directory to search recursively, relative to the workspace"},"regex":{"type":"string","description":"Rust-compatible regular expression pattern to match"},"file_pattern":{"type":["string","null"],"description":"Optional glob to limit which files are searched (e.g., *.ts)"}},"required":["path","regex","file_pattern"],"additionalProperties":false}}},{"type":"function","function":{"name":"switch_mode","description":"Request to switch to a different mode. This tool allows modes to request switching to another mode when needed, such as switching to Code mode to make code changes. The user must approve the mode switch.","strict":true,"parameters":{"type":"object","properties":{"mode_slug":{"type":"string","description":"Slug of the mode to switch to (e.g., code, ask, architect)"},"reason":{"type":"string","description":"Explanation for why the mode switch is needed"}},"required":["mode_slug","reason"],"additionalProperties":false}}},{"type":"function","function":{"name":"update_todo_list","description":"Replace the entire TODO list with an updated checklist reflecting the current state. Always provide the full list; the system will overwrite the previous one. This tool is designed for step-by-step task tracking, allowing you to confirm completion of each step before updating, update multiple task statuses at once (e.g., mark one as completed and start the next), and dynamically add new todos discovered during long or complex tasks.\n\nChecklist Format:\n- Use a single-level markdown checklist (no nesting or subtasks)\n- List todos in the intended execution order\n- Status options: [ ] (pending), [x] (completed), [-] (in progress)\n\nCore Principles:\n- Before updating, always confirm which todos have been completed\n- You may update multiple statuses in a single update\n- Add new actionable items as they're discovered\n- Only mark a task as completed when fully accomplished\n- Keep all unfinished tasks unless explicitly instructed to remove\n\nExample: Initial task list\n{ \"todos\": \"[x] Analyze requirements\\n[x] Design architecture\\n[-] Implement core logic\\n[ ] Write tests\\n[ ] Update documentation\" }\n\nExample: After completing implementation\n{ \"todos\": \"[x] Analyze requirements\\n[x] Design architecture\\n[x] Implement core logic\\n[-] Write tests\\n[ ] Update documentation\\n[ ] Add performance benchmarks\" }\n\nWhen to Use:\n- Task involves multiple steps or requires ongoing tracking\n- Need to update status of several todos at once\n- New actionable items are discovered during execution\n- Task is complex and benefits from stepwise progress tracking\n\nWhen NOT to Use:\n- Only a single, trivial task\n- Task can be completed in one or two simple steps\n- Request is purely conversational or informational","strict":true,"parameters":{"type":"object","properties":{"todos":{"type":"string","description":"Full markdown checklist in execution order, using [ ] for pending, [x] for completed, and [-] for in progress"}},"required":["todos"],"additionalProperties":false}}},{"type":"function","function":{"name":"write_to_file","description":"Request to write content to a file. This tool is primarily used for creating new files or for scenarios where a complete rewrite of an existing file is intentionally required. If the file exists, it will be overwritten. If it doesn't exist, it will be created. This tool will automatically create any directories needed to write the file.\n\n**Important:** You should prefer using other editing tools over write_to_file when making changes to existing files, since write_to_file is slower and cannot handle large files. Use write_to_file primarily for new file creation.\n\nWhen using this tool, use it directly with the desired content. You do not need to display the content before using the tool. ALWAYS provide the COMPLETE file content in your response. This is NON-NEGOTIABLE. Partial updates or placeholders like '// rest of code unchanged' are STRICTLY FORBIDDEN. Failure to do so will result in incomplete or broken code.\n\nWhen creating a new project, organize all new files within a dedicated project directory unless the user specifies otherwise. Structure the project logically, adhering to best practices for the specific type of project being created.\n\nExample: Writing a configuration file\n{ \"path\": \"frontend-config.json\", \"content\": \"{\\n  \\\"apiEndpoint\\\": \\\"https://api.example.com\\\",\\n  \\\"theme\\\": {\\n    \\\"primaryColor\\\": \\\"#007bff\\\"\\n  }\\n}\" }","strict":true,"parameters":{"type":"object","properties":{"path":{"type":"string","description":"The path of the file to write to (relative to the current workspace directory)"},"content":{"type":"string","description":"The content to write to the file. ALWAYS provide the COMPLETE intended content of the file, without any truncation or omissions. You MUST include ALL parts of the file, even if they haven't been modified. Do NOT include line numbers in the content."}},"required":["path","content"],"additionalProperties":false}}}],"tool_choice":"auto"}